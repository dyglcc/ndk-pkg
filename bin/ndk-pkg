#!/bin/sh

# Copyright (c) 2020-2022 åˆ˜å¯Œé¢‘
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# https://developer.android.google.cn/ndk/guides/other_build_systems
# https://clang.llvm.org/docs/CrossCompilation.html


_0=$0

unset CURRENT_SCRIPT_DIR
unset CURRENT_SCRIPT_FILENAME
unset CURRENT_SCRIPT_FILEPATH

CURRENT_SCRIPT_DIR=$(cd "$(dirname "$0")" && pwd) || exit 1
CURRENT_SCRIPT_FILENAME=$(basename "$0")
CURRENT_SCRIPT_FILEPATH="$CURRENT_SCRIPT_DIR/$CURRENT_SCRIPT_FILENAME"


COLOR_RED='\033[0;31m'          # Red
COLOR_GREEN='\033[0;32m'        # Green
COLOR_YELLOW='\033[0;33m'       # Yellow
COLOR_BLUE='\033[0;94m'         # Blue
COLOR_PURPLE='\033[0;35m'       # Purple
COLOR_OFF='\033[0m'             # Reset

print() {
    printf '%b' "$*"
}

echo() {
    printf '%b\n' "$*"
}

note() {
    printf '%b\n' "${COLOR_YELLOW}ðŸ””  $*${COLOR_OFF}" >&2
}

warn() {
    printf '%b\n' "${COLOR_YELLOW}ðŸ”¥  $*${COLOR_OFF}" >&2
}

success() {
    printf '%b\n' "${COLOR_GREEN}[âœ”] $*${COLOR_OFF}" >&2
}

error() {
    printf '%b\n' "${COLOR_RED}ðŸ’”  $*${COLOR_OFF}" >&2
}

die() {
    printf '%b\n' "${COLOR_RED}ðŸ’”  $*${COLOR_OFF}" >&2
    exit 1
}

bppend_to_PATH() {
    case ":${PATH}:" in
        *:"$1":*) ;;
        *) export PATH="$1:$PATH" ;;
    esac
}

# check if file exists
# $1 FILEPATH
file_exists() {
    [ -n "$1" ] && [ -e "$1" ]
}

# check if command exists in filesystem
# $1 command name or path
command_exists_in_filesystem() {
    case $1 in
        '') return 1 ;;
        */*)
            case $(uname | tr A-Z a-z) in
                cygwin*)
                    case $1 in
                        /cygdrive/*/choco) executable "$1" ;;
                        /cygdrive/*) return 1 ;;
                        *) executable "$1" ;;
                    esac
                    ;;
                *) executable "$1" ;;
            esac
            ;;
        *)  command_exists_in_filesystem $(command -v "$1" || true)
    esac
}

executable() {
    file_exists "$1" && [ -x "$1" ]
}

step() {
    STEP_NUM=$(expr ${STEP_NUM-0} + 1)
    STEP_MESSAGE="$@"
    printf '%s\n'
    printf '%b\n' "${COLOR_PURPLE}=>> STEP ${STEP_NUM} : ${STEP_MESSAGE} ${COLOR_OFF}"
}

step2() {
    STEP2_NUM=$(expr ${STEP2_NUM-0} + 1)
    STEP2_MESSAGE="$@"
    printf '%s\n'
    printf '%b\n' "${COLOR_BLUE}>>> STEP ${STEP_NUM}.${STEP2_NUM} : ${STEP2_MESSAGE} ${COLOR_OFF}"
}

run() {
    if [ "$RUN_SILENT" != yes ] ; then
        echo "${COLOR_PURPLE}==>${COLOR_OFF} ${COLOR_GREEN}$@${COLOR_OFF}"
    fi

    eval "$*"
}

list() {
    for item in $@
    do
        printf '%s\n' "$item"
    done
}

list_length() {
    printf '%s\n' $#
}

shiftn() {
    shift "$1" && shift && printf '%s\n' "$@"
}

globing() {
    case $1 in
        '')   ;;
        \~/*) printf '%s\n' "$HOME/$(printf '%s\n' "$1" | cut -c3-)" ;;
        *)    printf '%s\n' "$1"
    esac
}

sed_in_place() {
    if command -v gsed > /dev/null ; then
        unset SED_IN_PLACE_ACTION
        SED_IN_PLACE_ACTION="$1"
        shift
        # contains ' but not contains \'
        if printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" " "' | grep -q 27 && ! printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" ""' | grep -q '5C 27' ; then
            run gsed -i "\"$SED_IN_PLACE_ACTION\"" $@
        else
            run gsed -i "'$SED_IN_PLACE_ACTION'" $@
        fi
    elif command -v sed  > /dev/null ; then
        if sed -i 's/a/b/g' $(mktemp) 2> /dev/null ; then
            unset SED_IN_PLACE_ACTION
            SED_IN_PLACE_ACTION="$1"
            shift
            if printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" " "' | grep -q 27 && ! printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" ""' | grep -q '5C 27' ; then
                run sed -i "\"$SED_IN_PLACE_ACTION\"" $@
            else
                run sed -i "'$SED_IN_PLACE_ACTION'" $@
            fi
        else
            unset SED_IN_PLACE_ACTION
            SED_IN_PLACE_ACTION="$1"
            shift
            if printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" " "' | grep -q 27 && ! printf "$SED_IN_PLACE_ACTION" | hexdump -v -e '1/1 "%02X" ""' | grep -q '5C 27' ; then
                run sed -i '""' "\"$SED_IN_PLACE_ACTION\"" $@
            else
                run sed -i '""' "'$SED_IN_PLACE_ACTION'" $@
            fi
        fi
    else
        error "please install sed utility."
        return 1
    fi
}

getvalue() {
    if [ $# -eq 0 ] ; then
        cut -d= -f2
    else
        printf '%s\n' "$1" | cut -d= -f2
    fi
}

trim() {
    if [ $# -eq 0 ] ; then
        sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//'
    else
        if [ -n "$*" ] ; then
            printf '%s\n' "$*" | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//'
        fi
    fi
}

tolower() {
    if [ $# -eq 0 ] ; then
        if command -v tr > /dev/null ; then
            tr A-Z a-z
        elif command -v  awk > /dev/null ; then
            awk '{print(tolower($0))}'
        elif command -v gawk > /dev/null ; then
            gawk '{print(tolower($0))}'
        else
            error "please install GNU CoreUtils or awk."
            return 1
        fi
    else
        if [ -z "$*" ] ; then
            return 0
        fi
        if command -v tr > /dev/null ; then
            printf '%s\n' "$*" | tr A-Z a-z
        elif command -v  awk > /dev/null ; then
            printf '%s\n' "$*" | awk '{print(tolower($0))}'
        elif command -v gawk > /dev/null ; then
            printf '%s\n' "$*" | gawk '{print(tolower($0))}'
        elif command -v python > /dev/null ; then
            python  -c 'import sys; print(sys.argv[1].lower());' "$*"
        elif command -v python3 > /dev/null ; then
            python3 -c 'import sys; print(sys.argv[1].lower());' "$*"
        elif command -v python2 > /dev/null ; then
            python2 -c 'import sys; print(sys.argv[1].lower());' "$*"
        elif command -v perl > /dev/null ; then
            perl -e 'print @ARGV[0],"\n"' "$1"
        elif command -v node > /dev/null ; then
            node -e 'console.log(process.argv[2].toLowerCase())' - "$*"
        else
            error "please install GNU CoreUtils or awk."
            return 1
        fi
    fi
}

own() {
    ls -ld "$1" | cut -d ' ' -f3,4 | tr ' ' ':'
}

is_integer() {
    case "${1#[+-]}" in
        (*[!0123456789]*) return 1 ;;
        ('')              return 1 ;;
        (*)               return 0 ;;
    esac
}

is_elf_file() {
    [ -z "$1" ] && {
        error "is_elf_file <FILE-PATH>, <FILE-PATH> is not given."
        return 1
    }

    [ -e "$1" ] || {
        error "is_elf_file <FILE-PATH>, <FILE-PATH> is not exist."
        return 2
    }

    # http://www.sco.com/developers/gabi/latest/ch4.eheader.html

    if command -v hexdump > /dev/null ; then
        [ "$(hexdump -n 4 -v -e '1/1 "%02X" ""' "$1")" = '7F454C46' ]
    else
        [ "$(head -c 4 "$1")" = "$(printf '\177ELF')" ]
    fi
}

# format_unix_timestamp <TIMESTAMP-UNIX> <TO-FORMAT> [-u]
  format_unix_timestamp() {
   date $3 -jf "%s" "$1" "$2" 2> /dev/null ||
   date $3 -d      "@$1" "$2"
}

# https://equa.space/sh/lolcat/
lolcat_awk() {
    awk -v angle=45 -v angle_phase=40 -v reverse=0 -v offset=195 -v offset_phase=0 -v width=100 -v width_phase=8 "$@" '
    function put_rgb(color) {
        printf "\033[%s38;2;%d;%d;%dm", reverse ? "7;" : "", int(color[1] * 255), int(color[2] * 255), int(color[3] * 255);
    }

    function hsv_to_rgb(hsv, rgb, c, h2, x) {
        c = hsv[2] * hsv[3];
        h2 = hsv[1] * 6;
        x = c * (1 - ((h2 % 2) - 1 > 0 ? (h2 % 2) - 1 : 1 - (h2 % 2)));
        if (int(h2) % 6 == 0) {
            rgb[1] = c; rgb[2] = x; rgb[3] = 0;
        } else if (int(h2) % 6 == 1) {
            rgb[1] = x; rgb[2] = c; rgb[3] = 0;
        } else if (int(h2) % 6 == 2) {
            rgb[1] = 0; rgb[2] = c; rgb[3] = x;
        } else if (int(h2) % 6 == 3) {
            rgb[1] = 0; rgb[2] = x; rgb[3] = c;
        } else if (int(h2) % 6 == 4) {
            rgb[1] = x; rgb[2] = 0; rgb[3] = c;
        } else if (int(h2) % 6 == 5) {
            rgb[1] = c; rgb[2] = 0; rgb[3] = x;
        }

        rgb[1] += hsv[2] - c;
        rgb[2] += hsv[2] - c;
        rgb[3] += hsv[2] - c;
    }

    BEGIN {
        srand();
        if (offset == "") offset = rand() * 360;
    }

    {
        y = NR - 1;
        for (x = 0; x < length($0); x++) {
            for (i = 0; i < 3; i++) {
                mult_x = cos((angle + i * angle_phase) / 57.2976);
                mult_y = sin((angle + i * angle_phase) / 57.2976);
                hsv[1] = (((x * mult_x + y * mult_y) / (width + width_phase * i)) % 1 + 1 + (offset + offset_phase * i) / 360) % 1;
                hsv[2] = 0.8;
                hsv[3] = 0.9;

                hsv_to_rgb(hsv, trgb);
                rgb[i + 1] = trgb[i + 1];
            }

            put_rgb(rgb);
            printf("%s", substr($0, x + 1, 1));
        }
        print "\033[0m";
    }
    '
}

# }}}
##############################################################################
# {{{ md5sum

#examples:
# printf ss | md5sum
# cat FILE  | md5sum
# md5sum < FILE
md5sum() {
    if [ $# -eq 0 ] ; then
        if echo | command md5sum > /dev/null 2>&1 ; then
             command md5sum | cut -d ' ' -f1
        elif command -v openssl > /dev/null ; then
             openssl md5 | rev | cut -d ' ' -f1 | rev
        else
            error "md5sum, neither openssl nor GNU CoreUtils Found."
            return 1
        fi
    else
        [ -e "$1" ] || {
            error "md5sum <PATH-OF-FILE>, PATH-OF-FILE[$1] is not exist."
            return 1
        }

        if command -v openssl > /dev/null ; then
             openssl md5    "$1" | cut -d ' ' -f2
        elif echo | command md5sum > /dev/null 2>&1 ; then
             command md5sum "$1" | cut -d ' ' -f1
        else
            error "md5sum <PATH-OF-FILE>, neither openssl nor GNU CoreUtils Found."
            return 1
        fi
    fi
}

# }}}
##############################################################################
# {{{ sha256sum

#examples:
# printf ss | sha256sum
# cat FILE  | sha256sum
# sha256sum < FILE
sha256sum() {
    if [ $# -eq 0 ] ; then
        if echo | command sha256sum > /dev/null 2>&1 ; then
             command sha256sum | cut -d ' ' -f1
        elif command -v openssl > /dev/null ; then
             openssl sha256 | rev | cut -d ' ' -f1 | rev
        else
            error "sha256sum, neither openssl nor GNU CoreUtils Found."
            return 1
        fi
    else
        [ -e "$1" ] || {
            error "sha256sum <PATH-OF-FILE>, PATH-OF-FILE[$1] is not exist."
            return 1
        }

        if command -v openssl > /dev/null ; then
             openssl sha256    "$1" | cut -d ' ' -f2
        elif echo | command sha256sum > /dev/null 2>&1 ; then
             command sha256sum "$1" | cut -d ' ' -f1
        else
            error "sha256sum <PATH-OF-FILE>, neither openssl nor GNU CoreUtils Found."
            return 1
        fi
    fi
}

# file_exists_and_sha256sum_matched <PATH-OF-FILE> <EXPECTED-SHA256SUM-OF-FILE>
  file_exists_and_sha256sum_matched() {
    [ -z "$1" ] && {
        error "file_exists_and_sha256sum_matched <PATH-OF-FILE> <EXPECTED-SHA256SUM-OF-FILE>, <PATH-OF-FILE> is not given."
        return 1
    }

    [ -z "$2" ] && {
        error "file_exists_and_sha256sum_matched <PATH-OF-FILE> <EXPECTED-SHA256SUM-OF-FILE>, <EXPECTED-SHA256SUM-OF-FILE> is not given."
        return 1
    }

    [ -e "$1" ] || {
        error "file_exists_and_sha256sum_matched <PATH-OF-FILE> <EXPECTED-SHA256SUM-OF-FILE>, PATH-OF-FILE[$1] is not exist."
        return 1
    }

    [ "$(sha256sum $1)" = "$2" ]
}

# }}}
##############################################################################
# {{{ map

# 40   map name is not given.
# 41   map key  is not given.

# __map_name_ref <MAP-NAME>
  __map_name_ref() {
    if [ -z "$1" ] ; then
        error "__map_name_ref <MAP-NAME>, <MAP-NAME> is not given."
        return 40
    fi

    printf "map_%s\n" "$(printf '%s\n' "$1" | md5sum)"
}

# __map_key_ref <MAP-NAME> <MAP-KEY>
  __map_key_ref() {
    if [ -z "$1" ] ; then
        error "__map_key_ref <MAP-NAME> <MAP-KEY>, <MAP-NAME> is not given."
        return 40
    fi

    if [ -z "$2" ] ; then
        error "__map_key_ref <MAP-NAME> <MAP-KEY>, <MAP-KEY> is not given."
        return 41
    fi

    printf "%s_key_%s\n" "$(__map_name_ref "$1")" "$(printf '%s\n' "$2" | md5sum)"
}

# map_contains <MAP-NAME> <MAP-KEY>
  map_contains() {
    if [ -z "$1" ] ; then
        error "map_contains <MAP-NAME> <MAP-KEY>, <MAP-NAME> is not given."
        return 40
    fi

    if [ -z "$2" ] ; then
        error "map_contains <MAP-NAME> <MAP-KEY>, <MAP-KEY> is not given."
        return 41
    fi

    for item in $(eval echo \$$(__map_name_ref "$1"))
    do
        if [ "$item" = "$2" ] ; then
            return 0
        fi
    done

    return 1
}

# map_set <MAP-NAME> <MAP-KEY> <MAP-VALUE>
  map_set() {
    if [ -z "$1" ] ; then
        error "map_set <MAP-NAME> <MAP-KEY> <MAP-VALUE>, <MAP-NAME> is not given."
        return 40
    fi

    if [ -z "$2" ] ; then
        error "map_set <MAP-NAME> <MAP-KEY> <MAP-VALUE>, <MAP-KEY> is not given."
        return 41
    fi

    map_contains "$1" "$2" || {
        unset __MAP_NAME_REF__
        __MAP_NAME_REF__="$(__map_name_ref "$1")"
        __MAP_NAME_REF_VALUE__="$(eval echo \$$__MAP_NAME_REF__)"
        eval "$__MAP_NAME_REF__=\"$__MAP_NAME_REF_VALUE__ $2\""
    }

    eval "$(__map_key_ref "$1" "$2")=$3"
}

# map_get <MAP-NAME> <MAP-KEY>
  map_get() {
    if [ -z "$1" ] ; then
        error "map_get <MAP-NAME> <MAP-KEY>, <MAP-NAME> is not given."
        return 40
    fi

    if [ -z "$2" ] ; then
        error "map_get <MAP-NAME> <MAP-KEY>, <MAP-KEY> is not given."
        return 41
    fi

    eval echo "\$$(__map_key_ref "$1" "$2")"
}

# map_remove <MAP-NAME> <MAP-KEY>
  map_remove() {
    if [ -z "$1" ] ; then
        error "map_remove <MAP-NAME> <MAP-KEY>, <MAP-NAME> is not given."
        return 40
    fi

    if [ -z "$2" ] ; then
        error "map_remove <MAP-NAME> <MAP-KEY>, <MAP-KEY> is not given."
        return 41
    fi

    unset __MAP_NAME_REF__
    __MAP_NAME_REF__="$(__map_name_ref "$1")"

    unset __MAP_KEYS__
    __MAP_KEYS__="$(map_keys "$1")"

    unset $__MAP_NAME_REF__

    for item in $__MAP_KEYS__
    do
        if [ "$item" = "$2" ] ; then
            continue
        else
            eval "$__MAP_NAME_REF__='$(eval echo \$$__MAP_NAME_REF__) $item'"
        fi
    done

    eval "unset $(__map_key_ref "$1" "$2")"
}

# map_remove <MAP-NAME>
  map_clear() {
    if [ -z "$1" ] ; then
        error "map_clear <MAP-NAME>, <MAP-NAME> is not given."
        return 40
    fi

    unset __MAP_NAME_REF__
    __MAP_NAME_REF__="$(__map_name_ref "$1")"

    for item in $(eval echo "\$$__MAP_NAME_REF__")
    do
        eval "unset $(__map_key_ref "$1" "$item")"
    done

    eval "unset $__MAP_NAME_REF__"
}

# map_keys <MAP-NAME>
  map_keys() {
    if [ -z "$1" ] ; then
        error "map_keys <MAP-NAME>, <MAP-NAME> is not given."
        return 40
    fi

    eval echo "\$$(__map_name_ref "$1")"
}

# map_size <MAP-NAME>
  map_size() {
    if [ -z "$1" ] ; then
        error "map_size <MAP-NAME>, <MAP-NAME> is not given."
        return 40
    fi

    list_length $(map_keys "$1")
}

# }}}
##############################################################################
# {{{ fetch

# fetch <URL> [--silent] [--sha256=SHA256] <--output-path=PATH>
# fetch <URL> [--silent] [--sha256=SHA256] <--output-dir=DIR> <--output-name=NAME>
# fetch <URL> [--silent] [--sha256=SHA256] <--output-dir=DIR> [--output-name=NAME]
# fetch <URL> [--silent] [--sha256=SHA256] [--output-dir=DIR] <--output-name=NAME>
fetch() {
    unset FETCH_URL
    unset FETCH_SHA256
    unset FETCH_OUTPUT_DIR
    unset FETCH_OUTPUT_NAME
    unset FETCH_OUTPUT_PATH
    unset FETCH_SILENT

    if [ -z "$1" ] ; then
        error "fetch <URL> [OPTION]... , <URL> must not be empty."
        return 1
    else
        if [ "$COUNTRY" = 'china' ] ; then
            FETCH_URL="$(get_china_mirror_url "$1")"
        else
            FETCH_URL="$1"
        fi
    fi

    shift

    while [ -n "$1" ]
    do
        case $1 in
            --silent)
                FETCH_SILENT=yes
                RUN_SILENT=yes
                ;;
            --sha256=*)
                FETCH_SHA256=$(getvalue "$1")
                ;;
            --output-dir=*)
                FETCH_OUTPUT_DIR=$(getvalue "$1")
                if [ -z "$FETCH_OUTPUT_DIR" ] ; then
                    error "fetch <URL> --output-dir=<DIR> , <DIR> must not be empty."
                    return 1
                fi
                ;;
            --output-name=*)
                FETCH_OUTPUT_NAME=$(getvalue "$1")
                if [ -z "$FETCH_OUTPUT_NAME" ] ; then
                    error "fetch <URL> --output-name=<NAME> , <NAME> must not be empty."
                    return 1
                fi
                ;;
            --output-path=*)
                FETCH_OUTPUT_PATH=$(getvalue "$1")
                if [ -z "$FETCH_OUTPUT_PATH" ] ; then
                    error "fetch <URL> --output-path=<FILEPATH> , <FILEPATH> must not be empty."
                    return 1
                fi
                ;;
            *)  error "fetch <URL> [OPTION]..., unrecognized option: $1

    fetch command usage:

    fetch <URL> [--silent] [--sha256=SHA256] <--output-path=PATH>
    fetch <URL> [--silent] [--sha256=SHA256] <--output-dir=DIR> <--output-name=NAME>
    fetch <URL> [--silent] [--sha256=SHA256] <--output-dir=DIR> [--output-name=NAME]
    fetch <URL> [--silent] [--sha256=SHA256] [--output-dir=DIR] <--output-name=NAME>"
                return 1
        esac
        shift
    done

    if [ -z "$FETCH_OUTPUT_PATH" ] ; then
        if [ -z "$FETCH_OUTPUT_DIR" ] && [ -z "$FETCH_OUTPUT_NAME" ] ; then
            FETCH_OUTPUT_PATH='-'
        else
            if [ -z "$FETCH_OUTPUT_DIR" ] ; then
                FETCH_OUTPUT_DIR="$PWD"
            fi

            if [ -z "$FETCH_OUTPUT_NAME" ] ; then
                FETCH_OUTPUT_NAME=$(basename "$FETCH_URL")
            fi

            FETCH_OUTPUT_PATH="$FETCH_OUTPUT_DIR/$FETCH_OUTPUT_NAME"

            if [ !          -d "$FETCH_OUTPUT_DIR" ] ; then
                run install -d "$FETCH_OUTPUT_DIR" || return 1
            fi
        fi
    elif [ "$FETCH_OUTPUT_PATH" = '-' ] ; then
        unset FETCH_OUTPUT_DIR
        unset FETCH_OUTPUT_NAME
    else
        FETCH_OUTPUT_DIR="$(dirname $FETCH_OUTPUT_PATH)"
        FETCH_OUTPUT_NAME="$(basename $FETCH_OUTPUT_PATH)"
        if [ !          -d "$FETCH_OUTPUT_DIR" ] ; then
            run install -d "$FETCH_OUTPUT_DIR" || return 1
        fi
    fi

    case $FETCH_URL in
        *.git)
            if [    -d "$FETCH_OUTPUT_PATH" ] ; then
                run cd "$FETCH_OUTPUT_PATH" || return 1
                if      git rev-parse 2> /dev/null ; then
                    run git pull || return 1
                    run git submodule update --recursive || return 1
                else
                    run cd .. || return 1
                    run rm -rf "$FETCH_OUTPUT_NAME" || return 1
                    run git clone --recursive "$FETCH_URL" "$FETCH_OUTPUT_NAME" || return 1
                fi
            else
                if [ !          -d "$FETCH_OUTPUT_DIR" ] ; then
                    run install -d "$FETCH_OUTPUT_DIR" || return 1
                fi
                run cd "$FETCH_OUTPUT_DIR" || return 1
                run git clone --recursive "$FETCH_URL" "$FETCH_OUTPUT_NAME" || return 1
            fi
            ;;
        *)
            if [ "$FETCH_OUTPUT_PATH" != '-' ] && [ -f "$FETCH_OUTPUT_PATH" ] ; then
                if [ -n "$FETCH_SHA256" ] ; then
                    if file_exists_and_sha256sum_matched "$FETCH_OUTPUT_PATH" "$FETCH_SHA256" ; then
                        success "$FETCH_OUTPUT_PATH already have been fetched."
                        return 0
                    fi
                fi
                rm -f "$FETCH_OUTPUT_PATH" || return 1
            fi

            for FETCH_TOOL in curl wget http lynx aria2c axel
            do
                if command_exists_in_filesystem "$FETCH_TOOL" ; then
                    break
                else
                    unset FETCH_TOOL
                fi
            done

            if [ -z "$FETCH_TOOL" ] ; then
                if handle_dependency required exe curl ; then
                    FETCH_TOOL=curl
                else
                    return 1
                fi
            fi

            case $FETCH_TOOL in
                curl)
                    unset FETCH_TOOL_CURL_EXTRA_OPTIONS

                    if [ "$FETCH_SILENT" = yes ] ; then
                        FETCH_TOOL_CURL_OPTIONS='--no-progress-meter'
                    fi

                    run "curl $FETCH_TOOL_CURL_OPTIONS --fail --retry 20 --retry-delay 30 --location -o '$FETCH_OUTPUT_PATH' '$FETCH_URL'"
                    ;;
                wget)
                    if [ "$FETCH_SILENT" = yes ] ; then
                        run "wget --timeout=60 -O '$FETCH_OUTPUT_PATH' '$FETCH_URL'"
                    else
                        run "wget --timeout=60 -O '$FETCH_OUTPUT_PATH' '$FETCH_URL'"
                    fi
                    ;;
                http)
                    if [ "$FETCH_SILENT" = yes ] ; then
                        run "http --timeout=60 -o '$FETCH_OUTPUT_PATH' '$FETCH_URL'"
                    else
                        run "http --timeout=60 -o '$FETCH_OUTPUT_PATH' '$FETCH_URL'"
                    fi
                    ;;
                lynx)
                    if [ "$FETCH_SILENT" = yes ] ; then
                        run "lynx -source '$FETCH_URL' > '$FETCH_OUTPUT_PATH'"
                    else
                        run "lynx -source '$FETCH_URL' > '$FETCH_OUTPUT_PATH'"
                    fi
                    ;;
                aria2c)
                    if [ "$FETCH_SILENT" = yes ] ; then
                        run "aria2c -d '$FETCH_OUTPUT_DIR' -o '$FETCH_OUTPUT_NAME' '$FETCH_URL'"
                    else
                        run "aria2c -d '$FETCH_OUTPUT_DIR' -o '$FETCH_OUTPUT_NAME' '$FETCH_URL'"
                    fi
                    ;;
                axel)
                    if [ "$FETCH_SILENT" = yes ] ; then
                        run "axel -o '$FETCH_OUTPUT_PATH' '$FETCH_URL'"
                    else
                        run "axel -o '$FETCH_OUTPUT_PATH' '$FETCH_URL'"
                    fi
                    ;;
                *)  error "fetch() unimplementation: $FETCH_TOOL"
                    return 1
                    ;;
            esac

            [ $? -eq 0 ] || return 1

            if [ "$FETCH_OUTPUT_PATH" != '-' ] && [ -n "$FETCH_SHA256" ] ; then
                file_exists_and_sha256sum_matched "$FETCH_OUTPUT_PATH" "$FETCH_SHA256" || {
                    error "sha256sum mismatch.\n    expect : $FETCH_SHA256\n    actual : $(sha256sum $FETCH_OUTPUT_PATH)"
                    return 1
                }
            fi
    esac
}

install_ca_certificates_on_netbsd() {
    # https://www.cambus.net/installing-ca-certificates-on-netbsd/
    if [ "$(uname)" = NetBSD ] ; then
        command -v mozilla-rootcerts > /dev/null || {
            if command -v pkgin > /dev/null ; then
                run $([ "$(whoami)" = root ] || printf 'sudo\n') pkgin -y install mozilla-rootcerts
            fi
        }
        run mozilla-rootcerts install || true
    fi
}

# }}}
##############################################################################
# {{{ get_china_mirror_url

# get_china_mirror_url <ORIGIN_URL>
get_china_mirror_url() {
    case $1 in
        *githubusercontent.com/*)
            printf "%s\n" "$1" | sed 's@githubusercontent.com/@githubusercontents.com/@'
            ;;
        *github.com/*)
            printf "%s\n" "$1" | sed 's@github.com/@hub.fastgit.org/@'
            ;;
        *)  printf '%s\n' "$1"
    esac
}

# }}}
##############################################################################
# {{{ __upgrade_self

# __upgrade_self <URL> [--china] [-x]
__upgrade_self() {
    set -e

    if [ -z "$1" ] ; then
        error "__upgrade_self <URL> [--china] [-x] , <URL> must not be empty."
        return 1
    else
        UPGRADE_SELF_URL="$1"
    fi

    shift

    unset XTRACE
    unset COUNTRY

    for arg in $@
    do
        case $arg in
            --xtrace|-x)
                XTRACE=yes
                set -x
                ;;
            --china)
                COUNTRY=china
                ;;
            *)  error "__upgrade_self <URL> [--china] [-x] , unrecognized argument: $arg" ; return 1
        esac
    done

    unset CURRENT_SCRIPT_REALPATH

    # if file exists and is a symbolic link
    if [ -L "$CURRENT_SCRIPT_FILEPATH" ] ; then
        # https://unix.stackexchange.com/questions/136494/whats-the-difference-between-realpath-and-readlink-f#:~:text=GNU%20coreutils%20introduced%20a%20realpath,in%20common%20with%20GNU%20readlink%20.
        if command -v realpath > /dev/null ; then
            CURRENT_SCRIPT_REALPATH=$(realpath $CURRENT_SCRIPT_FILEPATH)
        elif command -v readlink > /dev/null && readlink -f xx > /dev/null 2>&1 ; then
            CURRENT_SCRIPT_REALPATH=$(readlink -f $CURRENT_SCRIPT_FILEPATH)
        else
            handle_dependency required exe realpath
            CURRENT_SCRIPT_REALPATH=$(realpath $CURRENT_SCRIPT_FILEPATH)
        fi
    else
        CURRENT_SCRIPT_REALPATH="$CURRENT_SCRIPT_FILEPATH"
    fi

    printf '%b\n' "$COLOR_PURPLE==>$COLOR_OFF ${COLOR_GREEN}mktemp -d$COLOR_OFF"
    WORKING_DIR=$(mktemp -d)

    run cd $WORKING_DIR

    fetch "$UPGRADE_SELF_URL" --output-path="$WORKING_DIR/self"

    __upgrade_self_exit() {
        if [ -w "$CURRENT_SCRIPT_REALPATH" ] ; then
            run      install -m 755 self "$CURRENT_SCRIPT_REALPATH"
        else
            run sudo install -m 755 self "$CURRENT_SCRIPT_REALPATH"
        fi

        run rm -rf $WORKING_DIR
    }

    trap __upgrade_self_exit EXIT
}

# }}}
##############################################################################
# {{{ __integrate_zsh_completions

# __integrate_zsh_completions <URL> [--output-dir=<DIR>] [--china] [-x]
__integrate_zsh_completions() {
    set -e

    if [ -z "$1" ] ; then
        error "__integrate_zsh_completions <URL> [--output-dir=<DIR>] [--china] [-x] , <URL> must not be empty."
        return 1
    else
        ZSH_COMPLETIONS_SCRIPT_URL="$1"
    fi

    shift

    unset XTRACE
    unset COUNTRY
    unset OUTPUT_DIR

    for arg in $@
    do
        case $arg in
            --xtrace|-x)
                XTRACE=yes
                set -x
                ;;
            --china)
                COUNTRY=china
                ;;
            --output-dir=*)
                OUTPUT_DIR=$(getvalue "$1")
                if [ -z "$OUTPUT_DIR" ] ; then
                    error "__integrate_zsh_completions <URL> [--output-dir=<DIR>] , <DIR> must not be empty."
                    return 1
                fi
                OUTPUT_DIR=$(globing "$OUTPUT_DIR")
                ;;
            *)  error "__integrate_zsh_completions <URL> [--output-dir=<DIR>] [--china] [-x] , unrecognized argument: $arg"
                return 1
        esac
    done

    ZSH_COMPLETIONS_SCRIPT_FILENAME="_$CURRENT_SCRIPT_FILENAME"

    if [ -n "$OUTPUT_DIR" ] ; then
        ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH="$OUTPUT_DIR/$ZSH_COMPLETIONS_SCRIPT_FILENAME"
    elif [ "$(uname)" = Linux ] && command -v termux-info > /dev/null && [ "$HOME" = '/data/data/com.termux/files/home' ] ; then
        ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH="/data/data/com.termux/files/usr/share/zsh/site-functions/$ZSH_COMPLETIONS_SCRIPT_FILENAME"
    else
        ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH="/usr/local/share/zsh/site-functions/$ZSH_COMPLETIONS_SCRIPT_FILENAME"
    fi

    # if file exists and is a symbolic link
    if [ -L "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH" ] ; then
        # https://unix.stackexchange.com/questions/136494/whats-the-difference-between-realpath-and-readlink-f#:~:text=GNU%20coreutils%20introduced%20a%20realpath,in%20common%20with%20GNU%20readlink%20.
        if command -v realpath > /dev/null ; then
            ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH=$(realpath $ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH)
        elif command -v readlink > /dev/null && readlink -f xx > /dev/null 2>&1 ; then
            ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH=$(readlink -f $ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH)
        else
            handle_dependency required exe realpath
            ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH=$(realpath $ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH)
        fi
    fi

    printf '%b\n' "$COLOR_PURPLE==>$COLOR_OFF ${COLOR_GREEN}mktemp -d$COLOR_OFF"
    WORKING_DIR=$(mktemp -d)

    run cd $WORKING_DIR

    fetch "$ZSH_COMPLETIONS_SCRIPT_URL" --output-path="$WORKING_DIR/$ZSH_COMPLETIONS_SCRIPT_FILENAME"

    if [ -f "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH" ] ; then
        if [ -w "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH" ] ; then
            run      install -m 644 "$ZSH_COMPLETIONS_SCRIPT_FILENAME" "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH"
        else
            run sudo install -m 644 "$ZSH_COMPLETIONS_SCRIPT_FILENAME" "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH"
        fi
    else
        ZSH_COMPLETIONS_SCRIPT_OUT_DIR="$(dirname "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH")"
        if [ ! -d "$ZSH_COMPLETIONS_SCRIPT_OUT_DIR" ] ; then
            run install -d "$ZSH_COMPLETIONS_SCRIPT_OUT_DIR" || run sudo install -d "$ZSH_COMPLETIONS_SCRIPT_OUT_DIR"
        fi
        if [ -w "$ZSH_COMPLETIONS_SCRIPT_OUT_DIR" ] ; then
            run      install -m 644 "$ZSH_COMPLETIONS_SCRIPT_FILENAME" "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH"
        else
            run sudo install -m 644 "$ZSH_COMPLETIONS_SCRIPT_FILENAME" "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH"
        fi
    fi

    run rm -rf $WORKING_DIR

    printf '\n'
    note "${COLOR_YELLOW}you need to run command${COLOR_RED} ${COLOR_GREEN}autoload -U compinit && compinit${COLOR_OFF} ${COLOR_YELLOW}in zsh to make it work.${COLOR_OFF}"
}

# }}}
##############################################################################
# {{{ os

__get_os_kind_from_uname() {
    case $1 in
        msys*)    printf '%s\n' 'windows' ;;
        mingw32*) printf '%s\n' 'windows' ;;
        mingw64*) printf '%s\n' 'windows' ;;
        cygwin*)  printf '%s\n' 'windows' ;;
        *)        printf '%s\n' "$1"
    esac
}

__get_os_type_from_uname_a() {
    if [ $# -eq 0 ] ; then
        if command -v uname > /dev/null ; then
            __get_os_type_from_uname_a "$(uname -a | cut -d ' ' -f2)"
        else
            return 1
        fi
    else
        case $1 in
            opensuse*) return 1 ;;
            *-*) printf '%s\n' "$1" | cut -d- -f1 | tr A-Z a-z ;;
            *)   return 1
        esac
    fi
}

__get_os_version_from_uname_a() {
    if [ $# -eq 0 ] ; then
        if command -v uname > /dev/null ; then
            __get_os_version_from_uname_a "$(uname -a | cut -d ' ' -f2)"
        else
            return 1
        fi
    else
        case $1 in
            opensuse*) return 1 ;;
            *-*) printf '%s\n' "$1" | cut -d- -f2 ;;
            *)   return 1
        esac
    fi
}

# https://www.freedesktop.org/software/systemd/man/os-release.html
__get_os_type_from_etc_os_release() {
    if [ -e /etc/os-release ] ; then
        (
            . /etc/os-release || return 20
            if [ -z "$ID" ] ; then
                return 1
            else
                printf '%s\n' "$ID" | tr A-Z a-z
            fi
        )
    else
        return 1
    fi
}

__get_os_version_from_etc_os_release() {
    if [ -f /etc/os-release ] ; then
        (
            . /etc/os-release || return 20
            if [ -z "$VERSION_ID" ] ; then
                printf '%s\n' 'rolling'
            else
                printf '%s\n' "$VERSION_ID"
            fi
        )
    else
        return 1
    fi
}

# https://refspecs.linuxfoundation.org/LSB_3.0.0/LSB-PDA/LSB-PDA/lsbrelease.html
__get_os_type_from_lsb_release() {
    if command -v lsb_release > /dev/null ; then
        lsb_release --id | cut -f2 | tr A-Z a-z
    else
        return 1
    fi
}

__get_os_version_from_lsb_release() {
    if command -v lsb_release > /dev/null ; then
        lsb_release --release | cut -f2
    else
        return 1
    fi
}

__get_os_type_from_etc_redhat_release() {
    if [ $# -eq 0 ] ; then
        if [ -e /etc/redhat-release ] ; then
            __get_os_type_from_etc_redhat_release "$(cat /etc/redhat-release)"
        else
            return 1
        fi
    else
        case $1 in
            'Red Hat Enterprise Linux release'*)
                printf '%s\n' rhel
                ;;
            'Fedora release'*)
                printf '%s\n' fedora
                ;;
            'CentOS release'*)
                printf '%s\n' centos
                ;;
            'CentOS Linux release'*)
                printf '%s\n' centos
                ;;
            *)  printf '%s\n' "$1" | cut -d ' ' -f1 | tr A-Z a-z
        esac
    fi
}

__get_os_version_from_etc_redhat_release() {
    if [ $# -eq 0 ] ; then
        if [ -e /etc/redhat-release ] ; then
            __get_os_version_from_etc_redhat_release $(cat /etc/redhat-release)
        else
            return 1
        fi
    else
        while [ -n "$1" ]
        do
            case $1 in
                [1-9]*) printf '%s\n' "$1"; return 0
            esac
            shift
        done
        return 1
    fi
}

__get_os_version_from_getprop() {
    if command -v getprop > /dev/null ; then
        getprop ro.build.version.release
    else
        return 1
    fi
}

__get_os_arch_from_uname() {
    if command -v uname > /dev/null ; then
        uname -m 2> /dev/null
    else
        return 1
    fi
}

__get_os_arch_from_arch() {
    if command -v arch > /dev/null ; then
        arch
    else
        return 1
    fi
}

__get_os_type_from_os_kind() {
    case $1 in
        darwin)  printf '%s\n' macos ;;
        linux)
            if [ "$(uname -o 2>/dev/null)" = Android ] ; then
                printf '%s\n' android
            else
                __get_os_type_from_etc_redhat_release ||
                __get_os_type_from_etc_os_release ||
                __get_os_type_from_lsb_release ||
                __get_os_type_from_uname_a
            fi
            ;;
        *) printf '%s\n' "$1"
    esac
}

__get_os_name_from_os_type() {
    case $1 in
        debian)  printf '%s\n' 'Debian' ;;
        ubuntu)  printf '%s\n' 'Ubuntu' ;;
        linuxmint) printf '%s\n' 'LinuxMint' ;;
        centos)  printf '%s\n' 'CentOS' ;;
        fedora)  printf '%s\n' 'Fedora' ;;
        rhel)    printf '%s\n' 'RHEL' ;;
        opensuse-leap)
                 printf '%s\n' 'openSUSE-Leap' ;;
        gentoo)  printf '%s\n' 'Gentoo' ;;
        manjaro) printf '%s\n' 'Manjaro' ;;
        alpine)  printf '%s\n' 'AlpineLinux' ;;
        arch)    printf '%s\n' 'ArchLinux' ;;
        void)    printf '%s\n' 'VoidLinux' ;;
        freebsd) printf '%s\n' 'FreeBSD' ;;
        netbsd)  printf '%s\n' 'NetBSD' ;;
        openbsd) printf '%s\n' 'OpenBSD' ;;
        macos)   printf '%s\n' 'macOS' ;;
        android) printf '%s\n' 'Android' ;;
        windows)
            systeminfo | sed -n '/OS Name:/p' | cut -d: -f2 | head -n 1 | sed 's/^[[:space:]]*//'
            ;;
        *) printf '%s\n' "$1"
    esac
}

__get_os_version_from_os_kind() {
    case $1 in
        freebsd) freebsd-version ;;
        openbsd) uname -r ;;
        netbsd)  uname -r ;;
        darwin)  sw_vers -productVersion ;;
        linux)
            __get_os_version_from_etc_redhat_release ||
            __get_os_version_from_etc_os_release ||
            __get_os_version_from_lsb_release ||
            __get_os_version_from_getprop ||
            __get_os_version_from_uname_a
            ;;
        windows)
            systeminfo | sed -n '/OS Version:/p' | cut -d: -f2 | head -n 1 | sed 's/^[[:space:]]*//' | cut -d ' ' -f1
            ;;
    esac
}

__get_os_sub_system() {
    case $(uname | tr A-Z a-z) in
        msys*)    printf '%s\n' "msys"    ;;
        mingw32*) printf '%s\n' "mingw32" ;;
        mingw64*) printf '%s\n' "mingw64" ;;
        cygwin*)  printf '%s\n' 'cygwin'  ;;
        *)
            if [ "$(uname -o 2>/dev/null)" = Android ] ; then
                if [ -n "$TERMUX_VERSION" ] ; then
                    printf '%s\n' termux
                fi
            fi
    esac
}

__get_os_arch() {
    __get_os_arch_from_uname ||
    __get_os_arch_from_arch
}

__get_os_libc_from_os_kind() {
    if [ "$1" = linux ] ; then
        if [ "$(uname -o 2>/dev/null)" = Android ] ; then
            printf '%s\n' bionic
            return 0
        fi

        # https://pubs.opengroup.org/onlinepubs/7908799/xcu/getconf.html
        if command -v getconf > /dev/null ; then
            if getconf GNU_LIBC_VERSION > /dev/null 2>&1 ; then
                printf '%s\n' glibc
                return 0
            fi
        fi

        if command -v ldd > /dev/null ; then
            if command -v grep > /dev/null ; then
                if ldd --version 2>&1 | head -n 1 | grep -q GLIBC ; then
                    printf '%s\n' glibc
                    return 0
                fi
                if ldd --version 2>&1 | head -n 1 | grep -q musl ; then
                    printf '%s\n' musl
                    return 0
                fi
            elif command -v sed > /dev/null ; then
                if [ -n "$(ldd --version 2>&1 | head -n 1 | sed -n '/GLIBC/p')" ] ; then
                    printf '%s\n' glibc
                    return 0
                fi
                if [ -n "$(ldd --version 2>&1 | head -n 1 | sed -n '/musl/p')"  ] ; then
                    printf '%s\n' musl
                    return 0
                fi
            fi
        fi

        return 1
    fi
}

# https://stackoverflow.com/questions/45181115/portable-way-to-find-the-number-of-processors-cpus-in-a-shell-script
__get_os_ncpu() {
    case "$(uname)" in
        Darwin) sysctl -n machdep.cpu.thread_count ;;
        *BSD)   sysctl -n hw.ncpu ;;
        *)  if command nproc --version > /dev/null 2>&1 ; then
                command nproc
            elif test -f /proc/cpuinfo ; then
                if command -v grep > /dev/null ; then
                    grep -c processor /proc/cpuinfo
                elif command -v sed > /dev/null && command -v wc > /dev/null ; then
                    sed -n '/^processor/p' /proc/cpuinfo | wc -l
                else
                    printf '%s\n' 4
                fi
            else
                printf '%s\n' 4
            fi
    esac
}

os() {
    if [ $# -eq 0 ] ; then
        printf "current-machine-os-kind : %s\n" "$(os kind)"
        printf "current-machine-os-type : %s\n" "$(os type)"
        printf "current-machine-os-name : %s\n" "$(os name)"
        printf "current-machine-os-vers : %s\n" "$(os vers)"
        printf "current-machine-os-arch : %s\n" "$(os arch)"
        printf "current-machine-os-ncpu : %s\n" "$(os ncpu)"
        printf "current-machine-os-euid : %s\n" "$(os euid)"
        printf "current-machine-os-libc : %s\n" "$(os libc)"
        printf "current-machine-os-subs : %s\n" "$(os subs)"
    elif [ $# -eq 1 ] ; then
        case $1 in
            -h|--help)
                cat <<'EOF'
os -h | --help
os -V | --version
os kind
os type
os name
os vers
os arch
os ncpu
os euid
os libc
os subs
EOF
                ;;
            -V|--version)
                printf "%s\n" '2021.10.01.03'
                ;;
            kind)
                __get_os_kind_from_uname $(uname | tr A-Z a-z)
                ;;
            type)
                __get_os_type_from_os_kind $(os kind)
                ;;
            name)
                __get_os_name_from_os_type $(os type)
                ;;
            vers)
                __get_os_version_from_os_kind $(os kind)
                ;;
            subs)
                __get_os_sub_system
                ;;
            arch)
                __get_os_arch
                ;;
            ncpu)
                __get_os_ncpu
                ;;
            euid)
                id -u
                ;;
            libc)
                __get_os_libc_from_os_kind $(os kind)
                ;;
            *)  printf '%s\n' "unrecognized argument: $1" >&2; return 1
        esac
    else
        printf '%s\n' "os command only support one argument." >&2; return 1
    fi
}

# }}}
##############################################################################
# {{{ version

version_of_python_module() {
    unset PIP_COMMAND
    PIP_COMMAND=$(command -v pip3 || command -v pip)
    if [ -z "$PIP_COMMAND" ] ; then
        error "can't found pip command."
        return 1
    else
        "$PIP_COMMAND" show $1 | sed -n '/Version:/p' | cut -d ' ' -f2
    fi
}

# retrive the version of a command from it's name or path
version_of_command() {
    case $(basename "$1") in
      gclient) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
       ccache) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         bear) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        xmake) "$1" --version 2> /dev/null | head -n 1 | cut -d '+' -f1 | cut -d 'v' -f2 ;;
        cmake) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         rake) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         make) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
        gmake) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
       rustup) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
       rustc)  "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        cargo) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
           go) "$1"   version | cut -d ' ' -f3 | cut -c3- ;;
         tree) "$1" --version | cut -d ' ' -f2 | cut -c2- ;;
   pkg-config) "$1" --version 2> /dev/null | head -n 1 ;;
     patchelf) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
       m4|gm4) "$1" --version 2> /dev/null | head -n 1 | awk '{print($NF)}';;
    autopoint) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
     xgettext) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
     automake|aclocal)
               "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
     autoconf|autoheader|autom4te|autoreconf|autoscan|autoupdate|ifnames)
               "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
     realpath) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
      libtool) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
   libtoolize|glibtoolize)
               "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
  intltoolize) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
      objcopy) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f5 ;;
          adb) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f5 ;;
         flex) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        bison) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         yacc) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         nasm) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         yasm) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        patch) "$1" --version 2> /dev/null | head -n 1 | awk '{print($NF)}' ;;
        gperf) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
        groff) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
     makeinfo) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
     help2man) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
    gtkdocize) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
 sphinx-build) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
 glib-mkenums) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
 glib-compile-resources)
               "$1" --version ;;
         file) "$1" --version 2> /dev/null | head -n 1 | cut -d '-' -f2 ;;
      itstool) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
       protoc) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        xmlto) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
      xmllint) ;;
     xsltproc) ;;
     rst2man|rst2man.py|rst2man-3|rst2man-3.6|rst2man-3.7|rst2man-3.8|rst2man-3.9)
               "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         java) "$1"  -version 2>&1 | head -n 1 | cut -d ' ' -f3 | sed 's/"//g' ;;
         gzip) "$1" --version 2>&1 | head -n 1 | awk '{print($NF)}' ;;
         lzip) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
           xz) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
          zip) "$1" --version 2> /dev/null | sed -n '2p' | cut -d ' ' -f4 ;;
        unzip) "$1" -v        2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
        bzip2) "$1" --help 2>&1 | head -n 1 | cut -d ' ' -f8 | cut -d ',' -f1 ;;
          tar)
            VERSION_MSG=$("$1" --version 2> /dev/null | head -n 1)
            case $VERSION_MSG in
                  tar*) printf '%s\n' "$VERSION_MSG" | cut -d ' ' -f4 ;;
               bsdtar*) printf '%s\n' "$VERSION_MSG" | cut -d ' ' -f2 ;;
            esac
            ;;
          git) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 ;;
         curl) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
     awk|gawk) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f3 | tr , ' ' ;;
     sed|gsed) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         cpan) ;;
         find) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         diff) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
         grep) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 | cut -d '-' -f1 ;;
         ruby) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
         perl) "$1" -v | sed -n '2p' | sed 's/.*v\([0-9]\.[0-9][0-9]\.[0-9]\).*/\1/' ;;
          lua) "$1" -v 2>/dev/null | head -n 1 | cut -d ' ' -f2 ;;
    python|python2|python3)
               "$1" --version 2>&1 | head -n 1 | cut -d ' ' -f2 ;;
         pip)  "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
         pip3) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
         node) "$1" --version 2> /dev/null | head -n 1 | cut -d 'v' -f2 ;;
          zsh) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f2 ;;
         bash) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 | cut -d '(' -f1 ;;
       base64) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
      hexdump) "$1" --version 2> /dev/null | head -n 1 | cut -d ' ' -f4 ;;
      sqlite3) "$1"  -version 2> /dev/null | head -n 1 | cut -d ' ' -f1 ;;
            *) "$1" --version 2> /dev/null | head -n 1
    esac
}

# retrive the major part of the version of the given command
# Note: the version of the given command must have form: major.minor.patch
version_major_of_command() {
    version_of_command "$1" | cut -d. -f1
}

# retrive the minor part of the version of the given command
# Note: the version of the given command must have form: major.minor.patch
version_minor_of_command() {
    version_of_command "$1" | cut -d. -f2
}

# retrive the major part of the given version
# Note: the given version must have form: major.minor.patch
version_major_of_version() {
    printf '%s\n' "$1" | cut -d. -f1
}

# retrive the minor part of the given version
# Note: the given version must have form: major.minor.patch
version_minor_of_version() {
    printf '%s\n' "$1" | cut -d. -f2
}

version_sort() {
    # https://pubs.opengroup.org/onlinepubs/9699919799/utilities/sort.html
    # https://man.netbsd.org/NetBSD-8.1/i386/sort.1
    #
    # sort: unrecognized option: V
    # BusyBox v1.29.3 (2019-01-24 07:45:07 UTC) multi-call binary.
    # Usage: sort [-nrugMcszbdfiokt] [-o FILE] [-k start[.offset][opts][,end[.offset][opts]] [-t CHAR] [FILE]...
    if  printf '%s\n' | (sort -V > /dev/null 2>&1) ; then
        printf '%s\n' "$@" | tr ' ' '\n' | sort -V
    else
        printf '%s\n' "$@" | tr ' ' '\n' | sort -t. -n -k1,1 -k2,2 -k3,3 -k4,4
    fi
}

# check if match the condition
#
# condition:
# eq  equal
# ne  not equal
# gt  greater than
# lt  less than
# ge  greater than or equal
# le  less than or equal
#
# examples:
# version_match 1.15.3 eq 1.16.0
# version_match 1.15.3 lt 1.16.0
# version_match 1.15.3 gt 1.16.0
# version_match 1.15.3 le 1.16.0
# version_match 1.15.3 ge 1.16.0
version_match() {
    case $2 in
        eq)  [ "$1"  = "$3" ] ;;
        ne)  [ "$1" != "$3" ] ;;
        le)
            if [ "$1" = "$3" ] ; then
                return 0
            fi
            [ "$1" = "$(version_sort "$1" "$3" | head -n 1)" ]
            ;;
        ge)
            if [ "$1" = "$3" ] ; then
                return 0
            fi
            [ "$1" = "$(version_sort "$1" "$3" | tail -n 1)" ]
            ;;
        lt)
            if [ "$1" = "$3" ] ; then
                return 1
            fi
            [ "$1" = "$(version_sort "$1" "$3" | head -n 1)" ]
            ;;
        gt)
            if [ "$1" = "$3" ] ; then
                return 1
            fi
            [ "$1" = "$(version_sort "$1" "$3" | tail -n 1)" ]
            ;;
        *)  error "version_compare: $2: not supported operator." ; return 1
    esac
}

# check if the version of give installed command match the condition
#
# condition:
# eq  equal
# ne  not equal
# gt  greater than
# lt  less than
# ge  greater than or equal
# le  less than or equal
#
# examples:
# command_exists_in_filesystem_and_version_matched automake eq 1.16.0
# command_exists_in_filesystem_and_version_matched automake lt 1.16.0
# command_exists_in_filesystem_and_version_matched automake gt 1.16.0
# command_exists_in_filesystem_and_version_matched automake le 1.16.0
# command_exists_in_filesystem_and_version_matched automake ge 1.16.0
# command_exists_in_filesystem_and_version_matched automake
command_exists_in_filesystem_and_version_matched() {
    if command_exists_in_filesystem "$1" ; then
        if [ $# -eq 3 ] ; then
            version_match "$(version_of_command "$1")" "$2" "$3"
        fi
    else
        return 1
    fi
}

# }}}
##############################################################################
# {{{ package manager wrapper, aka pmw

# https://cygwin.com/packages/package_list.html
__pmw_get_available_package_name_by_command_name_choco() {
    case $1 in
        go)   echo 'golang' ;;
        cc|gcc|c++|g++)
              echo 'gcc-g++';;
        addr2line|ar|as|c++filt|dwp|elfedit|gold|gprof|ld|ld.bfd|ld.gold|nm|objcopy|objdump|ranlib|readelf|size|strings|strip)
              echo 'binutils' ;;
       gmake) echo 'make'   ;;
         gm4) echo 'm4'     ;;
        gsed) echo 'gnu-sed';;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
    xsltproc) echo 'libxslt'  ;;
      protoc) echo 'protobuf' ;;
         dot) echo 'graphviz' ;;
      ps2pdf) echo "ghostscript" ;;
    hexdump)  echo 'util-linux' ;;
    makeinfo) echo 'texinfo'  ;;
    sphinx-build) echo 'python38-sphinx' ;;
    glib-mkenums) echo 'glib' ;;
    glib-compile-resources)
                  echo 'glib' ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
     xgettext)  echo "gettext"  ;;
    intltoolize)echo "intltool" ;;
    gtkdocize)  echo "gtk-doc"  ;;
    gdk-pixbuf-query-loaders)
                echo 'gdk-pixbuf' ;;
    gpasm|gpdasm|gplib|gplink|gpstrip|gpvc|gpvo)
                echo 'gputils' ;;
        *)      echo "$1"
    esac
}

__pmw_get_available_package_name_by_command_name_pkg_add() {
    case $1 in
          go) echo 'golang';;
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
        addr2line|ar|as|c++filt|dwp|elfedit|gold|gprof|ld|ld.bfd|ld.gold|nm|objcopy|objdump|ranlib|readelf|size|strings|strip)
              echo 'binutils' ;;
         gm4) echo 'm4'    ;;
        make) echo 'gmake' ;;
        perl) echo 'perl5' ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
    realpath) echo 'coreutils';;
     objcopy) echo 'binutils' ;;
  7z|7za|7zr) echo 'p7zip'    ;;
    xsltproc) echo 'libxslt'  ;;
      protoc) echo 'protobuf' ;;
         dot) echo 'graphviz' ;;
      ps2pdf) echo "ghostscript" ;;
    hexdump)  echo 'util-linux' ;;
    pip3|pip) echo 'py3-pip' ;;
    makeinfo) echo 'texinfo' ;;
    libtool|libtoolize|glibtool|glibtoolize)
              echo "libtool" ;;
    autoreconf|autoconf|autoreconf-2.69|autoconf-2.69)
              echo "autoconf-2.69p3" ;;
    automake|autoheader|automake-1.16|autoheader-1.16)
            if [ "$NATIVE_OS_VERS" = '6.9' ] ; then
                echo "automake-1.16.3"
            else
                echo "automake-1.16.2"
            fi
            ;;
    glib-mkenums) echo 'glib' ;;
    glib-compile-resources)
                  echo 'glib' ;;
    autopoint)    echo "gettext" ;;
     xgettext)    echo "gettext" ;;
    intltoolize)  echo "intltool";;
    gtkdocize)    echo "gtk-doc" ;;
    pkg-config)   echo "pkgconf" ;;
    gdk-pixbuf-query-loaders)
                echo 'gdk-pixbuf' ;;
    gpasm|gpdasm|gplib|gplink|gpstrip|gpvc|gpvo)
                echo 'gputils' ;;
        *) echo "$1"
    esac
}

__pmw_get_available_package_name_by_command_name_pkgin() {
    case $1 in
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
        addr2line|ar|as|c++filt|dwp|elfedit|gold|gprof|ld|ld.bfd|ld.gold|nm|objcopy|objdump|ranlib|readelf|size|strings|strip)
              echo 'binutils' ;;
         gm4) echo 'm4'    ;;
        make) echo 'gmake' ;;
        perl) echo 'perl5' ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
    realpath) echo 'coreutils';;
  7z|7za|7zr) echo 'p7zip'    ;;
    xsltproc) echo 'libxslt'  ;;
      protoc) echo 'protobuf' ;;
         dot) echo 'graphviz' ;;
      ps2pdf) echo "ghostscript" ;;
    hexdump)  echo 'util-linux' ;;
    makeinfo) echo 'texinfo'  ;;
    pip3|pip) echo 'py38-pip' ;;
    python3)  echo 'python38' ;;
    glib-mkenums) echo 'glib' ;;
    glib-compile-resources)
                  echo 'glib' ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
     xgettext)  echo "gettext"  ;;
    intltoolize)echo "intltool" ;;
    gtkdocize)  echo "gtk-doc"  ;;
    pkg-config) echo "pkgconf"  ;;
    gdk-pixbuf-query-loaders)
                echo 'gdk-pixbuf' ;;
    gpasm|gpdasm|gplib|gplink|gpstrip|gpvc|gpvo)
                echo 'gputils' ;;
        *)      echo "$1"
    esac
}

__pmw_get_available_package_name_by_command_name_pkg() {
    case $1 in
          go) echo 'golang';;
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
        addr2line|ar|as|c++filt|dwp|elfedit|gold|gprof|ld|ld.bfd|ld.gold|nm|objcopy|objdump|ranlib|readelf|size|strings|strip)
              echo 'binutils' ;;
        java) echo 'openjdk-17' ;;
         lua) echo 'lua54' ;;
         gm4) echo 'm4'    ;;
        make) echo 'gmake' ;;
        perl) echo 'perl5' ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
  7z|7za|7zr) echo 'p7zip'    ;;
    xsltproc) echo 'libxslt'  ;;
      protoc) echo 'protobuf' ;;
         dot) echo 'graphviz' ;;
      ps2pdf) echo "ghostscript" ;;
    hexdump)  echo 'util-linux' ;;
    makeinfo) echo 'texinfo'  ;;
    pip3|pip) echo 'py38-pip' ;;
    glib-mkenums) echo 'glib' ;;
    glib-compile-resources)
                  echo 'glib' ;;
    libtool|libtoolize|glibtool|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
     xgettext)  echo "gettext"  ;;
    intltoolize)echo "intltool" ;;
    gtkdocize)  echo "gtk-doc"  ;;
    pkg-config) echo "pkgconf"  ;;
    gdk-pixbuf-query-loaders)
                echo 'gdk-pixbuf' ;;
    gpasm|gpdasm|gplib|gplink|gpstrip|gpvc|gpvo)
                echo 'gputils' ;;
        *)      echo "$1"
    esac
}

__pmw_get_available_package_name_by_command_name_emerge() {
    case $1 in
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
        addr2line|ar|as|c++filt|dwp|elfedit|gold|gprof|ld|ld.bfd|ld.gold|nm|objcopy|objdump|ranlib|readelf|size|strings|strip)
              echo 'binutils' ;;
         gm4) echo 'm4'    ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
  7z|7za|7zr) echo 'p7zip'    ;;
    xsltproc) echo 'libxslt'  ;;
      protoc) echo 'protobuf' ;;
         dot) echo 'media-gfx/graphviz' ;;
      ps2pdf) echo "ghostscript" ;;
    hexdump)  echo 'util-linux' ;;
    makeinfo) echo 'texinfo'  ;;
    xz)       echo 'xz-utils' ;;
    rst2man|rst2html)
                  echo "docutils" ;;
    sphinx-build) echo "sphinx" ;;
    pip3|pip)     echo "dev-python/pip" ;;
    glib-mkenums) echo 'glib' ;;
    glib-compile-resources)
                  echo 'glib' ;;
    libtool|libtoolize|glibtool|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
     xgettext)  echo "gettext"  ;;
    intltoolize)echo "intltool" ;;
    gtkdocize)  echo "gtk-doc"  ;;
    pkg-config) echo "pkgconf"  ;;
    gdk-pixbuf-query-loaders)
                echo 'gdk-pixbuf' ;;
    gpasm|gpdasm|gplib|gplink|gpstrip|gpvc|gpvo)
                echo 'gputils' ;;
        *)      echo "$1"
    esac
}

__pmw_get_available_package_name_by_command_name_pacman_internal() {
    case $1 in
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
        addr2line|ar|as|c++filt|dwp|elfedit|gold|gprof|ld|ld.bfd|ld.gold|nm|objcopy|objdump|ranlib|readelf|size|strings|strip)
              echo 'binutils' ;;
         gm4) echo 'm4'    ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
  7z|7za|7zr) echo 'p7zip'    ;;
    xsltproc) echo 'libxslt'  ;;
      protoc) echo 'protobuf' ;;
         dot) echo 'graphviz' ;;
      ps2pdf) echo "ghostscript" ;;
    makeinfo) echo 'texinfo'  ;;
    hexdump)  echo 'util-linux' ;;
    rst2man|rst2html)
                  echo "python-docutils" ;;
    sphinx-build) echo "python-sphinx" ;;
    pip3|pip)     echo "python-pip" ;;
    glib-mkenums) echo 'glib' ;;
    glib-compile-resources)
                  echo 'glib' ;;
    libtool|libtoolize|glibtool|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
     xgettext)  echo "gettext"  ;;
    intltoolize)echo "intltool" ;;
    gtkdocize)  echo "gtk-doc"  ;;
    pkg-config) echo "pkgconf"  ;;
    gdk-pixbuf-query-loaders)
                echo 'gdk-pixbuf' ;;
    gpasm|gpdasm|gplib|gplink|gpstrip|gpvc|gpvo)
                echo 'gputils' ;;
        *)      echo "$1"
    esac
}

__mingw_w64_i686() {
    if pacman -S -i "mingw-w64-i686-$1" > /dev/null 2>&1 ; then
        echo "mingw-w64-i686-$1"
    else
        echo "$1"
    fi
}

__mingw_w64_x86_64() {
    if pacman -S -i "mingw-w64-x86_64-$1" > /dev/null 2>&1 ; then
        echo "mingw-w64-x86_64-$1"
    else
        echo "$1"
    fi
}

__pmw_get_available_package_name_by_command_name_pacman() {
    if [ "$1" = 'make' ] || [ "$1" = 'gmake' ] ; then
        echo make
        return 1
    fi
    case $NATIVE_OS_SUBS in
        mingw32) __mingw_w64_i686   $(__pmw_get_available_package_name_by_command_name_pacman_internal "$1") ;;
        mingw64) __mingw_w64_x86_64 $(__pmw_get_available_package_name_by_command_name_pacman_internal "$1") ;;
        *) __pmw_get_available_package_name_by_command_name_pacman_internal "$1"
    esac
}

__pmw_get_available_package_name_by_command_name_xbps() {
    case $1 in
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
        addr2line|ar|as|c++filt|dwp|elfedit|gold|gprof|ld|ld.bfd|ld.gold|nm|objcopy|objdump|ranlib|readelf|size|strings|strip)
              echo 'binutils' ;;
         gm4) echo 'm4'    ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
    realpath) echo 'coreutils';;
  7z|7za|7zr) echo 'p7zip'    ;;
    xsltproc) echo 'libxslt'  ;;
      protoc) echo 'protobuf' ;;
         dot) echo 'graphviz' ;;
      ps2pdf) echo "ghostscript" ;;
    hexdump)  echo 'util-linux' ;;
    makeinfo) echo 'texinfo'  ;;
    pip|pip3) echo "python3-pip" ;;
    rst2man|rst2html)
              echo "python3-docutils" ;;
    glib-mkenums) echo 'glib2' ;;
    glib-compile-resources)
                  echo 'glib2' ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
     xgettext)  echo "gettext"  ;;
    intltoolize)echo "intltool" ;;
    gtkdocize)  echo "gtk-doc"  ;;
    pkg-config) echo "pkgconf"  ;;
    gdk-pixbuf-query-loaders)
                echo 'gdk-pixbuf' ;;
    gpasm|gpdasm|gplib|gplink|gpstrip|gpvc|gpvo)
                echo 'gputils' ;;
        *)      echo "$1"
    esac
}

__pmw_get_available_package_name_by_command_name_apk() {
    case $1 in
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
        addr2line|ar|as|c++filt|dwp|elfedit|gold|gprof|ld|ld.bfd|ld.gold|nm|objcopy|objdump|ranlib|readelf|size|strings|strip)
              echo 'binutils' ;;
         gm4) echo 'm4'    ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
    realpath) echo 'coreutils';;
  7z|7za|7zr) echo 'p7zip'    ;;
    xsltproc) echo 'libxslt'  ;;
      protoc) echo 'protobuf' ;;
         dot) echo 'graphviz' ;;
      ps2pdf) echo "ghostscript" ;;
    hexdump)  echo 'util-linux' ;;
    makeinfo) echo 'texinfo'  ;;
    pip3|pip) echo 'py3-pip'  ;;
    rst2man|rst2html)
              echo "py3-docutils" ;;
    sphinx-build) echo "sphinx" ;;
    glib-mkenums) echo 'glib' ;;
    glib-compile-resources)
                  echo 'glib' ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
     xgettext)  echo "gettext"  ;;
    intltoolize)echo "intltool" ;;
    gtkdocize)  echo "gtk-doc"  ;;
    pkg-config) echo "pkgconf"  ;;
    gdk-pixbuf-query-loaders)
                echo 'gdk-pixbuf' ;;
    gpasm|gpdasm|gplib|gplink|gpstrip|gpvc|gpvo)
                echo 'gputils' ;;
        *) echo "$1"
    esac
}

__pmw_get_available_package_name_by_command_name_zypper() {
    case $1 in
          cc) echo 'gcc'   ;;
         c++) echo 'gcc-g++';;
     clang++) echo 'clang' ;;
        addr2line|ar|as|c++filt|dwp|elfedit|gold|gprof|ld|ld.bfd|ld.gold|nm|objcopy|objdump|ranlib|readelf|size|strings|strip)
              echo 'binutils' ;;
         gm4) echo 'm4'    ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
    realpath) echo 'coreutils';;
         7zr) echo 'p7zip'    ;;
      7z|7za)
            if [ "$NATIVE_OS_TYPE" = 'opensuse-leap' ] ; then
                if version_match "$NATIVE_OS_VERS" gt 15.1 ; then
                    echo 'p7zip-full'
                else
                    echo 'p7zip'
                fi
            else
                echo 'p7zip'
            fi
            ;;
    xsltproc) echo 'libxslt'  ;;
      protoc) echo 'protobuf' ;;
         dot) echo 'graphviz-gd' ;;
      ps2pdf) echo "ghostscript" ;;
    hexdump)  echo 'util-linux' ;;
    makeinfo) echo 'texinfo'  ;;
    rst2man|rst2html)
                  echo "python3-docutils" ;;
    sphinx-build) echo "python3-Sphinx" ;;
    pip3|pip)     echo "python3-pip" ;;
    glib-mkenums) echo 'glib' ;;
    glib-compile-resources)
                  echo 'glib' ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
     xgettext)  echo "gettext"  ;;
    intltoolize)echo "intltool" ;;
    gtkdocize)  echo "gtk-doc"  ;;
    gdk-pixbuf-query-loaders)
                echo 'gdk-pixbuf' ;;
    gpasm|gpdasm|gplib|gplink|gpstrip|gpvc|gpvo)
                echo 'gputils' ;;
        *)      echo "$1"
    esac
}

__pmw_get_available_package_name_by_command_name_dnf() {
    case $1 in
          go) echo 'golang';;
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
        addr2line|ar|as|c++filt|dwp|elfedit|gold|gprof|ld|ld.bfd|ld.gold|nm|objcopy|objdump|ranlib|readelf|size|strings|strip)
              echo 'binutils' ;;
         gm4) echo 'm4'    ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
    realpath) echo 'coreutils';;
  7z|7za|7zr) echo 'p7zip'    ;;
    xsltproc) echo 'libxslt'  ;;
      protoc) echo 'protobuf' ;;
         dot) echo 'graphviz' ;;
      ps2pdf) echo "ghostscript" ;;
    hexdump)  echo 'util-linux' ;;
    makeinfo) echo 'texinfo'  ;;
    patchelf)
        # EPEL repo is shipped with Fedora
        if [ "$NATIVE_OS_TYPE" = fedora ] ; then
            echo 'patchelf'
        else
            echo 'epel:patchelf'
        fi
        ;;
    ccache)
        # EPEL repo is shipped with Fedora
        if [ "$NATIVE_OS_TYPE" = fedora ] ; then
            echo 'ccache'
        else
            echo 'epel:ccache'
        fi
        ;;
    pkg-config)
        if [ "$NATIVE_OS_TYPE" = fedora ] ; then
            if [ "$NATIVE_OS_VERS" -ge 34 ] ; then
                echo 'pkgconf-pkg-config'
            else
                echo 'pkg-config'
            fi
        else
            echo 'pkg-config'
        fi
        ;;
    python3|python)
        if [ "$NATIVE_OS_TYPE" = fedora ] ; then
            echo 'python3'
        else
            echo 'python39'
        fi
        ;;
    rst2man|rst2html)
                  echo "python3-docutils" ;;
    sphinx-build) echo "python3-sphinx" ;;
    glib-mkenums) echo 'glib2-devel' ;;
    glib-compile-resources)
                  echo 'glib2-devel' ;;
    grpc_cpp_plugin)
                  echo "grpc-plugins" ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext-devel";;
     xgettext)  echo "gettext"  ;;
    msgfmt)     echo "gettext"  ;;
    intltoolize)echo "intltool" ;;
    gtkdocize)  echo "gtk-doc"  ;;
    gdk-pixbuf-query-loaders)
                echo 'gdk-pixbuf' ;;
    gpasm|gpdasm|gplib|gplink|gpstrip|gpvc|gpvo)
                echo 'gputils' ;;
        *)      echo "$1"
    esac
}

__pmw_get_available_package_name_by_command_name_yum() {
    case $1 in
          go) echo 'golang';;
          cc) echo 'gcc'   ;;
         c++) echo 'gcc-g++';;
     clang++) echo 'clang' ;;
        addr2line|ar|as|c++filt|dwp|elfedit|gold|gprof|ld|ld.bfd|ld.gold|nm|objcopy|objdump|ranlib|readelf|size|strings|strip)
              echo 'binutils' ;;
         gm4) echo 'm4'    ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
    realpath) echo 'coreutils';;
  7z|7za|7zr) echo 'p7zip'    ;;
    xsltproc) echo 'libxslt'  ;;
      protoc) echo 'protobuf' ;;
         dot) echo 'graphviz' ;;
      ps2pdf) echo "ghostscript" ;;
    hexdump)  echo 'util-linux' ;;
    makeinfo) echo 'texinfo'  ;;
    patchelf) echo 'epel:patchelf' ;;
    ccache)   echo 'epel:ccache' ;;
    sphinx-build) echo "python-sphinx" ;;
    glib-mkenums) echo 'glib2-devel' ;;
    glib-compile-resources)
                  echo 'glib2-devel' ;;
    grpc_cpp_plugin)
                  echo "grpc-plugins" ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext-devel";;
     xgettext)  echo "gettext"  ;;
    msgfmt)     echo "gettext"  ;;
    intltoolize)echo "intltool" ;;
    gtkdocize)  echo "gtk-doc"  ;;
    gdk-pixbuf-query-loaders)
                echo 'gdk-pixbuf' ;;
    gpasm|gpdasm|gplib|gplink|gpstrip|gpvc|gpvo)
                echo 'gputils' ;;
        *)      echo "$1"
    esac
}

__pmw_get_available_package_name_by_command_name_apt_get() {
    __pmw_get_available_package_name_by_command_name_apt $@
}

__pmw_get_available_package_name_by_command_name_apt() {
    case $1 in
          go) echo 'golang';;
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
        addr2line|ar|as|c++filt|dwp|elfedit|gold|gprof|ld|ld.bfd|ld.gold|nm|objcopy|objdump|ranlib|readelf|size|strings|strip)
              echo 'binutils' ;;
        java) echo 'openjdk-17-jdk' ;;
         lua) echo 'lua5.3';;
         gm4) echo 'm4'    ;;
         awk) echo 'gawk'  ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
        xz)   echo 'xz-utils' ;;
     objcopy) echo 'binutils' ;;
    realpath) echo 'coreutils';;
         7zr) echo 'p7zip'    ;;
      7z|7za) echo 'p7zip-full' ;;
      protoc) echo 'protobuf' ;;
         dot) echo 'graphviz' ;;
      ps2pdf) echo "ghostscript" ;;
    hexdump)  echo 'bsdmainutils';;
    makeinfo) echo 'texinfo'  ;;
    pip3|pip) echo "python3-pip" ;;
    rst2man|rst2html)
              echo "python3-docutils" ;;
    sphinx-build)
              echo "python3-sphinx" ;;
    grpc_cpp_plugin)
              echo "protobuf-compiler-grpc" ;;
    glib-mkenums)
              echo 'libglib2.0-dev' ;;
    glib-compile-resources)
                  echo 'libglib2.0-dev-bin' ;;
    libtoolize|glibtoolize)
                echo "libtool"  ;;
    libtool)    echo "libtool-bin" ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    xgettext)   echo "gettext"  ;;
    msgfmt)     echo "gettext"  ;;
    intltoolize)echo "intltool" ;;
    gtkdocize)  echo "gtk-doc-tools" ;;
    gdk-pixbuf-query-loaders)
                echo 'libgdk-pixbuf2.0-bin' ;;
    gpasm|gpdasm|gplib|gplink|gpstrip|gpvc|gpvo)
                echo 'gputils' ;;
    cwebp|dwebp|gif2webp|img2webp|vwebp|webpinfo|webpmux)
                echo 'webp' ;;
    scp|sftp|ssh|ssh-add|ssh-agent|ssh-argv0|ssh-copy-id|ssh-keygen|ssh-keyscan)
                echo 'openssh-client' ;;
        ninja)
            if [ "$NATIVE_OS_SUBS" = termux ] ; then
                echo ninja
            else
                echo ninja-build
            fi
            ;;
        *)      echo "$1"
    esac
}

__pmw_get_available_package_name_by_command_name_brew() {
    case $1 in
          cc) echo 'gcc'   ;;
         c++) echo 'g++'   ;;
     clang++) echo 'clang' ;;
        addr2line|ar|as|c++filt|dwp|elfedit|gold|gprof|ld|ld.bfd|ld.gold|nm|objcopy|objdump|ranlib|readelf|size|strings|strip)
              echo 'binutils' ;;
         gm4) echo 'm4'    ;;
        gsed) echo 'gnu-sed'  ;;
        find) echo 'findutils';;
        diff) echo 'diffutils';;
     objcopy) echo 'binutils' ;;
    realpath) echo 'coreutils';;
  7z|7za|7zr) echo 'p7zip'    ;;
    xsltproc) echo 'libxslt'  ;;
      protoc) echo 'protobuf' ;;
         dot) echo 'graphviz' ;;
      ps2pdf) echo "ghostscript" ;;
    hexdump)  echo 'util-linux' ;;
    makeinfo) echo 'texinfo'  ;;
    rst2man.py|rst2html.py)
              echo "docutils" ;;
    grpc_cpp_plugin)
              echo "grpc" ;;
    glib-mkenums)
              echo 'glib-utils' ;;
    glib-compile-resources)
              echo 'glib' ;;
    glibtool|libtoolize|glibtoolize)
                echo "libtool"  ;;
    autoreconf) echo "autoconf" ;;
    autoheader) echo "automake" ;;
    autopoint)  echo "gettext"  ;;
     xgettext)  echo "gettext"  ;;
    intltoolize)echo "intltool" ;;
    gtkdocize)  echo "gtk-doc"  ;;
    python|python3)
                echo 'python@3.9' ;;
    gdk-pixbuf-query-loaders)
                echo 'gdk-pixbuf' ;;
    gpasm|gpdasm|gplib|gplink|gpstrip|gpvc|gpvo)
                echo 'gputils' ;;
    cwebp|dwebp|gif2webp|img2webp|vwebp|webpinfo|webpmux)
                echo 'libwebp' ;;
    scp|sftp|ssh|ssh-add|ssh-agent|ssh-argv0|ssh-copy-id|ssh-keygen|ssh-keyscan)
                echo 'openssh' ;;
        *)      echo "$1"
    esac
}

__pmw_get_available_package_name_by_command_name_cargo() {
    case $1 in
        cargo-capi|cargo-cbuild|cargo-cinstall|cargo-ctest)
            echo 'cargo-c' ;;
    esac
}

__pmw_get_available_package_name_by_command_name_pip3() {
    __pmw_get_available_package_name_by_command_name_pip $@
}

__pmw_get_available_package_name_by_command_name_pip() {
    case $1 in
        sphinx-build) echo "sphinx"   ;;
        rst2man.py)   echo "docutils" ;;
        meson)        echo "meson" ;;
    esac
}

__pmw_get_available_pm_list() {
    for pm in brew pkg apt apt-get dnf yum zypper apk xbps emerge pacman choco pkgin pkg_add cargo
    do
        case $pm in
            apt)
                if command_exists_in_filesystem apt && apt show apt > /dev/null 2>&1 ; then
                    printf '%s\n' apt
                fi
                ;;
            xbps)
                if command_exists_in_filesystem xbps-install ; then
                    printf '%s\n' xbps
                fi
                ;;
            *)
                if command_exists_in_filesystem "$pm" ; then
                    printf '%s\n' "$pm"
                fi
        esac
    done
}

# __pmw_install_the_given_package <PM> <REPO> <PKG> [eq|ne|le|ge|lt|gt <VERSION>]
# __pmw_install_the_given_package apt default make ge 3.80
# __pmw_install_the_given_package apt default make
# __pmw_install_the_given_package yum epel    ccache
# __pmw_install_the_given_package dnf epel    ccache
__pmw_install_the_given_package() {
    [ -z "$1" ] && {
        error "USAGE: __pmw_install_the_given_package <PM> <REPO> <PKG> [eq|ne|le|ge|lt|gt <VERSION>] , <PM> must not be empty."
        return 1
    }

    [ -z "$2" ] && {
        error "USAGE: __pmw_install_the_given_package <PM> <REPO> <PKG> [eq|ne|le|ge|lt|gt <VERSION>] , <REPO> must not be empty."
        return 1
    }

    [ -z "$3" ] && {
        error "USAGE: __pmw_install_the_given_package <PM> <REPO> <PKG> [eq|ne|le|ge|lt|gt <VERSION>] , <PKG> must not be empty."
        return 1
    }

    {
        case $1 in
            apk)     run "$sudo" apk    update    ;;
            zypper)  run "$sudo" zypper update -y ;;
            pacman)  run "$sudo" pacman -Syy --noconfirm ;;
            dnf|yum)
                case $2 in
                    default) run "$sudo" "$1" -y update ;;
                    epel)
                        if [ epel = "$("$1" repolist | cut -d ' ' -f1 | sed -n '/^epel$/p')" ] ; then
                            run "$sudo" "$1" --enablerepo=epel -y update
                        else
                            run "$sudo" "$1"                   -y update  &&
                            run "$sudo" "$1"                   -y install epel-release &&
                            run "$sudo" "$1" --enablerepo=epel -y update
                        fi
                        ;;
                esac
                ;;
            apt-get|apt)
                case $2 in
                    default) run "$sudo" "$1" -y update ;;
                    ppa:*)   run "$sudo" "$1" -y update ;;
                    *)       error "$1: unrecognized repo: $2" ; return 1 ;;
                esac
        esac
    } || return 1

    # choco and pkg_add can not get a package's version
    case $1 in
        choco|pkg_add) ;;
        *) __pmw_is_the_given_package_available $@ || return 1
    esac

    note "${COLOR_GREEN}$(shiftn 2 $@)${COLOR_OFF} ${COLOR_YELLOW}command is required, but it is not found on this machine, I will install it via${COLOR_OFF} ${COLOR_GREEN}$1${COLOR_OFF}"

    case $1 in
        pip3)
            case $NATIVE_OS_KIND in
                *bsd|linux) run pip3 install --user -U "$3" ;;
                *)          run pip3 install        -U "$3"
            esac
            ;;
        pip)
            case $NATIVE_OS_KIND in
                *bsd|linux) run pip  install --user -U "$3" ;;
                *)          run pip  install        -U "$3"
            esac
            ;;
        brew)
            if run brew install "$3" ; then
                unset __HOMEBREW_PKG_PREFIX__
                __HOMEBREW_PKG_PREFIX__="$(brew --prefix "$3")"
                if [ "$(brew info --json=v2 "$3" | sed -n '/"keg_only":/p' | sed 's/ //g' | cut -d: -f2 | sed 's/,//')" = 'true' ] ; then
                    if [ -d "$__HOMEBREW_PKG_PREFIX__/bin" ] ; then
                        export PATH="$__HOMEBREW_PKG_PREFIX__/bin:$PATH"
                    fi
                    if [ -d "$__HOMEBREW_PKG_PREFIX__/sbin" ] ; then
                        export PATH="$__HOMEBREW_PKG_PREFIX__/sbin:$PATH"
                    fi
                fi
                if [ -d "$__HOMEBREW_PKG_PREFIX__/libexec/gnubin" ] ; then
                    export PATH="$__HOMEBREW_PKG_PREFIX__/libexec/gnubin:$PATH"
                fi
                unset __HOMEBREW_PKG_PREFIX__
            else
                return 1
            fi
            ;;
        pkg)     run $sudo pkg install -y "$3" ;;
        pkgin)   run $sudo pkgin -y install "$3" ;;
        pkg_add) run $sudo pkg_add "$3" ;;
        apt)     run $sudo apt -y install "$3" ;;
        apt-get) run $sudo apt-get -y install "$3" ;;
        dnf)     run $sudo dnf -y install "$3" ;;
        yum)     run $sudo yum -y install "$3" ;;
        zypper)  run $sudo zypper install -y "$3" ;;
        apk)     run $sudo apk add "$3" ;;
        xbps)    run $sudo xbps-install -Syu "$3" ;;
        pacman)  run $sudo pacman -Syy --noconfirm && run $sudo pacman -S --noconfirm "$3" ;;
        choco)   run choco install -y --source cygwin "$3" ;;
        cargo)   run cargo install "$3" ;;
        emerge)
            if [ "$3" = 'media-gfx/graphviz' ] ; then
                $sudo cat >> /etc/portage/package.use/zzz_autounmask <<EOF
# required by media-gfx/graphviz-2.44.1-r1::gentoo
# required by media-gfx/graphviz (argument)
>=media-libs/gd-2.3.1 fontconfig truetype
EOF
            fi
            run $sudo emerge "$3" ;;
    esac
}

# check if the give package specification is available in specified package manager's repo
#
# package specification's form: <PKG> [OP VERSION]
#
# OP:
# eq  equal
# ne  not equal
# gt  greater than
# lt  less than
# ge  greater than or equal
# le  less than or equal
#
# __pmw_is_the_given_package_available <PM> <REPO> <PKG> [OP VERSION]
#
# __pmw_is_the_given_package_available apt default automake eq 1.16.0
# __pmw_is_the_given_package_available apt default automake lt 1.16.0
# __pmw_is_the_given_package_available apt default automake gt 1.16.0
# __pmw_is_the_given_package_available apt default automake le 1.16.0
# __pmw_is_the_given_package_available apt default automake ge 1.16.0
# __pmw_is_the_given_package_available apt default automake
__pmw_is_the_given_package_available() {
    if [ $# -eq 3 ] ; then
        case $1 in
            pkg)
                if [ "$NATIVE_OS_KIND" = freebsd ] ; then
                    pkg search -S name "^$3$" > /dev/null 2>&1
                else
                    pkg show "$3" > /dev/null 2>&1
                fi
                ;;
            pkgin)  pkgin search "^$3-[0-9]" >/dev/null 2>&1 ;;
            apt) apt show "$3" > /dev/null 2>&1 ;;
            apk) apk info "$3" > /dev/null 2>&1 ;;
            yum) yum info "$3" > /dev/null 2>&1 ;;
            dnf) dnf info "$3" > /dev/null 2>&1 ;;
            brew) brew info "$3" > /dev/null 2>&1 ;;
            xbps) xbps-query -R "$3" > /dev/null 2>&1 ;;
            pacman) pacman -Ss "^$3$" > /dev/null 2>&1 ;;
            zypper) [ "$(zypper info "$3" 2>&1 | tail -n 1)" != "package '$3' not found." ] ;;
            emerge)
                case $3 in
                    */*) [ "$(emerge -s "%@^$3$" 2>&1 | tail -n 2 | head -n 1)" != '\[ Applications found : 0 \]' ] ;;
                    *)   [ "$(emerge -s "%^$3$"  2>&1 | tail -n 2 | head -n 1)" != '\[ Applications found : 0 \]' ]
                esac
                ;;
        esac
    elif [ $# -eq 5 ] ; then
        __pmw_is_the_given_package_available "$1" "$2" "$3" && version_match "$(__pmw_get_available_package_version_by_package_name "$1" "$3")" "$4" "$5"
    else
        error "USAGE:  __pmw_is_the_given_package_available <PM> <REPO> <PKG> [OP VERSION]\n    ACTUAL: __pmw_is_the_given_package_available $@"
        return 1
    fi
}

# __pmw_get_available_package_version_by_package_name <PM> <PKG>
# __pmw_get_available_package_version_by_package_name apt automake
__pmw_get_available_package_version_by_package_name() {
    case $1 in
        pkg)
            if [ "$NATIVE_OS_KIND" = freebsd ] ; then
                pkg search -S pkg-name "^$2-[0-9]" | cut -d ' ' -f1 | cut -d- -f2 | tr _ .
            else
                pkg show "$2" 2> /dev/null | sed -n '/Version: /p' | head -n 1 | cut -d ' ' -f2 | cut -d- -f1  | cut -d~ -f1 | sed 's/[0-9]://'
            fi
            ;;
        pkgin)  pkgin search "^$2-[0-9]" 2>/dev/null | head -n 1 | cut -d ' ' -f1 | cut -d- -f2 ;;
        apt)   apt show "$2" 2> /dev/null | sed -n '/Version: /p' | head -n 1 | cut -d ' ' -f2 | cut -d- -f1  | cut -d~ -f1 | sed 's/[0-9]://' ;;
        apk)   apk info "$2" 2> /dev/null | head -n 1 | cut -d ' ' -f1 | cut -d- -f2 ;;
        yum)   yum info "$2" 2> /dev/null | sed -n '/Version     :/p'  | head -n 1 | cut -d : -f2 | sed 's/^[[:space:]]//' ;;
        dnf)   dnf info "$2" 2> /dev/null | sed -n '/Version      :/p' | head -n 1 | cut -d : -f2 | sed 's/^[[:space:]]//' ;;
        brew) brew info "$2" 2> /dev/null | head -n 1 | sed -e 's|^==> .*: ||' -e 's|stable ||' | cut -d ' ' -f1 ;;
        xbps) xbps-query -R --property=pkgver "$2" | cut -d- -f2 | cut -d_ -f1 ;;
        pacman) pacman -Ss "^$2$" 2> /dev/null | head -n 1 | cut -d ' ' -f2 | cut -d- -f1 ;;
        zyyper) zyyper info "$2" 2> /dev/null | sed -n '/Version        :/p' | sed 's/Version        : \(.*\)/\1/' | cut -d- -f1 ;;
        emerge)
            case $2 in
                */*) emerge -s "%@^$2$" 2> /dev/null | sed -n '/Latest version available:/p' | cut -d: -f2 ;;
                *)   emerge -s "%^$2$"  2> /dev/null | sed -n '/Latest version available:/p' | cut -d: -f2 ;;
            esac
    esac
}

# }}}
##############################################################################
# {{{ uppm => universal prebuild package manager

__uppm_list_the_available_packages_for_linux_x86_64() {
    cat <<EOF
autoconf   |2.69   |3b29f52cabe26ba0217825b1cf25b8d4163b6e6afcce1cce70027e0bc33a0860|https://github.com/leleliu008/autoconf-prebuild/releases/download/2.69/autoconf-2.69-glibc-linux-x86_64.tar.gz
git        |2.36.1 |d8543cc6a0f29cdcdb9c7418961e349cff8b1b3244fe4db16f6e06315b90c517|https://github.com/leleliu008/ppkg-core-linux-x86_64/releases/download/2022.05.22/git-2.36.1-linux-x86_64.tar.xz
file       |5.41   |004a4110f9f687eefa643db4f59f1500879dd5bd69d0494c3cabd475ed6fd449|https://github.com/leleliu008/ppkg-core-linux-x86_64/releases/download/2022.05.22/file-5.41-linux-x86_64.tar.xz
tree       |2.0.2  |ada484b7bdafdd2f12ed68e204121d83ae5ae8d57c3fc607404219d767bb4bb3|https://github.com/leleliu008/ppkg-core-linux-x86_64/releases/download/2022.05.22/tree-2.0.2-linux-x86_64.tar.xz
patchelf   |0.14.5 |e21089041deb2a3773ba239148e5a6ffa025cbaee0b1a46ff2adb57fc651b3c7|https://github.com/leleliu008/ppkg-core-linux-x86_64/releases/download/2022.05.22/patchelf-0.14.5-linux-x86_64.tar.xz
cmake      |3.21.4 |eddba9da5b60e0b5ec5cbb1a65e504d776e247573204df14f6d004da9bc611f9|https://github.com/Kitware/CMake/releases/download/v3.21.4/cmake-3.21.4-linux-x86_64.tar.gz
ninja      |1.10.2 |763464859c7ef2ea3a0a10f4df40d2025d3bb9438fcb1228404640410c0ec22d|https://github.com/ninja-build/ninja/releases/download/v1.10.2/ninja-linux.zip
golang     |1.18   |e85278e98f57cdb150fe8409e6e5df5343ecb13cebf03a5d5ff12bd55a80264f|https://dl.google.com/go/go1.18.linux-amd64.tar.gz
jdk        |17.0.1 |6f25bcb94d3e22fb52a4632c74e03b403834e81b68701ab7ecd900fb9cd89f43|https://download.oracle.com/java/17/archive/jdk-17.0.1_linux-x64_bin.tar.gz
android-sdk|7583922|124f2d5115eee365df6cf3228ffbca6fc3911d16f8025bebd5b1c6e2fcfa7faf|https://dl.google.com/android/repository/commandlinetools-linux-7583922_latest.zip
EOF
}

__uppm_list_the_available_packages_for_macos_x86_64() {
    cat <<EOF
tree       |2.0.2  |aca635c7394b9c11eb81211670b1961a2be1bd4c86f23eb3e5962bb1ad12ba18|https://raw.githubusercontent.com/leleliu008/ppkg-core-macos-x86_64/master/tree-2.0.2-macos-x86_64.tar.xz
cmake      |3.21.4 |f818a10fe625b215e31d0c29c19a6563fb5f51ed7cc7727e5011626c11ea321a|https://github.com/Kitware/CMake/releases/download/v3.21.4/cmake-3.21.4-macos-universal.tar.gz
ninja      |1.10.2 |6fa359f491fac7e5185273c6421a000eea6a2f0febf0ac03ac900bd4d80ed2a5|https://github.com/ninja-build/ninja/releases/download/v1.10.2/ninja-mac.zip
golang     |1.18   |70bb4a066997535e346c8bfa3e0dfe250d61100b17ccc5676274642447834969|https://dl.google.com/go/go1.18.darwin-amd64.tar.gz
jdk        |17.0.1 |b8905d88a14e60f873064a8b25737e2ec2e3688611adbf21f3a5dd5c8742797d|https://download.oracle.com/java/17/archive/jdk-17.0.1_macos-x64_bin.tar.gz
android-sdk|7583922|6929a1957f3e71008adfade0cebd08ebea9b9f506aa77f1849c7bdc3418df7cf|https://dl.google.com/android/repository/commandlinetools-mac-7583922_latest.zip
EOF
}

__uppm_list_the_available_packages_for_macos_arm64() {
    cat <<EOF
golang     |1.18   |9cab6123af9ffade905525d79fc9ee76651e716c85f1f215872b5f2976782480|https://dl.google.com/go/go1.18.darwin-arm64.tar.gz
jdk        |17.0.1 |8e5f240705bdf37ed831abc8c52cc05afe71721a6bc26dd977b6efd01b5ebef7|https://download.oracle.com/java/17/archive/jdk-17.0.1_macos-aarch64_bin.tar.gz
EOF
}

__uppm_list_the_available_packages() {
    case $NATIVE_OS_KIND-$NATIVE_OS_ARCH in
        linux-x86_64)  __uppm_list_the_available_packages_for_linux_x86_64 ;;
        darwin-x86_64) __uppm_list_the_available_packages_for_macos_x86_64 ;;
        darwin-arm64)  __uppm_list_the_available_packages_for_macos_arm64  ;;
    esac
}

# __uppm_parse_the_given_package_spec <PACKAGE-SPEC>
# __uppm_parse_the_given_package_spec 'cmake<=3.20.1'
# __uppm_parse_the_given_package_spec 'cmake>=3.20.1'
# __uppm_parse_the_given_package_spec 'cmake=3.20.1'
# __uppm_parse_the_given_package_spec 'cmake<3.20.1'
# __uppm_parse_the_given_package_spec 'cmake>3.20.1'
  __uppm_parse_the_given_package_spec() {
    [ -z "$1" ] && {
        error "__uppm_parse_the_given_package_spec <PACKAGE-SPEC>, <PACKAGE-SPEC> must not be empty."
        return 1
    }

    unset UPPM_THE_GIVEN_PACKAGE_SPEC_OP_COUNT_le
    unset UPPM_THE_GIVEN_PACKAGE_SPEC_OP_COUNT_ge
    unset UPPM_THE_GIVEN_PACKAGE_SPEC_OP_COUNT_lt
    unset UPPM_THE_GIVEN_PACKAGE_SPEC_OP_COUNT_gt
    unset UPPM_THE_GIVEN_PACKAGE_SPEC_OP_COUNT_eq

    UPPM_THE_GIVEN_PACKAGE_SPEC_OP_COUNT_le="$(printf '%s\n' "$1" | grep -c '<='     || true)"
    UPPM_THE_GIVEN_PACKAGE_SPEC_OP_COUNT_ge="$(printf '%s\n' "$1" | grep -c '>='     || true)"
    UPPM_THE_GIVEN_PACKAGE_SPEC_OP_COUNT_lt="$(printf '%s\n' "$1" | grep -c '<[^=]'  || true)"
    UPPM_THE_GIVEN_PACKAGE_SPEC_OP_COUNT_gt="$(printf '%s\n' "$1" | grep -c '>[^=]'  || true)"
    UPPM_THE_GIVEN_PACKAGE_SPEC_OP_COUNT_eq="$(printf '%s\n' "$1" | grep -c '[^><]=' || true)"

    UPPM_THE_GIVEN_PACKAGE_SPEC_OP_COUNT_total="$(expr "$UPPM_THE_GIVEN_PACKAGE_SPEC_OP_COUNT_le" + "$UPPM_THE_GIVEN_PACKAGE_SPEC_OP_COUNT_ge" + "$UPPM_THE_GIVEN_PACKAGE_SPEC_OP_COUNT_lt" + "$UPPM_THE_GIVEN_PACKAGE_SPEC_OP_COUNT_gt" + "$UPPM_THE_GIVEN_PACKAGE_SPEC_OP_COUNT_eq")"

    if [ "$UPPM_THE_GIVEN_PACKAGE_SPEC_OP_COUNT_total" -gt 1 ] ; then
        error "__uppm_parse_the_given_package_spec <PACKAGE-SPEC>, PACKAGE-SPEC[$1] is invalid."
        return 1
    fi

    unset UPPM_THE_GIVEN_PACKAGE_SPEC_PACKAHE_NAME
    unset UPPM_THE_GIVEN_PACKAGE_SPEC_PACKAGE_VERS
    unset UPPM_THE_GIVEN_PACKAGE_SPEC_OP

    if [ "$UPPM_THE_GIVEN_PACKAGE_SPEC_OP_COUNT_le" -eq 1 ] ; then
        UPPM_THE_GIVEN_PACKAGE_SPEC_PACKAHE_NAME="$(printf '%s\n' "$1" | sed 's/<=/ /g' | cut -d ' ' -f1)"
        UPPM_THE_GIVEN_PACKAGE_SPEC_PACKAGE_VERS="$(printf '%s\n' "$1" | sed 's/<=/ /g' | cut -d ' ' -f2)"
        UPPM_THE_GIVEN_PACKAGE_SPEC_OP='le'
    fi

    if [ "$UPPM_THE_GIVEN_PACKAGE_SPEC_OP_COUNT_ge" -eq 1 ] ; then
        UPPM_THE_GIVEN_PACKAGE_SPEC_PACKAHE_NAME="$(printf '%s\n' "$1" | sed 's/>=/ /g' | cut -d ' ' -f1)"
        UPPM_THE_GIVEN_PACKAGE_SPEC_PACKAGE_VERS="$(printf '%s\n' "$1" | sed 's/>=/ /g' | cut -d ' ' -f2)"
        UPPM_THE_GIVEN_PACKAGE_SPEC_OP='ge'
    fi

    if [ "$UPPM_THE_GIVEN_PACKAGE_SPEC_OP_COUNT_lt" -eq 1 ] ; then
        UPPM_THE_GIVEN_PACKAGE_SPEC_PACKAHE_NAME="$(printf '%s\n' "$1" | sed 's/</ /g' | cut -d ' ' -f1)"
        UPPM_THE_GIVEN_PACKAGE_SPEC_PACKAGE_VERS="$(printf '%s\n' "$1" | sed 's/</ /g' | cut -d ' ' -f2)"
        UPPM_THE_GIVEN_PACKAGE_SPEC_OP='lt'
    fi

    if [ "$UPPM_THE_GIVEN_PACKAGE_SPEC_OP_COUNT_gt" -eq 1 ] ; then
        UPPM_THE_GIVEN_PACKAGE_SPEC_PACKAHE_NAME="$(printf '%s\n' "$1" | sed 's/>/ /g' | cut -d ' ' -f1)"
        UPPM_THE_GIVEN_PACKAGE_SPEC_PACKAGE_VERS="$(printf '%s\n' "$1" | sed 's/>/ /g' | cut -d ' ' -f2)"
        UPPM_THE_GIVEN_PACKAGE_SPEC_OP='gt'
    fi

    if [ "$UPPM_THE_GIVEN_PACKAGE_SPEC_OP_COUNT_eq" -eq 1 ] ; then
        UPPM_THE_GIVEN_PACKAGE_SPEC_PACKAHE_NAME="$(printf '%s\n' "$1" | sed 's/=/ /g' | cut -d ' ' -f1)"
        UPPM_THE_GIVEN_PACKAGE_SPEC_PACKAGE_VERS="$(printf '%s\n' "$1" | sed 's/=/ /g' | cut -d ' ' -f2)"
        UPPM_THE_GIVEN_PACKAGE_SPEC_OP='eq'
    fi

    if [ "$UPPM_THE_GIVEN_PACKAGE_SPEC_OP_COUNT_total" -eq 0 ] ; then
        UPPM_THE_GIVEN_PACKAGE_SPEC_PACKAHE_NAME="$1"
    else
        if [ -z "$UPPM_THE_GIVEN_PACKAGE_SPEC_PACKAHE_NAME" ] || [ -z "$UPPM_THE_GIVEN_PACKAGE_SPEC_PACKAGE_VERS" ] ; then
            error "__uppm_parse_the_given_package_spec <PACKAGE-SPEC>, PACKAGE-SPEC[$1] is invalid."
            return 1
        fi
    fi
}

# __uppm_is_the_given_package_available <PACKAGE-SPEC>
  __uppm_is_the_given_package_available() {
    __uppm_parse_the_given_package_spec "$1" || return 1

    for UPPM_PKG_LINE in $(__uppm_list_the_available_packages | sed 's/ //g')
    do
        unset UPPM_PKG_NAME
        unset UPPM_PKG_VERS

        if [ -z "$UPPM_PKG_LINE" ] ; then
            continue
        fi

        UPPM_PKG_NAME=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f1)
        UPPM_PKG_VERS=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f2)

        if [ "$UPPM_PKG_NAME" = "$UPPM_THE_GIVEN_PACKAGE_SPEC_PACKAHE_NAME" ] ; then
            if [ -z "$UPPM_THE_GIVEN_PACKAGE_SPEC_OP" ] && [ -z "$UPPM_THE_GIVEN_PACKAGE_SPEC_PACKAGE_VERS" ] ; then
                return 0
            else
                if version_match "$UPPM_PKG_VERS" "$UPPM_THE_GIVEN_PACKAGE_SPEC_OP" "$UPPM_THE_GIVEN_PACKAGE_SPEC_PACKAGE_VERS" ; then
                    return 0
                else
                    return 1
                fi
            fi
        else
            continue
        fi
    done

    return 1
}

# __uppm_is_the_given_package_installed <PACKAGE-NAME>
  __uppm_is_the_given_package_installed() {
    [ -f "$HOME/.uppm/install.d/$1/installed-metadata" ]
}

# __uppm_show_infomation_of_the_given_package <PACKAGE-NAME>
  __uppm_show_infomation_of_the_given_package() {
    if [ -z "$1" ] ; then
        error "uppm info <PACKAGE-NAME>, <PACKAGE-NAME> must not be empty."
        return 1
    fi

    if [ "$1" = '@all' ] ; then
        __uppm_list_the_available_packages
        return $?
    fi

    for UPPM_PKG_LINE in $(__uppm_list_the_available_packages | sed 's/ //g')
    do
        if [ "$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f1)" = "$1" ] ; then
            printf '%s\n' "$UPPM_PKG_LINE"
            return 0
        else
            continue
        fi
    done

    error "uppm package [$1] is not available."
    return 1
}

__uppm_list_the_installed_packages() {
    :
}

__uppm_get_filetype_from_url() {
    case $1 in
        *.zip)     printf '%s\n' zip    ;;
        *.tar.xz)  printf '%s\n' tar.xz ;;
        *.tar.gz)  printf '%s\n' tar.gz ;;
        *.tar.lz)  printf '%s\n' tar.lz ;;
        *.tar.bz2) printf '%s\n' tar.bz2;;
        *.tgz)     printf '%s\n' tar.gz ;;
        *.txz)     printf '%s\n' tar.xz ;;
        *.c)       printf '%s\n' c      ;;
        *.cc)      printf '%s\n' cxx    ;;
        *.cxx)     printf '%s\n' cxx    ;;
        *.cpp)     printf '%s\n' cxx    ;;
    esac
}

# __uppm_fetch_the_given_package <PACKAGE-NAME>
  __uppm_fetch_the_given_package() {
    if [ -z "$1" ] ; then
        error "uppm fetch <PACKAGE-NAME>, <PACKAGE-NAME> must not be empty."
        return 1
    fi

    if [ "$1" = '@all' ] ; then
        UPPM_AVAILABLE_PACKAGES="$(__uppm_list_the_available_packages | sed 's/ //g')"
    else
        UPPM_AVAILABLE_PACKAGES="$(__uppm_show_infomation_of_the_given_package "$1")"
    fi

    if [ -z "$UPPM_AVAILABLE_PACKAGES" ] ; then
        error "no uppm packages to be fetched."
        return 1
    fi

    for UPPM_PKG_LINE in $UPPM_AVAILABLE_PACKAGES
    do
        unset UPPM_PKG_NAME
        unset UPPM_PKG_VERS
        unset UPPM_PKG_SHA_
        unset UPPM_PKG_URL_

        UPPM_PKG_NAME=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f1)
        UPPM_PKG_VERS=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f2)
        UPPM_PKG_SHA_=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f3)
        UPPM_PKG_URL_=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f4)

        UPPM_PKG_FILETYPE=$(__uppm_get_filetype_from_url "$UPPM_PKG_URL_")
        UPPM_PKG_FILENAME="$UPPM_PKG_NAME-$UPPM_PKG_VERS.$UPPM_PKG_FILETYPE"
        UPPM_PKG_FILEPATH="$HOME/.uppm/downloads/$UPPM_PKG_FILENAME"

        fetch "$UPPM_PKG_URL_" --sha256="$UPPM_PKG_SHA_" --output-path="$UPPM_PKG_FILEPATH"
    done
}

# __uppm_install_the_given_package <PACKAGE-SPEC> --prefix=DIR
  __uppm_install_the_given_package() {
    __uppm_parse_the_given_package_spec "$1" || return 1

    unset UPPM_PKG_LINE

    for UPPM_PKG_LINE in $(__uppm_list_the_available_packages | sed 's/ //g')
    do
        unset UPPM_PKG_NAME
        unset UPPM_PKG_VERS

        [ -z "$UPPM_PKG_LINE" ] && {
            unset UPPM_PKG_LINE
            continue
        }

        UPPM_PKG_NAME=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f1)
        UPPM_PKG_VERS=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f2)

        if [ "$UPPM_PKG_NAME" = "$UPPM_THE_GIVEN_PACKAGE_SPEC_PACKAHE_NAME" ] ; then
            if [ -z "$UPPM_THE_GIVEN_PACKAGE_SPEC_OP" ] && [ -z "$UPPM_THE_GIVEN_PACKAGE_SPEC_PACKAGE_VERS" ] ; then
                break
            else
                if version_match "$UPPM_PKG_VERS" "$UPPM_THE_GIVEN_PACKAGE_SPEC_OP" "$UPPM_THE_GIVEN_PACKAGE_SPEC_PACKAGE_VERS" ; then
                    break
                else
                    unset UPPM_PKG_LINE
                    break
                fi
            fi
        else
            unset UPPM_PKG_LINE
            continue
        fi
    done

    if [ -z "$UPPM_PKG_LINE" ] ; then
        error "no available uppm package: $1"
        return 1
    fi

    unset UPPM_PKG_NAME
    unset UPPM_PKG_VERS
    unset UPPM_PKG_SHA_
    unset UPPM_PKG_URL_

    UPPM_PKG_NAME=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f1)
    UPPM_PKG_VERS=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f2)
    UPPM_PKG_SHA_=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f3)
    UPPM_PKG_URL_=$(printf '%s\n' "$UPPM_PKG_LINE" | cut -d '|' -f4)

    UPPM_PKG_FILETYPE=$(__uppm_get_filetype_from_url "$UPPM_PKG_URL_")
    UPPM_PKG_FILENAME="$UPPM_PKG_NAME-$UPPM_PKG_VERS.$UPPM_PKG_FILETYPE"
    UPPM_PKG_FILEPATH="$HOME/.uppm/downloads/$UPPM_PKG_FILENAME"

    fetch "$UPPM_PKG_URL_" --sha256="$UPPM_PKG_SHA_" --output-path="$UPPM_PKG_FILEPATH"

    case $UPPM_PKG_FILETYPE in
        zip)
            handle_dependency required exe unzip
            ;;
        tar.xz)
            handle_dependency required exe tar
            handle_dependency required exe xz
            ;;
        tar.gz)
            handle_dependency required exe tar
            handle_dependency required exe gzip
            ;;
        tar.lz)
            handle_dependency required exe tar
            handle_dependency required exe lzip
            ;;
        tar.bz2)
            handle_dependency required exe tar
            handle_dependency required exe bzip2
            ;;
        tgz)
            handle_dependency required exe tar
            handle_dependency required exe gzip
            ;;
        txz)
            handle_dependency required exe tar
            handle_dependency required exe xz
            ;;
    esac

    unset UPPM_PKG_INSTALL_DIR

    for arg in $@
    do
        case $arg in
            --prefix=*)
                UPPM_PKG_INSTALL_DIR="$(getvalue $arg)"
                case "$UPPM_PKG_INSTALL_DIR" in
                    '') die "--prefix=<DIR>, <DIR> must not be empty." ;;
                    /*) ;;
                    \~|\~/) UPPM_PKG_INSTALL_DIR="${HOME}" ;;
                    \~/*)   UPPM_PKG_INSTALL_DIR="${HOME}$(printf "$UPPM_PKG_INSTALL_DIR" | cut -c2-)" ;;
                    .|./)   UPPM_PKG_INSTALL_DIR="${PWD}" ;;
                    *)      UPPM_PKG_INSTALL_DIR="${PWD}/$UPPM_PKG_INSTALL_DIR" ;;
                esac
        esac
        shift
    done

    if [ -z "$UPPM_PKG_INSTALL_DIR" ] ; then
        UPPM_PKG_INSTALL_DIR="$HOME/.uppm/install.d/$UPPM_PKG_NAME"
    fi

    UPPM_PKG_INSTALLED_METADATA_FILEPATH="$UPPM_PKG_INSTALL_DIR/installed-metadata"

    if [ -f "$UPPM_PKG_INSTALLED_METADATA_FILEPATH" ] ; then
        if [ -z "$UPPM_THE_GIVEN_PACKAGE_SPEC_OP" ] && [ -z "$UPPM_THE_GIVEN_PACKAGE_SPEC_PACKAGE_VERS" ] ; then
            success "$UPPM_PKG_FILEPATH already have been installed to $UPPM_PKG_INSTALL_DIR."
        else
            if version_match "$(. "$UPPM_PKG_INSTALLED_METADATA_FILEPATH" && printf '%s\n' "$INSTALLED_UPPM_PKG_VERS")" "$UPPM_THE_GIVEN_PACKAGE_SPEC_OP" "$UPPM_THE_GIVEN_PACKAGE_SPEC_PACKAGE_VERS" ; then
                success "$UPPM_PKG_FILEPATH already have been installed to $UPPM_PKG_INSTALL_DIR."
            else
                warn "$UPPM_PKG_FILEPATH already have been installed to $UPPM_PKG_INSTALL_DIR. but it not match, I will reinstall it."
                run rm -rf "$UPPM_PKG_INSTALL_DIR"
            fi
        fi
    fi

    if [ ! -f "$UPPM_PKG_INSTALLED_METADATA_FILEPATH" ] ; then
        if [ ! -d "$UPPM_PKG_INSTALL_DIR" ] ; then
            CURRENT_GROUP_NAME="$(id -n -g)"
            CURRENT_USER__NAME="$(id -n -u)"
            install -g "$CURRENT_GROUP_NAME" -o "$CURRENT_USER__NAME" -d "$UPPM_PKG_INSTALL_DIR" 2>/dev/null || sudo install -g "$CURRENT_GROUP_NAME" -o "$CURRENT_USER__NAME" -d "$UPPM_PKG_INSTALL_DIR"
        fi
        case $UPPM_PKG_FILETYPE in
            zip)
                run unzip  "$UPPM_PKG_FILEPATH" -d "$UPPM_PKG_INSTALL_DIR"
                ;;
            tar.xz|tar.gz|tar.lz|tar.bz2|tgz|txz|tlz)
                run tar xf "$UPPM_PKG_FILEPATH" -C "$UPPM_PKG_INSTALL_DIR" --strip-components 1
                ;;
        esac

        cat > "$UPPM_PKG_INSTALLED_METADATA_FILEPATH" <<EOF
INSTALLED_UPPM_PKG_TIME='$(date +%s)'
INSTALLED_UPPM_PKG_NAME='$UPPM_PKG_NAME'
INSTALLED_UPPM_PKG_VERS='$UPPM_PKG_VERS'
INSTALLED_UPPM_PKG_URL_='$UPPM_PKG_URL_'
INSTALLED_UPPM_PKG_SHA_='$UPPM_PKG_SHA_'
EOF
    fi

    if [ -d "$UPPM_PKG_INSTALL_DIR/bin" ] ; then
        bppend_to_PATH "$UPPM_PKG_INSTALL_DIR/bin"
    fi

    bppend_to_PATH "$UPPM_PKG_INSTALL_DIR"

    case $UPPM_PKG_NAME in
        autoconf)
            for xx in $(grep '/root/.zpkg/install.d/autoconf' -rl "$UPPM_PKG_INSTALL_DIR")
            do
                sed_in_place "s|/root/.zpkg/install.d/autoconf|$UPPM_PKG_INSTALL_DIR|" "$xx"
            done
            ;;
        jdk)
            cat > "$UPPM_PKG_INSTALL_DIR/env" <<EOF
bppend_to_PATH() {
    case ":\${PATH}:" in
        *:"\$@":*) ;;
        *) export PATH="\$@:\$PATH" ;;
    esac
}

JAVA_HOME="$UPPM_PKG_INSTALL_DIR"

bppend_to_PATH "$UPPM_PKG_INSTALL_DIR/bin"
EOF
            . "$UPPM_PKG_INSTALL_DIR/env"

    esac
}

__uppm_help() {
    printf '%b\n' "
uppm (universal prebuild package manager)

uppm <ACTION> <ARGUMENT>...

uppm -h
uppm --help

uppm -V
uppm --version

uppm ls-available
uppm ls-installed

uppm is-available <PACKAGE-NAME><OP><PACKAGE-VERSION>]
uppm is-available 'cmake'
uppm is-available 'cmake<=3.20.1'
uppm is-available 'cmake>=3.20.1'
uppm is-available 'cmake=3.20.1'
uppm is-available 'cmake<3.20.1'
uppm is-available 'cmake>3.20.1'

uppm info    <PACKAGE-NAME|@all>

uppm fetch   <PACKAGE-NAME|@all>

uppm install <PACKAGE-NAME><OP><PACKAGE-VERSION>] --prefix=DIR
uppm install 'cmake'
uppm install 'cmake<=3.20.1'
uppm install 'cmake>=3.20.1'
uppm install 'cmake=3.20.1'
uppm install 'cmake<3.20.1'
uppm install 'cmake>3.20.1'
"
}

uppm() {
    set -e

    case $1 in
        -h|--help|'')
            __uppm_help
            ;;
        -V|--version)
            printf '%s\n' "0.0.1"
            ;;
        info)
            shift
            __uppm_show_infomation_of_the_given_package $@
            ;;
        fetch)
            shift
            __uppm_fetch_the_given_package $@
            ;;
        ls-available)
            shift
            __uppm_list_the_available_packages
            ;;
        ls-installed)
            shift
            __uppm_list_the_installed_packages
            ;;
        is-available)
            shift
            __uppm_is_the_given_package_available $@
            ;;
        is-installed)
            shift
            __uppm_is_the_given_package_installed $@
            ;;
        install)
            shift
            __uppm_install_the_given_package $@
            ;;
        *)  error "uppm unrecognized ACTION: $1"
            __uppm_help
            return 1
    esac
}

__uppm_get_package_name_by_command_name() {
    [ -z "$1" ] && {
        error "__uppm_get_package_name_by_command_name <CMD>, <CMD> must not be empty."
        return 1
    }

    case $1 in
        python)         printf '%s\n' 'python3' ;;
        autoconf)       printf '%s\n' 'autoconf';;
        autoreconf)     printf '%s\n' 'autoconf';;
        go)             printf '%s\n' 'golang'  ;;
        java)           printf '%s\n' 'jdk'     ;;
        *)              printf '%s\n' "$1"
    esac
}

# __install_command_via_uppm <CMD> [eq|ne|le|ge|lt|gt <VERSION>]
  __install_command_via_uppm() {
    [ -z "$1" ] && {
        error "__install_command_via_uppm <CMD>, <CMD> must not be empty."
        return 1
    }

    if command_exists_in_filesystem_and_version_matched $@ ; then
        return 0
    fi

    UPPM_PKG_NAME=$(__uppm_get_package_name_by_command_name "$1")

    case $2 in
        '') UPPM_PKG_SPEC="$UPPM_PKG_NAME"     ;;
        le) UPPM_PKG_SPEC="$UPPM_PKG_NAME<=$3" ;;
        ge) UPPM_PKG_SPEC="$UPPM_PKG_NAME>=$3" ;;
        lt) UPPM_PKG_SPEC="$UPPM_PKG_NAME<$3"  ;;
        gt) UPPM_PKG_SPEC="$UPPM_PKG_NAME>$3"  ;;
        eq) UPPM_PKG_SPEC="$UPPM_PKG_NAME=$3"  ;;
    esac

    if  uppm is-available "$UPPM_PKG_SPEC" ; then
        note "${COLOR_GREEN}$@${COLOR_OFF} ${COLOR_YELLOW}command is required, but it is not found on this machine, I will install it via${COLOR_OFF} ${COLOR_GREEN}uppm${COLOR_OFF}"
        uppm install      "$UPPM_PKG_SPEC"
    else
        return 1
    fi
}

# __install_command_via_pmw <CMD> [eq|ne|le|ge|lt|gt <VERSION>]
  __install_command_via_pmw() {
    [ -z "$1" ] && {
        error "__install_command_via_pmw <CMD> [eq|ne|le|ge|lt|gt <VERSION>] , <CMD> must not be empty."
        return 1
    }

    if command_exists_in_filesystem_and_version_matched $@ ; then
        return 0
    fi

    AVAILABLE_PACKAGE_MANAGER_LIST=$(__pmw_get_available_pm_list | tr '\n' ' ')
    if [ -z "$AVAILABLE_PACKAGE_MANAGER_LIST" ] ; then
        warn "no package manager found."
        return 1
    else
        note "Found $(list_length $AVAILABLE_PACKAGE_MANAGER_LIST) package manager : ${COLOR_GREEN}$AVAILABLE_PACKAGE_MANAGER_LIST${COLOR_OFF}"
    fi

    for pm in $AVAILABLE_PACKAGE_MANAGER_LIST
    do
        unset PMW_PM_NAME_UNDERSCORE
        unset PMW_REPO_PKG_ITEM
        unset PMW_REPO_NAME
        unset PMW_PKG__NAME

        PMW_PM_NAME_UNDERSCORE="$(printf '%s\n' "$pm" | tr - _)"
        PMW_REPO_PKG_ITEM="$(eval __pmw_get_available_package_name_by_command_name_$PMW_PM_NAME_UNDERSCORE $1)"

        # if pacmakge name is empty, I assume that command name is equal to package name.
        if [ -z "$PMW_REPO_PKG_ITEM" ] ; then
            PMW_REPO_NAME=default
            PMW_PKG__NAME="$1"
        else
            case $PMW_REPO_PKG_ITEM in
                *:*)
                    PMW_REPO_NAME=$(printf '%s\n' "$PMW_REPO_PKG_ITEM" | cut -d: -f1)
                    PMW_PKG__NAME=$(printf '%s\n' "$PMW_REPO_PKG_ITEM" | cut -d: -f2)
                    ;;
                *)  PMW_REPO_NAME=default
                    PMW_PKG__NAME="$PMW_REPO_PKG_ITEM"
            esac
        fi
        __pmw_install_the_given_package "$pm" "$PMW_REPO_NAME" "$PMW_PKG__NAME" $2 $3 && return 0
    done
    return 1
}

__install_command_via_run_install_script() {
    case $1 in
        java|javac|jar)
            install_jdk_if_needed
            ;;
        adb|aapt|aapt2|sdkmanager|zipalign)
            install_android_sdk_if_needed
            ;;
        gclient)
            handle_dependency required exe git || return 1

            # https://commondatastorage.googleapis.com/chrome-infra-docs/flat/depot_tools/docs/html/depot_tools_tutorial.html

            if [ !          -d "$MY_HOME_DIR/native" ] ; then
                run install -d "$MY_HOME_DIR/native" || return 1
            fi

            if [ -d "$MY_HOME_DIR/native/depot_tools" ] ; then
                if [ -d "$MY_HOME_DIR/native/depot_tools/.git" ] && git -C "$MY_HOME_DIR/native/depot_tools" rev-parse 2> /dev/null ; then
                    # do nothing. depot_tools will be automatically updated when you running 'yes | gclient sync' command
                    :
                else
                    run rm -rf "$MY_HOME_DIR/native/depot_tools" || return 1
                    run git -C "$MY_HOME_DIR/native/depot_tools" clone https://gitlab.com/webrtc-mirror/depot_tools.git || return 1
                fi
            else
                run git -C "$MY_HOME_DIR/native" clone https://gitlab.com/webrtc-mirror/depot_tools.git || return 1
            fi

            export PATH="$MY_HOME_DIR/native/depot_tools:$PATH"
            ;;
        xmake)
            handle_dependency required exe bash || return 1

            # https://xmake.io/#/guide/installation
            note "${COLOR_GREEN}$1${COLOR_OFF} ${COLOR_YELLOW}command is required, but it is not found on this machine, I will install it via running shell script.${COLOR_OFF}"

            if [ -f    "$MY_HOME_DIR/tmp.d/get-xmake.sh" ] ; then
                run rm "$MY_HOME_DIR/tmp.d/get-xmake.sh" || return 1
            fi

            fetch 'https://xmake.io/shget.text' --output-path="$MY_HOME_DIR/tmp.d/get-xmake.sh" || return 1

            run bash "$MY_HOME_DIR/tmp.d/get-xmake.sh"
            ;;
        rustup)
            handle_dependency required exe bash:zsh:dash:ash || return 1

            # https://www.rust-lang.org/tools/install
            note "${COLOR_GREEN}$1${COLOR_OFF} ${COLOR_YELLOW}command is required, but it is not found on this machine, I will install it via running shell script.${COLOR_OFF}"

            if [ -f    "$MY_HOME_DIR/tmp.d/rustup-init.sh" ] ; then
                run rm "$MY_HOME_DIR/tmp.d/rustup-init.sh" || return 1
            fi

            fetch 'https://sh.rustup.rs' --output-path="$MY_HOME_DIR/tmp.d/rustup-init.sh" || return 1

            run $(command -v bash || command -v zsh || command -v dash || command -v ash || command -v sh) "$MY_HOME_DIR/tmp.d/rustup-init.sh" -y || return 1

            export CARGO_HOME=$HOME/.cargo
            export PATH="$CARGO_HOME/bin:$PATH"
            ;;
        nvm)
            # https://github.com/nvm-sh/nvm
            note "${COLOR_GREEN}$1${COLOR_OFF} ${COLOR_YELLOW}command is required, but it is not found on this machine, I will install it via running bash shell script.${COLOR_OFF}"

            handle_dependency required exe bash:zsh || return 1

            if [ -f    "$MY_HOME_DIR/tmp.d/install-nvm.sh" ] ; then
                run rm "$MY_HOME_DIR/tmp.d/install-nvm.sh" || return 1
            fi

	        fetch "$(github_user_content_base_url)/nvm-sh/nvm/master/install-nvm.sh" || return 1

            run $(command -v bash || command -v zsh || printf '%s\n' bash) "$MY_HOME_DIR/tmp.d/install-nvm.sh" || return 1

	        export NVM_DIR="${HOME}/.nvm"
	        . "${HOME}/.nvm/nvm.sh"
            ;;
        *)  return 1
    esac
}

__install_command_via_pip() {
    if [ -z "$(__pmw_get_available_package_name_by_command_name_pip3 "$1")" ] ; then
        return 1
    fi

    handle_dependency required exe pip3:pip || return 1

    (
        unset __PIP_COMMAND__
        __PIP_COMMAND__="$(command -v pip3.8)"

        if [ -n "$__PIP_COMMAND__" ] && [ -d '/usr/local/bin' ] ; then
            $sudo ln -sf "$__PIP_COMMAND__" /usr/local/bin/pip3
        fi
    )

    if   command_exists_in_filesystem pip3 ; then
        __pmw_install_the_given_package pip3 default "$(__pmw_get_available_package_name_by_command_name_pip3 "$1")"
    elif command_exists_in_filesystem pip ; then
        __pmw_install_the_given_package pip  default "$(__pmw_get_available_package_name_by_command_name_pip "$1")"
    else
        return 1
    fi
}

# __install_command <CMD> [OP VERSION]
# __install_command python3 ge 3.5
# __install_command make
  __install_command() {
    if command_exists_in_filesystem_and_version_matched $@ ; then
        return 0
    fi

    if __install_command_via_run_install_script $@ ; then
        return 0
    fi

    if __install_command_via_pip $@ ; then
        return 0
    fi

    if __install_command_via_pmw $@ ; then
        return 0
    fi

    if __install_command_via_uppm $@ ; then
        return 0
    fi

    warn "${COLOR_GREEN}$@${COLOR_OFF} ${COLOR_YELLOW}command is required, but I found no way to install it.${COLOR_OFF}\n"
    return 1
}

# usage:
# handle_depnedency <required|optional> <exe|pym|plm> [eq|ne|ge|lt|gt|lt <VERSION>]
#
# examples:
# handle_dependency required exe python      ge 3.5
# handle_dependency required pym libxml2     ge 2.19
# handle_dependency required plm XML::Parser ge 2.45
#
# handle_dependency optional exe python      ge 3.5
# handle_dependency optional pym libxml2     ge 2.19
# handle_dependency optional plm XML::Parser ge 2.45
  handle_dependency() {
    [ "$1" = 'required' ] || return 0

    shift

    case $1 in
        exe)
            shift
            case $1 in
                *:*)
                    for CMD in $(printf '%s\n' "$1" | tr ':' ' ')
                    do
                        if command_exists_in_filesystem_and_version_matched "$CMD" $2 $3 ; then
                            map_set MAP_REQUIRED_DEPENDENCIES "$1" "$CMD"
                            return 0
                        fi
                    done

                    for CMD in $(printf '%s\n' "$1" | tr ':' ' ')
                    do
                        if __install_command "$CMD" $2 $3 ; then
                            map_set MAP_REQUIRED_DEPENDENCIES "$1" "$CMD"
                            return 0
                        fi
                    done

                    return 1
                    ;;
                *)  __install_command $@
            esac
            ;;
        pym)
            shift
            python_module install $@
            ;;
        plm)
            shift
            perl_module   install $@
            ;;
        *)  error "handle_dependency() unrecognized argument:$1" ; return 1
    esac
}

__handle_required_dependencies() {
    step "handle required dependencies"

    for dependency in $REQUIRED_DEPENDENCIES
    do
        handle_dependency $(__decode_dependency "$dependency")
    done
}

# }}}
##############################################################################
# {{{ __printf_dependencies

# examples:
# __printf_dependency required exe python      ge 3.5
# __printf_dependency required pym libxml2     ge 2.19
# __printf_dependency required plm XML::Parser ge 2.45
#
# __printf_dependency optional exe python      ge 3.5
# __printf_dependency optional plm libxml2     ge 2.19
# __printf_dependency optional plm XML::Parser ge 2.45
  __printf_dependency() {
    printf "%-10s %-15s %-2s %-10s %-10s %s\n" "$1" "$2" "$3" "$4" "$5" "$6"
}

# examples:
# printf_dependency required exe python      ge 3.5
# printf_dependency required pym libxml2     ge 2.19
# printf_dependency required plm XML::Parser ge 2.45
#
# printf_dependency optional exe python      ge 3.5
# printf_dependency optional pym libxml2     ge 2.19
# printf_dependency optional plm XML::Parser ge 2.45
  printf_dependency() {
    case $2 in
        exe)
            case $3 in
                *:*)
                    if [ "$1" = 'required' ] ; then
                        REQUIRED_ITEM="$(map_get MAP_REQUIRED_DEPENDENCIES "$3")"
                        __printf_dependency "$2" "$REQUIRED_ITEM" "$4" "$5" "$(version_of_command $REQUIRED_ITEM)" "$(command -v $REQUIRED_ITEM)"
                    else
                        for item in $(printf '%s\n' "$3" | tr ':' ' ')
                        do
                            __printf_dependency "$2" "$item" "$4" "$5" "$(version_of_command $item)" "$(command -v $item)"
                        done
                    fi
                    ;;
                *)  __printf_dependency "$2" "$3" "$4" "$5" "$(version_of_command $3)" "$(command -v $3)"
            esac
            ;;
        pym)
            __printf_dependency "$2" "$3" "$4" "$5" "$(python_module get-version "$item")" "$(python_module get-location "$item")"
            ;;
        plm)
            __printf_dependency "$2" "$3" "$4" "$5" "$(perl_module get-version "$item")" "$(perl_module get-location "$item")"
            ;;
        *)  error "printf_dependency() unrecognized argument: $2" ; return 1
    esac
}

__printf_required_dependencies() {
    step "printf required dependencies"
    if [ -z "$REQUIRED_DEPENDENCIES" ] ; then
        note "no required dependencies."
    else
        __printf_dependency TYPE NAME OP EXPECT ACTUAL LOCATION
        for dependency in $REQUIRED_DEPENDENCIES
        do
            printf_dependency $(__decode_dependency "$dependency")
        done
    fi
}

__printf_optional_dependencies() {
    step "printf optional dependencies"
    if [ -z "$OPTIONAL_DEPENDENCIES" ] ; then
        note "no optional dependencies."
    else
        __printf_dependency TYPE NAME OP EXPECT ACTUAL LOCATION
        for dependency in $OPTIONAL_DEPENDENCIES
        do
            printf_dependency $(__decode_dependency "$dependency")
        done
    fi
}

# }}}
##############################################################################
# {{{ python_module

# examples:
# python_module is  installed libxml2
# python_module get version   libxml2
# python_module get location  libxml2
# python_module install       libxml2
  python_module() {
    case $1 in
        is)
            [ $# -eq 3 ] || {
                error "[python_module is] command accept 2 arguments."
                return 1
            }

            handle_dependency required exe python3:python3.9:python3.8:python3.7:python3.6:python3.5:python || return 1
            handle_dependency required exe pip3:pip3.9:pip3.8:pip3.7:pip3.6:pip3.5:pip || return 1

            __PYTHON_COMMAND__=$(command -v python3 || command -v python3.9 || command -v python3.8 || command -v python3.7 || command -v python3.6 || command -v python3.5 || command -v python || printf '%s\n' python)
            __PIP_COMMAND__=$(command -v pip3 || command -v pip3.9 || command -v pip3.8 || command -v pip3.7 || command -v pip3.6 || command -v pip3.5 || command -v pip || printf '%s\n' pip)

            case $2 in
                installed)  "$__PYTHON_COMMAND__" -c "import $3" 2> /dev/null ;;
                *) error "python_module is $2: not support." ; return 1
            esac
            ;;
        get)
            [ $# -eq 3 ] || {
                error "[python_module get] command accept 2 arguments."
                return 1
            }

            handle_dependency required exe python3:python3.9:python3.8:python3.7:python3.6:python3.5:python || return 1
            handle_dependency required exe pip3:pip3.9:pip3.8:pip3.7:pip3.6:pip3.5:pip || return 1

            __PYTHON_COMMAND__=$(command -v python3 || command -v python3.9 || command -v python3.8 || command -v python3.7 || command -v python3.6 || command -v python3.5 || command -v python || printf '%s\n' python)
            __PIP_COMMAND__=$(command -v pip3 || command -v pip3.9 || command -v pip3.8 || command -v pip3.7 || command -v pip3.6 || command -v pip3.5 || command -v pip || printf '%s\n' pip)

            case $2 in
                version)  "$__PIP_COMMAND__" show "$3" 2> /dev/null | sed -n '/Version:/p'  | cut -d ' ' -f2 ;;
                location) "$__PIP_COMMAND__" show "$3" 2> /dev/null | sed -n '/Location:/p' | cut -d ' ' -f2 ;;
                *) error "python_module get $2: not support." ; return 1
            esac
            ;;
        install)
            [ -z "$2" ] && {
                error "please specify a python module name."
                return 1
            }

            if ! python_module is installed "$2" ; then
                note "${COLOR_GREEN}$2${COLOR_OFF} ${COLOR_YELLOW}python module is required, but it is not found on this machine, I will install it via${COLOR_OFF} ${COLOR_GREEN}$__PIP_COMMAND__${COLOR_OFF}"
                run "$__PIP_COMMAND__" install -U pip
                run "$__PIP_COMMAND__" install -U "$2"
            fi
            ;;
        *)  error "python_module $1: not support." ; return 1
    esac
}

# }}}
##############################################################################
# {{{ perl_module

# examples:
# perl_module is-installed  XML::Parser
# perl_module install       XML::Parser
# perl_module get-version   XML::Parser
# perl_module get-location  XML::Parser
  perl_module() {
    case $1 in
        get-version)
            shift
            cpan -l 2>/dev/null | sed -n "/$1/p" | head -n 1 | cut -f2
            ;;
        get-location)
            shift
            __PERL_MODULE_NAME_TO_PATH=$(printf "%s.pm\n" "$1" | sed 's|::|/|g')
            for item in $(perl -e 'print "@INC"')
            do
                if [ -e           "$item/$__PERL_MODULE_NAME_TO_PATH" ] ; then
                    printf '%s\n' "$item/$__PERL_MODULE_NAME_TO_PATH"
                    return 0
                else
                    continue
                fi
                return 1
            done
            ;;
        is-installed)
            shift
            handle_dependency required exe perl || return 1
            perl -M"$1" -le 'print "installed"' > /dev/null 2>&1
            ;;
        install)
            shift
            perl_module is-installed "$1" && return 0

            if command_exists_in_filesystem cpan  ; then
                note "${COLOR_GREEN}$@${COLOR_OFF} ${COLOR_YELLOW}perl module is required, but it is not found on this machine, I will install it via${COLOR_OFF} ${COLOR_GREEN}cpan${COLOR_OFF}"
                run cpan -i "$1"
            elif command_exists_in_filesystem cpanm ; then
                note "${COLOR_GREEN}$@${COLOR_OFF} ${COLOR_YELLOW}perl module is required, but it is not found on this machine, I will install it via${COLOR_OFF} ${COLOR_GREEN}cpanm${COLOR_OFF}"
                run cpanm "$1"
            else
                handle_dependency required exe cpan:cpanm || return 1
                perl_module install $@
            fi
            ;;
        *)  error "perl_module $1: not support." ; return 1
    esac
}

# }}}
##############################################################################
# {{{ encode/decode dependency

__encode_dependency() {
    if [ $# -eq 0 ] ; then
        tr ' ' '|'
    else
        printf "%s" "$*" | tr ' ' '|'
    fi
}

__decode_dependency() {
    if [ $# -eq 0 ] ; then
        tr '|' ' '
    else
        printf "%s" "$*" | tr '|' ' '
    fi
}

# }}}
##############################################################################
# {{{ regist dependency

# regist dependency required|optional exe|lib|dev|py|pm|pip|npm|gem|pub|cargo|go NAME
#
# required this is a required dependency
# optional this is a optional dependency
#
# exe  this dependency is a command
# py   this dependency is a python  module
# py2  this dependency is a python2 module
# py3  this dependency is a python3 module
# pm   this dependency is a perl module
#
# gt VERSION
# ge VERSION
# lt VERSION
# le VERSION
# eq VERSION
# ne VERSION
#
# examples:
# regist_dependency required exe pkg-config ge 0.18
# regist_dependency required exe python     ge 3.5
# regist_dependency required py  libxml2    ge 2.19
#
# regist_dependency optional exe pkg-config ge 0.18
# regist_dependency optional exe python     ge 3.5
# regist_dependency optional py  libxml2    ge 2.19
  regist_dependency() {
    case $1 in
        required)
            if [ -z "$REQUIRED_DEPENDENCIES" ] ; then
                REQUIRED_DEPENDENCIES="$(__encode_dependency "$*")"
            else
                REQUIRED_DEPENDENCIES="$REQUIRED_DEPENDENCIES $(__encode_dependency "$*")"
            fi
            ;;
        optional)
            if [ -z "$OPTIONAL_DEPENDENCIES" ] ; then
                OPTIONAL_DEPENDENCIES=$(__encode_dependency "$*")
            else
                OPTIONAL_DEPENDENCIES="$OPTIONAL_DEPENDENCIES $(__encode_dependency "$*")"
            fi
    esac
}

# }}}
##############################################################################
# {{{ define formula syntax

# set the given package's information
#
# USAGE:
# pkg_set <KEY> <VALUE>
#
# EXAMPLES:
# pkg_set summary "JPEG image codec that aids compression and decompression"
# pkg_set webpage "https://www.libjpeg-turbo.org"

# pkg_set git.url "https://github.com/libjpeg-turbo/libjpeg-turbo.git"
# pkg_set git.rev "5db6aa6cab1b146e07b60cc1736a01f21da01154"

# pkg_set src.url "https://downloads.sourceforge.net/project/libjpeg-turbo/2.0.6/libjpeg-turbo-2.1.2.tar.gz"
# pkg_set src.sha "d74b92ac33b0e3657123ddcf6728788c90dc84dcb6a52013d758af3c4af481bb"

# pkg_set version "1.0.0"

# pkg_set license "IJG"

# pkg_set dep.cmd "nasm"
# pkg_set dep.cmd "nasm flex bison"

# pkg_set dep.pkg "openssl"
# pkg_set dep.pkg "openssl zlib"

# pkg_set bsystem "cmake"

# pkg_set bscript "src"

# pkg_set binbstd 'yes'
# pkg_set binbstd 'no'

# pkg_set sdk.api '23'
  pkg_set() {
    [ -z "$1" ] && {
        error "pkg_set <KEY> <VALUE>..., <KEY> must not be empty."
        return 1
    }

    [ -z "$2" ] && {
        error "pkg_set <KEY> <VALUE>..., <VALUE> must not be empty."
        return 1
    }


    unset __PACKAGE_SET_KEY__

    __PACKAGE_SET_KEY__="$(printf '%s\n' "$1" | tr '+-.' '_' | tr a-z A-Z)"

    shift

    eval "PACKAGE_$__PACKAGE_SET_KEY__='$@'"
}

# __parse_require_dependency_item <exe|pym|plm> <cmake>=3.19>
  __parse_require_dependency_item() {
    case $2 in
        *\<=*) printf '%s\n' "required $1 $2" | sed 's/<=/ le /g' ;;
        *\>=*) printf '%s\n' "required $1 $2" | sed 's/>=/ ge /g' ;;
        *=*)   printf '%s\n' "required $1 $2" | sed 's/=/  eq /g' ;;
        *\<*)  printf '%s\n' "required $1 $2" | sed 's/</  lt /g' ;;
        *\>*)  printf '%s\n' "required $1 $2" | sed 's/>/  gt /g' ;;
        *)     printf '%s\n' "required $1 $2"
    esac
}

# }}}
##############################################################################
# {{{ operations of formula

# __load_formula_of_the_given_package <PACKAGE-NAME>
  __load_formula_of_the_given_package() {
    [ -z "$1" ] && {
        error "__load_formula_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is not given."
        return 1
    }

    unset PACKAGE_FORMULA_LOADED

    unset PACKAGE_NAME
    unset PACKAGE_NAME_UPPERCASE_UNDERSCORE

    unset PACKAGE_SUMMARY
    unset PACKAGE_WEBPAGE

    unset PACKAGE_GIT_URL
    unset PACKAGE_GIT_SHA
    unset PACKAGE_GIT_TAG

    unset PACKAGE_SVN_URL

    unset PACKAGE_SRC_URL
    unset PACKAGE_SRC_SHA
    unset PACKAGE_SRC_NAME
    unset PACKAGE_SRC_TYPE
    unset PACKAGE_SRC_PATH

    unset PACKAGE_FIX_URL
    unset PACKAGE_FIX_SHA
    unset PACKAGE_FIX_NAME
    unset PACKAGE_FIX_TYPE
    unset PACKAGE_FIX_PATH

    unset PACKAGE_VERSION
    unset PACKAGE_VERSION_MAJOR
    unset PACKAGE_VERSION_MINOR
    unset PACKAGE_VERSION_PATCH
    unset PACKAGE_VERSION_TWEAK

    unset PACKAGE_DEVELOPER

    unset PACKAGE_LICENSE

    unset PACKAGE_BSYSTEM

    unset PACKAGE_BUILD_SYSTEM
    unset PACKAGE_BUILD_SYSTEM_GO
    unset PACKAGE_BUILD_SYSTEM_RAKE
    unset PACKAGE_BUILD_SYSTEM_NINJA
    unset PACKAGE_BUILD_SYSTEM_GMAKE
    unset PACKAGE_BUILD_SYSTEM_CMAKE
    unset PACKAGE_BUILD_SYSTEM_XMAKE
    unset PACKAGE_BUILD_SYSTEM_MESON
    unset PACKAGE_BUILD_SYSTEM_CARGO
    unset PACKAGE_BUILD_SYSTEM_AUTOGENSH
    unset PACKAGE_BUILD_SYSTEM_AUTOTOOLS
    unset PACKAGE_BUILD_SYSTEM_CONFIGURE
    unset PACKAGE_BUILD_SYSTEM_NDK_BUILD

    # dir relative to $PACKAGE_INSTALLING_TOP_DIR, where the build script (such as autogen.sh, configure, Makefile, CMakeLists.txt, meson.build, Cargo.toml, xmake.lua, etc) is located in.
    unset PACKAGE_BSCRIPT

    # if build in build script dir, otherwise build in build dir
    unset PACKAGE_BINBSTD
    unset PACKAGE_BUILD_IN_BSCRIPT_DIR

    # if build in parallel
    unset PACKAGE_BUILD_IN_PARALLEL
    unset PACKAGE_PARALLEL

    # dependency commands       List
    unset PACKAGE_DEP_CMD

    # dependency python modules List
    unset PACKAGE_DEP_PYM

    # dependency perl modules   List
    unset PACKAGE_DEP_PLM

    # dependency packages       List
    unset PACKAGE_DEP_PKG

    unset PACKAGE_CDEFINE
    unset PACKAGE_CCFLAGS
    unset PACKAGE_XXFLAGS
    unset PACKAGE_LDFLAGS

    unset PACKAGE_FORMULA_FILEPATH

    unset PACKAGE_SDK_API

    unset PACKAGE_INSTALL
    unset PACKAGE_INSTALL_EXE
    unset PACKAGE_INSTALL_PIE
    unset PACKAGE_INSTALL_DEV
    unset PACKAGE_INSTALL_LIB

    unset -f build0
    unset -f prepare
    unset -f build
    unset -f build_configed

    PACKAGE_FORMULA_FILEPATH="$(__path_of_formula_of_the_given_package $1)" || return 1

    . "$PACKAGE_FORMULA_FILEPATH" || return 1

    PACKAGE_NAME="$1"
    PACKAGE_NAME_UPPERCASE_UNDERSCORE=$(printf '%s\n' "$PACKAGE_NAME" | tr a-z A-Z | tr '+-.' '_')

    PACKAGE_BUILD_SYSTEM=$PACKAGE_BSYSTEM

    PACKAGE_BUILD_IN_BSCRIPT_DIR=$PACKAGE_BINBSTD

    if [ -z "$PACKAGE_PARALLEL" ] ; then
        PACKAGE_PARALLEL=yes
        PACKAGE_BUILD_IN_PARALLEL=yes
    else
        PACKAGE_BUILD_IN_PARALLEL="$PACKAGE_PARALLEL"
    fi

    if [ -z "$PACKAGE_SUMMARY" ] ; then
        die "summary must be configed in $PACKAGE_FORMULA_FILEPATH"
    fi

    if [ -z "$PACKAGE_WEBPAGE" ] ; then
        PACKAGE_WEBPAGE="$PACKAGE_GIT_URL"
    fi

    if [ -z "$PACKAGE_WEBPAGE" ] ; then
        die "webpage or git.url must be configed in $PACKAGE_FORMULA_FILEPATH"
    fi

    if [ -z "$PACKAGE_SRC_URL" ] ; then
        PACKAGE_SRC_URL="$PACKAGE_GIT_URL"
    fi

    if [ -z "$PACKAGE_SRC_URL" ] ; then
        die "src.url or git.url must be configed in $PACKAGE_FORMULA_FILEPATH"
    fi

    case $PACKAGE_SRC_URL in
        dir://*)   PACKAGE_SRC_TYPE=dir ;;
        *.git)     PACKAGE_SRC_TYPE=git    ; PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD git" ;;
        *.zip)     PACKAGE_SRC_TYPE=zip    ; PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD curl unzip" ;;
        *.tar.xz)  PACKAGE_SRC_TYPE=tar.xz ; PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD curl tar xz" ;;
        *.tar.gz)  PACKAGE_SRC_TYPE=tar.gz ; PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD curl tar gzip" ;;
        *.tar.lz)  PACKAGE_SRC_TYPE=tar.lz ; PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD curl tar lzip" ;;
        *.tar.bz2) PACKAGE_SRC_TYPE=tar.bz2; PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD curl tar bzip2" ;;
        *.tgz)     PACKAGE_SRC_TYPE=tar.gz ; PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD curl tar gzip" ;;
        *.txz)     PACKAGE_SRC_TYPE=tar.xz ; PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD curl tar xz" ;;
        *.c)       PACKAGE_SRC_TYPE=c      ; PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD curl" ;;
        *.cc)      PACKAGE_SRC_TYPE=cxx    ; PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD curl" ;;
        *.cxx)     PACKAGE_SRC_TYPE=cxx    ; PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD curl" ;;
        *.cpp)     PACKAGE_SRC_TYPE=cxx    ; PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD curl" ;;
        *)  die "unrecognized extension : $PACKAGE_SRC_URL. the supported extensions are .git .zip .tar.xz .tar.gz .tar.lz .tar.bz2 .tgz .txz"
    esac

    case $PACKAGE_SRC_TYPE in
        dir)
            PACKAGE_SRC_PATH=$(printf '%s\n' "$PACKAGE_SRC_URL" | cut -c7-)

            if [ -z "$PACKAGE_VERSION" ] ; then
                PACKAGE_VERSION="$(format_unix_timestamp "$TIMESTAMP_UNIX" '+%Y.%m.%d')"
            fi
            ;;
        git)
            PACKAGE_SRC_NAME="$PACKAGE_NAME.git"
            PACKAGE_SRC_PATH="$MY_SOURCE_DIR/$PACKAGE_SRC_NAME"

            if [ -z "$PACKAGE_VERSION" ] ; then
                PACKAGE_VERSION="$(format_unix_timestamp "$TIMESTAMP_UNIX" '+%Y.%m.%d')"
            fi
            ;;
        *)
            if [ -z "$PACKAGE_SRC_SHA" ] ; then
                die "src.sha is not configed in $PACKAGE_FORMULA_FILEPATH"
            fi

            if [ -z "$PACKAGE_VERSION" ] ; then
                PACKAGE_VERSION="$(basename "$PACKAGE_SRC_URL" | tr '_@' - | sed 's|-stable||' | sed 's|-src||' | sed 's|\.src||' | sed 's|\.orig\.|.|' | awk '{str = tolower($0); gsub(".tar.xz", "", str); gsub(".tar.gz", "", str); gsub(".tar.lz", "", str); gsub(".tar.bz2", "", str); gsub(".tgz", "", str); gsub(".txz", "", str); gsub(".zip", "", str); print(str)}' | awk -F- '{print $NF}')"
                case $PACKAGE_VERSION in
                    '') die "version is not configed in $PACKAGE_FORMULA_FILEPATH" ;;
                    v*) PACKAGE_VERSION=$(printf '%s\n' "$PACKAGE_VERSION" | cut -c2-)
                esac
            fi

            PACKAGE_SRC_NAME="$PACKAGE_NAME-$PACKAGE_VERSION.$PACKAGE_SRC_TYPE"
            PACKAGE_SRC_PATH="$MY_SOURCE_DIR/$PACKAGE_SRC_NAME"
    esac

    if [ -n "$PACKAGE_FIX_URL" ] ; then
        case $PACKAGE_FIX_URL in
            *.fix)     PACKAGE_FIX_TYPE=patch  ; PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD patch"           ;;
            *.diff)    PACKAGE_FIX_TYPE=patch  ; PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD patch"           ;;
            *.patch)   PACKAGE_FIX_TYPE=patch  ; PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD patch"           ;;
            *.zip)     PACKAGE_FIX_TYPE=zip    ; PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD patch unzip"     ;;
            *.tar.xz)  PACKAGE_FIX_TYPE=tar.xz ; PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD patch tar xz"    ;;
            *.tar.gz)  PACKAGE_FIX_TYPE=tar.gz ; PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD patch tar gzip"  ;;
            *.tar.lz)  PACKAGE_FIX_TYPE=tar.lz ; PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD patch tar lzip"  ;;
            *.tar.bz2) PACKAGE_FIX_TYPE=tar.bz2; PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD patch tar bzip2" ;;
            *.tgz)     PACKAGE_FIX_TYPE=tar.gz ; PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD patch tar gzip"  ;;
            *.txz)     PACKAGE_FIX_TYPE=tar.xz ; PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD patch tar xz"    ;;
            *)  die "unrecognized fix extension : $PACKAGE_FIX_URL.\n    supported fix extensons are: .fix .diff .patch .zip .tar.xz .tar.gz .tar.lz .tar.bz2 .tgz .txz"
        esac

        if [ -z "$PACKAGE_FIX_SHA" ] ; then
            die "fix.sha is not configed in $PACKAGE_FORMULA_FILEPATH"
        fi

        PACKAGE_FIX_NAME=$(basename "$PACKAGE_FIX_URL")
        PACKAGE_FIX_PATH="$MY_PATCH__DIR/$PACKAGE_NAME/$PACKAGE_FIX_NAME"
    fi

    if [ -n "$PACKAGE_VERSION" ] ; then
        PACKAGE_VERSION_MAJOR="$(printf '%s\n' "$PACKAGE_VERSION" | cut -d. -f1)"
        PACKAGE_VERSION_MINOR="$(printf '%s\n' "$PACKAGE_VERSION" | cut -d. -f2)"
        PACKAGE_VERSION_PATCH="$(printf '%s\n' "$PACKAGE_VERSION" | cut -d. -f3)"
        PACKAGE_VERSION_TWEAK="$(printf '%s\n' "$PACKAGE_VERSION" | cut -d. -f4)"
    fi

    for item in $PACKAGE_BUILD_SYSTEM
    do
        case $item in
            ndk-build)   PACKAGE_BUILD_SYSTEM_NDK_BUILD=yes ;;
            autogen)     PACKAGE_BUILD_SYSTEM_AUTOGENSH=yes ; PACKAGE_BUILD_SYSTEM_GMAKE=yes ;;
            autotools)   PACKAGE_BUILD_SYSTEM_AUTOTOOLS=yes ; PACKAGE_BUILD_SYSTEM_GMAKE=yes ;;
            configure)   PACKAGE_BUILD_SYSTEM_CONFIGURE=yes ; PACKAGE_BUILD_SYSTEM_GMAKE=yes ;;
            cmake-gmake) PACKAGE_BUILD_SYSTEM_CMAKE=yes     ; PACKAGE_BUILD_SYSTEM_GMAKE=yes ;;
            cmake-ninja) PACKAGE_BUILD_SYSTEM_CMAKE=yes     ; PACKAGE_BUILD_SYSTEM_NINJA=yes ;;
            cmake)       PACKAGE_BUILD_SYSTEM_CMAKE=yes     ; PACKAGE_BUILD_SYSTEM_NINJA=yes ;;
            xmake)       PACKAGE_BUILD_SYSTEM_XMAKE=yes     ;;
            meson)       PACKAGE_BUILD_SYSTEM_MESON=yes     ; PACKAGE_BUILD_SYSTEM_NINJA=yes ;;
            ninja)       PACKAGE_BUILD_SYSTEM_NINJA=yes     ;;
            gmake)       PACKAGE_BUILD_SYSTEM_GMAKE=yes     ;;
            rake)        PACKAGE_BUILD_SYSTEM_RAKE=yes      ;;
            cargo)       PACKAGE_BUILD_SYSTEM_CARGO=yes     ;;
            go)          PACKAGE_BUILD_SYSTEM_GO=yes        ;;
        esac
    done

    for item in $PACKAGE_BUILD_SYSTEM
    do
        case $item in
            autogen)     PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD perl m4 autoconf automake make" ;;
            autotools)   PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD perl m4 autoconf automake make" ;;
            configure)   PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD make" ;;
            ndk-build)   PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD make" ;;
            cmake-gmake) PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD cmake>=3.19.0 make"  ;;
            cmake-ninja) PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD cmake>=3.19.0 ninja" ;;
            cmake)       PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD cmake>=3.19.0 ninja" ;;
            xmake)       PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD xmake" ;;
            meson)       PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD meson ninja" ;;
            ninja)       PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD ninja" ;;
            gmake)       PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD make"  ;;
            rake)        PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD ruby gem rake" ;;
            cargo)       PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD rustup rustc cargo" ;;
            go)          PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD go>=1.18" ;;
        esac
    done

    if [ "$PACKAGE_BUILD_IN_PARALLEL" = no ] ; then
        BUILD_NJOBS=1
    fi

    if [ "$PACKAGE_BUILD_SYSTEM_GO" = yes ] ; then
        PACKAGE_BINBSTD=yes
        PACKAGE_BUILD_IN_BSCRIPT_DIR=yes
    fi

    if [ "$PACKAGE_BUILD_SYSTEM_CARGO" = yes ] ; then
        PACKAGE_BINBSTD=yes
        PACKAGE_BUILD_IN_BSCRIPT_DIR=yes
    fi

    if [ "$PACKAGE_BUILD_SYSTEM_XMAKE" = yes ] ; then
        PACKAGE_BINBSTD=yes
        PACKAGE_BUILD_IN_BSCRIPT_DIR=yes
    fi

    if [ "$NATIVE_OS_KIND" = 'darwin' ] ; then
        PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD gsed"
    fi

    # I don't known why
    # If bash is not installed, ccache and make can not work correctly on VoidLinux.
    if [ "$NATIVE_OS_TYPE" = 'void' ] ; then
        PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD bash"
    fi

    for item in $PACKAGE_INSTALL
    do
        case $item in
            exe) PACKAGE_INSTALL_EXE=yes ;;
            pie) PACKAGE_INSTALL_PIE=yes ;;
            dev) PACKAGE_INSTALL_DEV=yes ;;
            lib) PACKAGE_INSTALL_LIB=yes ;;
        esac
    done

    PACKAGE_FORMULA_LOADED=yes
}

# examples:
# __view_formula_of_the_given_package curl
# __view_formula_of_the_given_package curl --paging=never
  __view_formula_of_the_given_package() {
    [ -z "$1" ] && {
        error "__view_formula_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is not given."
        return 1
    }

    unset PACKAGE_FORMULA_FILEPATH
    PACKAGE_FORMULA_FILEPATH="$(__path_of_formula_of_the_given_package $1)" || return 1

    shift

    unset VIEW_FORMULA_PAGING

    while [ -n "$1" ]
    do
        case $1 in
            --paging=*)
                VIEW_FORMULA_PAGING=$(getvalue "$1")
                case $VIEW_FORMULA_PAGING in
                    auto|always|never) ;;
                    *) die "--paging=<VALUE>, <VALUE> must be one of auto, always, never"
                esac
                ;;
            *)  die "unrecognized argument: $1"
        esac
        shift
    done

    case $VIEW_FORMULA_PAGING in
        ''|auto)
            if command -v bat > /dev/null ; then
                bat --paging=auto "$PACKAGE_FORMULA_FILEPATH"
            else
                cat "$PACKAGE_FORMULA_FILEPATH"
                echo
                prompt_user_to_install_bat
            fi
            ;;
        always)
            if command -v bat > /dev/null ; then
                bat --paging=always "$PACKAGE_FORMULA_FILEPATH"
            else
                more "$PACKAGE_FORMULA_FILEPATH"
                echo
                prompt_user_to_install_bat
            fi
            ;;
        never)
            if command -v bat > /dev/null ; then
                bat --paging=never "$PACKAGE_FORMULA_FILEPATH"
            else
                cat "$PACKAGE_FORMULA_FILEPATH"
                echo
                prompt_user_to_install_bat
            fi
            ;;
    esac
}

# __edit_formula_of_the_given_package <PACKAGE-NAME>
  __edit_formula_of_the_given_package() {
    [ -z "$1" ] && {
        error "__edit_formula_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is not given."
        return 1
    }

    unset PACKAGE_FORMULA_FILEPATH
    PACKAGE_FORMULA_FILEPATH="$(__path_of_formula_of_the_given_package $1)" || return 1

    [ -z "$2" ] || warn "edit action accept only one argument."

    if [ -z "$EDITOR" ] ; then
        EDITOR=$(command -v nvim || command -v vim || command -v vi || command -v open) || die "please set EDITOR environment variable."
    fi

    "$EDITOR" "$PACKAGE_FORMULA_FILEPATH"
}

# __create_formula_of_the_given_package <PACKAGE-NAME>
  __create_formula_of_the_given_package() {
    [ -z "$1" ] && {
        error "__create_formula_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is not given."
        return 1
    }

    unset REPO_NAME
    REPO_NAME=offical

    if [ -e "$MY_FORMULA_REPO_DIR/$REPO_NAME/formula/$1.sh" ] ; then
        die "$MY_FORMULA_REPO_DIR/$REPO_NAME/formula/$1.sh formula already exists."
    fi

    cat > "$MY_FORMULA_REPO_DIR/$REPO_NAME/formula/$1.sh" <<EOF
pkg_set summary "Summary of this package"

pkg_set webpage "https://www.xx.com"

# the source code download url of this package. the value of src.url must end with one of .git .zip .tar.xz .tar.gz .tar.lz .tar.bz2 .tgz .txz
pkg_set src.url "https://www.xx.com/pkgname-x.y.z.tar.gz"

# the sha256sum of source code. If the value of src.url end with .git, this function is optional, otherwise, this function must be invoked.
pkg_set src.sha "c3e5e9fdd5004dcb542feda5ee4f0ff0744628baf8ed2dd5d66f8ca1197cb1a1"

# the version of this package. If this function is not invoked, it will be calculated from src.url.
#pkg_set version "x.y.z"

# the license of this package.
#pkg_set license "MIT"

# the required commands of this package when installing. If specify multiple values, separate them with spaces.
#pkg_set dep.cmd "a b c"

# the packages are depended by this package. If specify multiple values, separate them with spaces.
#pkg_set dep.pkg "a b c"

prepare() {
    :
    #this function is optional, you can delete it, if don't use it.
}

build() {
    :
    #configure
    #cargow
    #mesonw
    #cmakew
    #gmakew
}
EOF
    __edit_formula_of_the_given_package "$1"
}

# __delete_formula_of_the_given_package <PACKAGE-NAME>
  __delete_formula_of_the_given_package() {
    [ -z "$1" ] && {
        error "__delete_formula_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is not given."
        return 1
    }

    unset PACKAGE_FORMULA_FILEPATH
    PACKAGE_FORMULA_FILEPATH="$(__path_of_formula_of_the_given_package $1)" || return 1

    run rm "$PACKAGE_FORMULA_FILEPATH"
}

# __rename_formula_of_the_given_package <OLD-PACKAGE-NAME> <NEW-PACKAGE-NAME>
__rename_formula_of_the_given_package() {
    [ -z "$1" ] && {
        error "__rename_formula_of_the_given_package <OLD-PACKAGE-NAME> <NEW-PACKAGE-NAME>, <OLD-PACKAGE-NAME> is not given."
        return 1
    }

    [ -z "$2" ] && {
        error "__rename_formula_of_the_given_package <OLD-PACKAGE-NAME> <NEW-PACKAGE-NAME>, <NEW-PACKAGE-NAME> is not given."
        return 1
    }

    unset PACKAGE_FORMULA_REPO
    PACKAGE_FORMULA_REPO="$(__repo_of_formula_of_the_given_package $1)" || return 1

    unset PACKAGE_FORMULA_FILEPATH_OLD
    unset PACKAGE_FORMULA_FILEPATH_NEW

    PACKAGE_FORMULA_FILEPATH_OLD="$MY_FORMULA_REPO_DIR/$PACKAGE_FORMULA_REPO/formula/$1.sh"
    PACKAGE_FORMULA_FILEPATH_NEW="$MY_FORMULA_REPO_DIR/$PACKAGE_FORMULA_REPO/formula/$2.sh"

    if [ -f "$PACKAGE_FORMULA_FILEPATH_NEW" ] ; then
        die "$2 package is already exist."
    fi

    if mv "$PACKAGE_FORMULA_FILEPATH_OLD" "$PACKAGE_FORMULA_FILEPATH_NEW" ; then
        success "rename formula $1 -> $2 success."
    else
        die "rename formula $1 -> $2 failed."
    fi
}

__list_formulas() {
    for repo in $(cut -d= -f1 "$MY_HOME_DIR/repos")
    do
        if [ -d  "$MY_FORMULA_REPO_DIR/$repo/formula" ] ; then
            ls "$MY_FORMULA_REPO_DIR/$repo/formula"/*.sh
        fi
    done
}

# __add_a_formula_repo <REPO-NAME> <REPO-URL>
__add_a_formula_repo() {
    if [ -z "$1" ] ; then
        die "please specify a repo name."
    fi

    if [ -z "$2" ] ; then
        die "please specify a repo url."
    fi

    case $2 in
        *.git)
            case $2 in
                http://*|https://*|git@*) ;;
                *)  die "$2: not a valid git url."
            esac
            ;;
        *)  die "$2: repo url must end with .git"
    esac

    for repoName in $(__list_formula_repositories | cut -d= -f1)
    do
        if [ "$repoName" = "$1" ] ; then
            die "$1 formula repo already exists."
        fi
    done

    printf '%s=%s\n' "$1" "$2" >> "$MY_HOME_DIR/repos"
}

# __del_a_formula_repo <REPO-NAME>
  __del_a_formula_repo() {
    if [ -z "$1" ] ; then
        die "please specify a repo name."
    fi

    if [ "$1" = 'offical' ] ; then
        die "offical formula repo can not be deleted."
    fi

    unset REPO_EXISTS
    for repoName in $(__list_formula_repositories | cut -d= -f1)
    do
        if [ "$repoName" = "$1" ] ; then
            REPO_EXISTS=yes
        fi
    done

    if [ "$REPO_EXISTS" = yes ] ; then
        sed_in_place "/^$1=/d" "$MY_HOME_DIR/repos"
    else
        die "$1 formula repo not exists."
    fi
}

__repo_of_formula_of_the_given_package() {
    [ -z "$1" ] && {
        error "__repo_of_formula_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is not given."
        return 1
    }

    for repo in $(__list_formula_repositories | cut -d= -f1)
    do
        if [ -e "$MY_FORMULA_REPO_DIR/$repo/formula/$1.sh" ] ; then
            printf '%s\n' "$repo"
            return 0
        fi
    done

    error "package [$1] is not available."
    return 1
}

# __path_of_formula_of_the_given_package <PACKAGE-NAME>
  __path_of_formula_of_the_given_package() {
    [ -z "$1" ] && {
        error "__path_of_formula_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is not given."
        return 1
    }

    for repo in $(cut -d= -f1 "$MY_HOME_DIR/repos")
    do
        if [ -e           "$MY_FORMULA_REPO_DIR/$repo/formula/$1.sh" ] ; then
            printf '%s\n' "$MY_FORMULA_REPO_DIR/$repo/formula/$1.sh"
            return 0
        fi
    done

    error "package [$1] is not available."
    return 1
}

__list_formula_repositories() {
    if [ -e "$MY_HOME_DIR/repos" ] ; then
        cat "$MY_HOME_DIR/repos"
    else
        install -d "$MY_HOME_DIR"
        printf 'offical=%s\n' "$MY_OFFICAL_FORMULA_REPO_URL" | tee "$MY_HOME_DIR/repos"
    fi
}

__update_formula_repositories() {
    set -e

    handle_dependency required exe git

    for item in $(__list_formula_repositories)
    do
        unset FORMULA_REPO_NAME
        unset FORMULA_REPO_URL_

        FORMULA_REPO_NAME=$(printf '%s\n' "$item" | cut -d= -f1)
        FORMULA_REPO_URL_=$(printf '%s\n' "$item" | cut -d= -f2)

        printf '%b\n' "${COLOR_PURPLE}=== Updating formula repository${COLOR_OFF} ${COLOR_GREEN}$FORMULA_REPO_NAME${COLOR_OFF}"

        if [ -d     "$MY_FORMULA_REPO_DIR/$FORMULA_REPO_NAME" ] ; then
            run cd  "$MY_FORMULA_REPO_DIR/$FORMULA_REPO_NAME"
            run git pull origin master:master
            if [ "$(git branch | sed -n '/^*/p' | cut -d ' ' -f2)" != master ] ;  then
                run git checkout master
            fi
        else
            run install -d "$MY_FORMULA_REPO_DIR"
            run cd         "$MY_FORMULA_REPO_DIR"
            run git clone "$FORMULA_REPO_URL_" "$FORMULA_REPO_NAME"
        fi
    done
}

# }}}
##############################################################################

prompt_user_to_install_bat() {
    echo
    note "${COLOR_YELLOW}if you want to have a better experience, I strongly recommend you to install${COLOR_OFF} ${COLOR_GREEN}bat${COLOR_OFF} ${COLOR_YELLOW}on this machine. For more details, please visit website${COLOR_OFF} ${COLOR_GREEN}https://github.com/sharkdp/bat${COLOR_OFF}"
}

# fetch source code if needed
__fetch_sources_of_the_given_package() {
    case $PACKAGE_SRC_TYPE in
        git)
            if [ -d "$PACKAGE_SRC_PATH" ] ; then
                run cd  "$PACKAGE_SRC_PATH"
                if git rev-parse 2> /dev/null ; then
                    if [ -n "$PACKAGE_GIT_SHA" ] ; then
                        if [ "$PACKAGE_GIT_SHA" = "$(git rev-parse HEAD)" ] ; then
                            success "$PACKAGE_SRC_PATH already have been fetched."
                            return 0
                        fi
                        run git -c protocol.version=2 fetch --no-tags --prune --progress --depth=1 origin +$PACKAGE_GIT_SHA:refs/remotes/origin/master &&
                        run git checkout --progress --force -B master refs/remotes/origin/master
                    else
                        run git pull &&
                        run git submodule update --recursive
                    fi
                else
                    if [ -n "$PACKAGE_GIT_SHA" ] ; then
                        run rm -rf * &&
                        run git init &&
                        run git remote add origin "$PACKAGE_SRC_URL" &&
                        run git -c protocol.version=2 fetch --no-tags --prune --progress --depth=1 origin +$PACKAGE_GIT_SHA:refs/remotes/origin/master &&
                        run git checkout --progress --force -B master refs/remotes/origin/master
                    else
                        run cd .. &&
                        run rm -rf "$PACKAGE_SRC_NAME" &&
                        run git clone --recursive "$PACKAGE_SRC_URL" "$PACKAGE_SRC_NAME"
                    fi
                fi
            else
                if [ -n "$PACKAGE_GIT_SHA" ] ; then
                    run install -d "$PACKAGE_SRC_PATH" &&
                    run cd         "$PACKAGE_SRC_PATH" &&
                    run git init &&
                    run git remote add origin "$PACKAGE_SRC_URL" &&
                    run git -c protocol.version=2 fetch --no-tags --prune --progress --depth=1 origin +$PACKAGE_GIT_SHA:refs/remotes/origin/master &&
                    run git checkout --progress --force -B master refs/remotes/origin/master
                else
                    if [ !          -d "$MY_SOURCE_DIR" ] ; then
                        run install -d "$MY_SOURCE_DIR"
                    fi
                    run cd "$MY_SOURCE_DIR" &&
                    run git clone --recursive "$PACKAGE_SRC_URL" "$PACKAGE_SRC_NAME"
                fi
            fi
            ;;
        dir) note "$PACKAGE_SRC_URL is local path, no need to fetch." ;;
        *)  fetch "$PACKAGE_SRC_URL" --sha256="$PACKAGE_SRC_SHA" --output-path="$PACKAGE_SRC_PATH"
    esac
}

__fetch_patches_of_the_given_package() {
    if [ -n "$PACKAGE_FIX_URL" ] ; then
        fetch "$PACKAGE_FIX_URL" --sha256="$PACKAGE_FIX_SHA" --output-path="$PACKAGE_FIX_PATH"
    fi
}

__fetch_resources_of_the_given_package() {
    [ -z "$1" ] && {
        error "__fetch_resources_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is not given."
        return 1
    }

    case $1 in
        @all)
            shift
            unset STEP_NUM
            for PKG in $(__list_available_packages)
            do
                step "$PKG"
                 __load_formula_of_the_given_package "$PKG"
                __fetch_sources_of_the_given_package "$PKG" $@
                __fetch_patches_of_the_given_package "$PKG" $@
            done
            ;;
        *)
             __load_formula_of_the_given_package $1
            __fetch_sources_of_the_given_package $@
            __fetch_patches_of_the_given_package $@
    esac
}

# check if the given package is available
# if the version condition is given, check if the condition is matched
#
# condition operator:
# eq  equal
# ne  not equal
# gt  greater than
# lt  less than
# ge  greater than or equal
# le  less than or equal
#
# examples:
# is_package_available automake eq 1.16.0
# is_package_available automake lt 1.16.0
# is_package_available automake gt 1.16.0
# is_package_available automake le 1.16.0
# is_package_available automake ge 1.16.0
# is_package_available automake
  is_package_available() {
    [ -z "$1" ] && {
        error "is_package_available <PACKAGE-NAME> [<eq|lt|gt|le|ge> <VERSION>], <PACKAGE-NAME> is not given."
        return 1
    }

    case $# in
        1)  [ -n "$(__path_of_formula_of_the_given_package $1)" ] ;;
        3)  __load_formula_of_the_given_package "$1" || return 1
            shift
            version_match $PACKAGE_VERSION $@
            ;;
        *)  error "is available command only accept 1 or 3 argument." ; return 1
    esac
}

# is_package_installed <PACKAGE-NAME> <MIN-SDK-API-LEVEL>
  is_package_installed() {
    [ -z "$1" ] && {
        error "is_package_installed <PACKAGE-NAME> <MIN-SDK-API-LEVEL>, <PACKAGE-NAME> is not given."
        return 1
    }

    [ -z "$2" ] && {
        error "is_package_installed <PACKAGE-NAME> <MIN-SDK-API-LEVEL>, <MIN-SDK-API-LEVEL> is not given."
        return 1
    }

    is_integer "$2" || {
        error "is_package_installed <PACKAGE-NAME> <MIN-SDK-API-LEVEL>, <MIN-SDK-API-LEVEL> must be a integer."
        return 1
    }

    [ -d "$MY_INSTALL_DIR/android/$2/$1" ]                    || return 10
    [ -f "$MY_INSTALL_DIR/android/$2/$1/installed-metadata" ] || return 11
    [ -f "$MY_INSTALL_DIR/android/$2/$1/installed-files" ]    || return 12
    [ -f "$MY_INSTALL_DIR/android/$2/$1/installed-abis" ]     || return 13
}

# is_package__outdated <PACKAGE-NAME> <MIN-SDK-API-LEVEL>
  is_package__outdated() {
    __load_installed_metadata_of_the_given_package "$1" "$2" &&
    __load_formula_of_the_given_package "$1" &&
    version_match "$PACKAGE_VERSION" gt "$INSTALLED_PACKAGE_VERSION"
}

__gen_github_workflows() {
    set -e

    unset BREAK
    unset NDEPENDED_PACKAGES
    unset AVAILABLE_PACKAGES
    unset GROUP_SIZE
    unset OUTPUT_DIR
    unset I

    while [ -n "$1" ]
    do
        case $1 in
            --group-size=*)
                GROUP_SIZE=$(getvalue "$1")
                is_integer "$GROUP_SIZE" || die "--group-size=INTEGER"
                ;;
            --output-dir=*)
                OUTPUT_DIR=$(getvalue "$1")
                case "$OUTPUT_DIR" in
                    '') die "--output-dir=<DIR>, <DIR> must not be empty." ;;
                    /*) ;;
                    \~|\~/) OUTPUT_DIR="${HOME}" ;;
                    \~/*)   OUTPUT_DIR="${HOME}$(printf "$OUTPUT_DIR" | cut -c2-)" ;;
                    .|./)   OUTPUT_DIR="${PWD}" ;;
                    *)      OUTPUT_DIR="${PWD}/$OUTPUT_DIR" ;;
                esac
                [ -d "$OUTPUT_DIR" ] || run install -d "$OUTPUT_DIR"
        esac
        shift
    done

    if [ -z "$GROUP_SIZE" ] ; then
        die "please sepecify --group-size=INTEGER argument."
    fi

    if [ -z "$OUTPUT_DIR" ] ; then
        OUTPUT_DIR="$MY_HOME_DIR/repos.d/offical/.github/workflows"
    fi

    GITHUB_ACTIONS_WORKFLOW_TEMPLATE_FILEPATH="$MY_HOME_DIR/repos.d/offical/.github/workflows/template"

    if [ ! -f "$GITHUB_ACTIONS_WORKFLOW_TEMPLATE_FILEPATH" ] ; then
        __update_formula_repositories
    fi

    AVAILABLE_PACKAGES=$(__list_available_packages)

    for item in test v8 webrtc skia pdfium
    do
        AVAILABLE_PACKAGES=$(printf '%s\n' "$AVAILABLE_PACKAGES" | sed "s|^$item$||")
    done

    for x in $AVAILABLE_PACKAGES
    do
        for y in $AVAILABLE_PACKAGES
        do
            if [ "$x" = "$y" ] ; then
                continue
            else
                for z in $(__get_packages_that_are_directly_depended_by_the_given_package "$y")
                do
                    if [ "$x" = "$z" ] ; then
                        BREAK=yes
                        break 2
                    fi
                done
            fi
        done
        if [ "$BREAK" = yes ] ; then
            unset BREAK
        else
            if [ -z "$NDEPENDED_PACKAGES" ] ; then
                NDEPENDED_PACKAGES="$x"
            else
                NDEPENDED_PACKAGES="$NDEPENDED_PACKAGES $x"
            fi
            if [ "$(list_length $NDEPENDED_PACKAGES)" -eq "$GROUP_SIZE" ] ; then
                unset OUTPUT_FILEPATH

                I=$(expr ${I-0} + 1)
                OUTPUT_FILEPATH="$OUTPUT_DIR/ci$I.yml"
                NDEPENDED_PACKAGES=$(printf '%s\n' "$NDEPENDED_PACKAGES" | tr ' ' ,)

                echo
                run cp "$GITHUB_ACTIONS_WORKFLOW_TEMPLATE_FILEPATH" "$OUTPUT_FILEPATH"
                sed_in_place "s/INDEX/$I/"                     "$OUTPUT_FILEPATH"
                sed_in_place "s/PKGLIST/$NDEPENDED_PACKAGES/"  "$OUTPUT_FILEPATH"

                unset NDEPENDED_PACKAGES
            fi
        fi
    done
    if [ -n "$NDEPENDED_PACKAGES" ] ; then
        unset OUTPUT_FILEPATH

        I=$(expr ${I-0} + 1)
        OUTPUT_FILEPATH="$OUTPUT_DIR/ci$I.yml"
        NDEPENDED_PACKAGES=$(printf '%s\n' "$NDEPENDED_PACKAGES" | tr ' ' ,)

        run cp "$GITHUB_ACTIONS_WORKFLOW_TEMPLATE_FILEPATH" "$OUTPUT_FILEPATH"
        sed_in_place "s/INDEX/$I/"                     "$OUTPUT_FILEPATH"
        sed_in_place "s/PKGLIST/$NDEPENDED_PACKAGES/"  "$OUTPUT_FILEPATH"
    fi
}

__list_available_packages() {
    for FORMULA_REPO_NAME in $(__list_formula_repositories | cut -d= -f1)
    do
        cd "$MY_FORMULA_REPO_DIR/$FORMULA_REPO_NAME/formula" || return 1
        ls -1 *.sh | sed 's/\.sh$//g' || return 1
    done
}

# __list_installed_packages [--min-sdk-api-level=<VALUE>]
  __list_installed_packages() {
    unset MIN_SDK_API_LEVEL

    while [ -n "$1" ]
    do
        case "$1" in
            --min-sdk-api-level=*)
                MIN_SDK_API_LEVEL=$(getvalue "$1")
                is_integer "$MIN_SDK_API_LEVEL" || die "--min-sdk-api-level=<VALUE>, <VALUE> must be a integer."
                ;;
            -x|--xtrace)
                ;;
            *)  die "__list_installed_packages [--min-sdk-api-level=<MIN-SDK-API-LEVEL>], unrecognized option: $1"
        esac
        shift
    done

    if [ -z "$MIN_SDK_API_LEVEL" ] ; then
        if [ -d "$MY_INSTALL_DIR/android" ] ; then
             cd "$MY_INSTALL_DIR/android" >/dev/null
        else
            return 0
        fi

        for item in $(ls)
        do
            case $item in
                [1-9][0-9])
                    cd "$MY_INSTALL_DIR/android/$item" >/dev/null
                    for fileName in $(ls)
                    do
                        is_package_installed "$fileName" "$item" || continue
                        printf 'android/%s/%s\n' "$item" "$fileName"
                    done
            esac
        done
    else
        if [ -d "$MY_INSTALL_DIR/android/$MIN_SDK_API_LEVEL" ] ; then
             cd "$MY_INSTALL_DIR/android/$MIN_SDK_API_LEVEL" >/dev/null
        else
            return 0
        fi

        for fileName in $(ls)
        do
            is_package_installed "$fileName" "$MIN_SDK_API_LEVEL" || continue
            printf 'android/%s/%s\n' "$MIN_SDK_API_LEVEL" "$fileName"
        done
    fi
}

# __list__outdated_packages [--min-sdk-api-level=<VALUE>]
  __list__outdated_packages() {
    unset MIN_SDK_API_LEVEL

    while [ -n "$1" ]
    do
        case "$1" in
            --min-sdk-api-level=*)
                MIN_SDK_API_LEVEL=$(getvalue "$1")
                is_integer "$MIN_SDK_API_LEVEL" || die "--min-sdk-api-level=<VALUE>, <VALUE> must be a integer."
                ;;
            -x|--xtrace)
                ;;
            *)  die "__list__outdated_packages [--min-sdk-api-level=<MIN-SDK-API-LEVEL>], unrecognized option: $1"
        esac
        shift
    done

    if [ -z "$MIN_SDK_API_LEVEL" ] ; then
        if [ -d "$MY_INSTALL_DIR/android" ] ; then
             cd "$MY_INSTALL_DIR/android" >/dev/null
        else
            return 0
        fi

        for item in $(ls)
        do
            case $item in
                [1-9][0-9])
                    cd "$MY_INSTALL_DIR/android/$item" >/dev/null
                    for fileName in $(ls)
                    do
                        is_package_available "$fileName"         || continue
                        is_package_installed "$fileName" "$item" || continue
                        is_package__outdated "$fileName" "$item" || continue
                        printf 'android/%s/%s\n' "$item" "$fileName"
                    done
            esac
        done
    else
        if [ -d "$MY_INSTALL_DIR/android/$MIN_SDK_API_LEVEL" ] ; then
             cd "$MY_INSTALL_DIR/android/$MIN_SDK_API_LEVEL" >/dev/null
        else
            return 0
        fi

        for fileName in $(ls)
        do
            is_package_available "$fileName"                      || continue
            is_package_installed "$fileName" "$MIN_SDK_API_LEVEL" || continue
            is_package__outdated "$fileName" "$MIN_SDK_API_LEVEL" || continue
            printf 'android/%s/%s\n' "$item" "$fileName"
        done
    fi
}

# __tree_the_given_installed_package <PACKAGE-NAME> <MIN-SDK-API-LEVEL> [TREE-OPTIONS]
  __tree_the_given_installed_package() {
    [ -z "$1" ] && {
        error "__tree_the_given_installed_package <PACKAGE-NAME> <MIN-SDK-API-LEVEL> [TREE-OPTIONS], <PACKAGE-NAME> is not given."
        return 1
    }

    [ -z "$2" ] && {
        error "__tree_the_given_installed_package <PACKAGE-NAME> <MIN-SDK-API-LEVEL> [TREE-OPTIONS], <MIN-SDK-API-LEVEL> is not given."
        return 1
    }

    is_package_installed "$1" "$2" || {
        error "package [$1] is not installed."
        return 1
    }

    handle_dependency required exe tree || return 1

    run tree $(shiftn 2 $@) "$MY_INSTALL_DIR/android/$2/$1"
}

# __uninstall_the_given_packages <PACKAGE-NAME>... [--min-sdk-api-level=<MIN-SDK-API-LEVEL>]
  __uninstall_the_given_packages() {
    unset USER_SPECIFIED_PACKAGES
    unset MIN_SDK_API_LEVEL

    while [ -n "$1" ]
    do
        case "$1" in
            --min-sdk-api-level=*)
                MIN_SDK_API_LEVEL=$(getvalue "$1")
                is_integer "$MIN_SDK_API_LEVEL" || die "--min-sdk-api-level=<VALUE>, <VALUE> must be a integer."
                ;;
            -x|--xtrace)
                ;;
            -*) die "__uninstall_the_given_packages <PACKAGE-NAME>... [--min-sdk-api-level=<MIN-SDK-API-LEVEL>], unrecognized option: $1"
                ;;
            *)  USER_SPECIFIED_PACKAGES="$USER_SPECIFIED_PACKAGES $1"
        esac
        shift
    done

    [ -z "$USER_SPECIFIED_PACKAGES" ] && {
        error "__uninstall_the_given_packages <PACKAGE-NAME>... [--min-sdk-api-level=<MIN-SDK-API-LEVEL>], <PACKAGE-NAME> is not given."
        return 1
    }

    [ -d "$MY_INSTALL_DIR/android" ] || return 0

    if [ -z "$MIN_SDK_API_LEVEL" ] ; then
        for item in $(ls "$MY_INSTALL_DIR/android")
        do
            case $item in
                [1-9][0-9])
                    for packageName in $USER_SPECIFIED_PACKAGES
                    do
                        if is_package_installed "$packageName" "$item" ; then
                            run rm -rf "$MY_INSTALL_DIR/android/$item/$packageName"
                        fi
                    done
            esac
        done
    else
        for packageName in $USER_SPECIFIED_PACKAGES
        do
            if is_package_installed "$packageName" "$MIN_SDK_API_LEVEL" ; then
                run rm -rf "$MY_INSTALL_DIR/android/$MIN_SDK_API_LEVEL/$packageName"
            fi
        done
    fi
}

# __reinstall_the_given_packages <PACKAGE-NAME>... [OPTIONS]
  __reinstall_the_given_packages() {
    inspect_install_arguments $@

    [ -z "$USER_SPECIFIED_PACKAGES" ] && {
        error "$_0 reinstall <PACKAGE-NAME>... [OPTIONS], <PACKAGE-NAME> is not given."
        return 1
    }

    for packageName in $USER_SPECIFIED_PACKAGES
    do
        is_package_available "$packageName" || {
            error "package [$packageName] is not available."
            return 1
        }

        is_package_installed "$packageName" "$MIN_SDK_API_LEVEL" || {
            error "package [$packageName] is not installed."
            return 1
        }
    done

    for INSTALLING_PACKAGE in $USER_SPECIFIED_PACKAGES
    do
        if [ !      -d "$MY_BACKUP_DIR" ] ; then
            install -d "$MY_BACKUP_DIR"
        fi

        if [        -d "$MY_BACKUP_DIR/$INSTALLING_PACKAGE" ] ; then
            rm -rf     "$MY_BACKUP_DIR/$INSTALLING_PACKAGE"
        fi

        mv "$MY_INSTALL_DIR/android/$MIN_SDK_API_LEVEL/$INSTALLING_PACKAGE" "$MY_BACKUP_DIR/$INSTALLING_PACKAGE"

        (__install_the_given_package "$INSTALLING_PACKAGE")

        rm -rf "$MY_BACKUP_DIR/$INSTALLING_PACKAGE"
    done
}

__upgrade_packages() {
    inspect_install_arguments $@

    if [ -z "$USER_SPECIFIED_PACKAGES" ] ; then
        if [ -z "$MIN_SDK_API_LEVEL" ] ; then
            USER_SPECIFIED_PACKAGES=$(__list__outdated_packages)
        else
            USER_SPECIFIED_PACKAGES=$(__list__outdated_packages --min-sdk-api-level=$MIN_SDK_API_LEVEL)
        fi
    fi

    for packageName in $USER_SPECIFIED_PACKAGES
    do
        is_package_available "$packageName" || {
            error "package [$packageName] is not available."
            return 1
        }

        is_package_installed "$packageName" "$MIN_SDK_API_LEVEL" || {
            error "package [$packageName] is not installed."
            return 1
        }
    done

    for INSTALLING_PACKAGE in $USER_SPECIFIED_PACKAGES
    do
        if [ !      -d "$MY_BACKUP_DIR" ] ; then
            install -d "$MY_BACKUP_DIR"
        fi

        mv "$MY_INSTALL_DIR/$INSTALLING_PACKAGE" "$MY_BACKUP_DIR/$INSTALLING_PACKAGE"

        (__install_the_given_package "$INSTALLING_PACKAGE")

        rm -rf "$MY_BACKUP_DIR/$INSTALLING_PACKAGE"
    done
}

__cleanup() {
    [ -d "$MY_SOURCE_DIR" ] || return 0

    for repo in $(__list_formula_repositories | cut -d= -f1)
    do
        cd "$MY_FORMULA_REPO_DIR/$repo/formula"
        for item in $(ls)
        do
            if [ -f "$item" ] ; then
                case $item in
                    *.sh) __load_formula_of_the_given_package ${item%.sh}
                esac
            fi
        done
    done

    success "Done."
}

__search_packages() {
    [ -z "$1" ] && {
        error "please specify a keyword."
        return 1
    }

    handle_dependency required exe grep 1>&2

    for repo in $(__list_formula_repositories | cut -d= -f1)
    do
        cd "$MY_FORMULA_REPO_DIR/$repo/formula" && ls -1 *.sh | sed 's/\.sh$//g' | grep "$*"
    done
}

__compare_versions_with_brew() {
    get_brew_package_name_from_my_package_name() {
        case $1 in
            file)     printf '%s\n' 'file-formula' ;;
            delta)    printf '%s\n' 'git-delta' ;;
            gmake)    printf '%s\n' 'make'      ;;
            gtar)     printf '%s\n' 'gnu-tar'   ;;
            libjxl)   printf '%s\n' 'jpeg-xl'   ;;
            blake3)   printf '%s\n' 'b3sum'     ;;
            libwebp)  printf '%s\n' 'webp'      ;;
            proj7)    printf '%s\n' 'proj@7'    ;;
            openssl)  printf '%s\n' 'openssl@1.1';;
            freetype2)printf '%s\n' 'freetype'  ;;
            freetype2-with-harfbuzz)
                      printf '%s\n' 'freetype'  ;;
            gnu-coreutils)
                      printf '%s\n' 'coreutils' ;;
            libmediainfo|mediainfo)
                      printf '%s\n' 'media-info';;
            tcl-core) printf '%s\n' 'tcl-tk'    ;;
            *)        printf '%s\n' "$1"
        esac
    }

    set -e

    cd "$MY_HOME_DIR/repos.d/offical/formula"

    for item in $(ls -1 *.sh | sed 's/\.sh//')
    do
        __load_formula_of_the_given_package "$item"
        BREW_PKG_NMAE="$(get_brew_package_name_from_my_package_name $PACKAGE_NAME)"
        if brew info "$BREW_PKG_NMAE" > /dev/null 2>&1 ; then
            BREW_PKG_VERS=$(__pmw_get_available_package_version_by_package_name brew "$BREW_PKG_NMAE")
            if version_match "$BREW_PKG_VERS" gt "$PACKAGE_VERSION" ; then
                printf "${COLOR_RED}%-10s %-10s  |  %-10s %-10s${COLOR_OFF}\n" "$PACKAGE_NAME" "$PACKAGE_VERSION" "$BREW_PKG_NMAE" "$BREW_PKG_VERS"
            else
                :
                #printf "${COLOR_GREEN}%-10s %-10s  |  %-10s %-10s${COLOR_OFF}\n" "$PACKAGE_NAME" "$PACKAGE_VERSION" "$BREW_PKG_NMAE" "$BREW_PKG_VERS"
            fi
        else
            printf "${COLOR_BLUE}%-10s %-10s  |${COLOR_OFF}\n" "$PACKAGE_NAME" "$PACKAGE_VERSION"
        fi
    done
}

# https://repo1.maven.org/maven2/com/fpliu/ndk/pkg/prefab/android/21/
__compare_versions_with_maven_central() {
    WORKING_DIR=$(mktemp -d)

    cd "$WORKING_DIR"

    fetch 'https://repo1.maven.org/maven2/com/fpliu/ndk/pkg/prefab/android/21' --output-name=artifacts.html --silent

    for artifactId in $(sed -n '/<a href=.* title=/p' artifacts.html | sed 's|<a href="\(.*\)/" .*|\1|')
    do
        rm -f maven-metadata.xml

        fetch "https://repo1.maven.org/maven2/com/fpliu/ndk/pkg/prefab/android/21/${artifactId}/maven-metadata.xml" --output-name=maven-metadata.xml --silent

        LATEST_VERSION_IN_MAVEN_CENTRAL=$(sed -n '/latest/p' maven-metadata.xml | sed -e 's|[[:space:]]||g' -e 's|<latest>\(.*\)</latest>|\1|')
        AVAILABLE_VERSION_IN_FORMULA_REPO=$(__show_infomation_of_the_given_package "$artifactId" version)

        if version_match "$AVAILABLE_VERSION_IN_FORMULA_REPO" gt "$LATEST_VERSION_IN_MAVEN_CENTRAL" ; then
            printf "${COLOR_RED}%-15s %-10s %-10s${COLOR_OFF}\n" "$artifactId" "$AVAILABLE_VERSION_IN_FORMULA_REPO" "$LATEST_VERSION_IN_MAVEN_CENTRAL"
        else
            :
        fi
    done

    rm -rf "$WORKING_DIR"
}

__show_or_open_homepage_of_the_given_package() {
    unset ACTION
    unset PACKAGE

    while [ -n "$1" ]
    do
        case $1 in
            --open)
                ACTION=open
                ;;
            -*|--*)
                die "unrecognized argument: $1"
                ;;
            *)  if [ -z "$PACKAGE" ] ; then
                    PACKAGE=$1
                else
                    die "too many packages given."
                fi
        esac
        shift
    done

    if [ "$ACTION" = open ] ; then
        __open_homepage_of_the_given_package $PACKAGE
    else
        __show_homepage_of_the_given_package $PACKAGE
    fi
}

__show_homepage_of_the_given_package() {
    if [ -z "$1" ] ; then
        PACKAGE_WEBPAGE="$MY_HOME_PAGE"
    else
        __load_formula_of_the_given_package "$1"
    fi

    printf '%s\n' "$PACKAGE_WEBPAGE"
}

__open_homepage_of_the_given_package() {
    if [ -z "$1" ] ; then
        PACKAGE_WEBPAGE="$MY_HOME_PAGE"
    else
        __load_formula_of_the_given_package "$1"
    fi
    
    if command -v open > /dev/null ; then
        run "open '$PACKAGE_WEBPAGE'"
    elif command -v termux-open-url > /dev/null ; then
        run "termux-open-url '$PACKAGE_WEBPAGE'"
    else
        warn "I don't konw how to open"
    fi
}

# __show_packages_depended_by_the_given_package <PACKAGE-NAME> [--format=<list|json|graph>] [--brief] [-o <OUTPUT-FILE-PATH>]
__show_packages_depended_by_the_given_package() {
    [ -z "$1" ] && {
        error "__show_packages_depended_by_the_given_package <PACKAGE-NAME> [--format=<list|json|graph>] [--brief] [-o <OUTPUT-FILE-PATH>], <PACKAGE-NAME> is not given."
        return 1
    }

    PACKAGE_NAME="$1"

    shift

    unset OUTPUT_FILEPATH
    unset OUTPUT_FORMAT
    unset OUTPUT_BRIEF
    unset RECURSIVE

    while [ -n "$1" ]
    do
        case $1 in
            --format=list)
                OUTPUT_FORMAT=list
                ;;
            --format=json)
                OUTPUT_FORMAT=json
                ;;
            --format=dot)
                OUTPUT_FORMAT=dot
                ;;
            --format=txt)
                OUTPUT_FORMAT=txt
                ;;
            --format=png)
                OUTPUT_FORMAT=png
                ;;
            --format=*)
                OUTPUT_FORMAT=$(getvalue $1)
                die "unsupported format: $OUTPUT_FORMAT"
                ;;
            --brief)
                OUTPUT_BRIEF=yes
                ;;
            -r) RECURSIVE=yes ;;
            -x) set -x ;;
            -o)
                if [ -z "$2" ] ; then
                    die "-o <OUTPUT-FILE-PATH>, <OUTPUT-FILE-PATH> must not be empty."
                else
                    OUTPUT_FILEPATH="$2"
                    shift
                fi
                ;;
            *)  die "$_0 depends <PACKAGE-NAME> [--format=<list|json|graph>] [--brief] [-o <OUTPUT-FILE-PATH>], unrecognized argumet: $1"
        esac
        shift
    done

    if [ -z "$OUTPUT_FORMAT" ] ; then
        OUTPUT_FORMAT=list
    fi

    if [ -z "$OUTPUT_FILEPATH" ] ; then
        if [ "$OUTPUT_FORMAT" = 'png' ] ; then
            die "you want png file, but -o <OUTPUT-FILE-PATH> option is not given."
        fi

        OUTPUT_FILEPATH=/dev/tty
    else
        if [ "$OUTPUT_FORMAT" = 'png' ] && [ "$OUTPUT_FILEPATH" = '/dev/tty' ] ; then
            die "you want png file, /dev/tty is not allowed."
        fi
    fi

    case $OUTPUT_FORMAT in
        list)
            unset RECURSIVE_DEPENDENT_PACKAGES
            RECURSIVE_DEPENDENT_PACKAGES=$(__get_packages_that_are_recursively_depended_by_the_given_package "$PACKAGE_NAME")

            if [ -z "$RECURSIVE_DEPENDENT_PACKAGES" ] ; then
                return 0
            fi

            unset OUTPUT_CONTENT

            if [ "$OUTPUT_BRIEF" = yes ] ; then
                OUTPUT_CONTENT="$RECURSIVE_DEPENDENT_PACKAGES"
            else
                for DEPENDENCY_PACKAGE_NAME in $RECURSIVE_DEPENDENT_PACKAGES
                do
                    unset DEPENDENCY_PACKAGE_DIRECT_DEPS
                    DEPENDENCY_PACKAGE_DIRECT_DEPS=$(__get_packages_that_are_directly_depended_by_the_given_package "$DEPENDENCY_PACKAGE_NAME")
                    DEPENDENCY_PACKAGE_DIRECT_DEPS=$(printf '%s\n' "$DEPENDENCY_PACKAGE_DIRECT_DEPS" | tr ' ' ',')

                    unset LINE
                    LINE=$(printf 'name:%-15s dependencies:%s\n' "$DEPENDENCY_PACKAGE_NAME" "$DEPENDENCY_PACKAGE_DIRECT_DEPS")
                    if [ -z "$OUTPUT_CONTENT" ] ; then
                        OUTPUT_CONTENT="$LINE"
                    else
                        OUTPUT_CONTENT="$OUTPUT_CONTENT
$LINE"
                    fi
                done
            fi

            if [ "$OUTPUT_FILEPATH" = '/dev/tty' ] ; then
                printf '%s\n' "$OUTPUT_CONTENT"
            else
                unset OUTPUT_DIR

                case $3 in
                    /*) OUTPUT_DIR="$(dirname      "$3")" ;;
                     *) OUTPUT_DIR="$(dirname "$PWD/$3")" ;;
                esac

                if [ !      -d "$OUTPUT_DIR" ] ; then
                    install -d "$OUTPUT_DIR"
                fi

                printf '%s\n' "$OUTPUT_CONTENT" > "$OUTPUT_FILEPATH"
            fi
            ;;
        json)
            unset RECURSIVE_DEPENDENT_PACKAGES
            RECURSIVE_DEPENDENT_PACKAGES=$(__get_packages_that_are_recursively_depended_by_the_given_package "$PACKAGE_NAME")

            JSON_ARRAY='['

            if [ "$OUTPUT_BRIEF" = yes ] ; then
                for DEPENDENCY_PACKAGE_NAME in $RECURSIVE_DEPENDENT_PACKAGES
                do
                    JSON_ARRAY="$JSON_ARRAY\"$DEPENDENCY_PACKAGE_NAME\","
                done
            else
                for DEPENDENCY_PACKAGE_NAME in $RECURSIVE_DEPENDENT_PACKAGES
                do
                    unset DEPENDENCY_PACKAGE_DIRECT_DEPS
                    DEPENDENCY_PACKAGE_DIRECT_DEPS=$(__get_packages_that_are_directly_depended_by_the_given_package "$DEPENDENCY_PACKAGE_NAME" | tr ' ' ',')

                    JSON_ARRAY="$JSON_ARRAY{\"name\":\"$DEPENDENCY_PACKAGE_NAME\",\"dependencies\":\"$DEPENDENCY_PACKAGE_DIRECT_DEPS\"},"
                done
            fi

            JSON_ARRAY=$(printf '%s\n' "$JSON_ARRAY" | sed 's|,$||')

            JSON_ARRAY="$JSON_ARRAY]"

            if [ "$OUTPUT_FILEPATH" = '/dev/tty' ] ; then
                printf '%s\n' "$JSON_ARRAY"
            else
                unset OUTPUT_DIR

                case $3 in
                    /*) OUTPUT_DIR="$(dirname      "$3")" ;;
                     *) OUTPUT_DIR="$(dirname "$PWD/$3")" ;;
                esac

                if [ !      -d "$OUTPUT_DIR" ] ; then
                    install -d "$OUTPUT_DIR"
                fi

                printf '%s\n' "$JSON_ARRAY" > "$OUTPUT_FILEPATH"
            fi
            ;;
        dot)
            __gen_dependency_graph_recursively_depended_by_the_given_package "$PACKAGE_NAME" dot "$OUTPUT_FILEPATH"
            ;;
        txt)
            __gen_dependency_graph_recursively_depended_by_the_given_package "$PACKAGE_NAME" txt "$OUTPUT_FILEPATH"
            ;;
        png)
            __gen_dependency_graph_recursively_depended_by_the_given_package "$PACKAGE_NAME" png "$OUTPUT_FILEPATH"

            if [ "$OUTPUT_FILEPATH" != '/dev/tty' ] ; then
                for item in open feh eog lsix
                do
                    if command -v "$item" > /dev/null ; then
                        "$item" "$OUTPUT_FILEPATH" &
                        return 0
                    fi
                done
            fi
    esac
}

# __logs_the_given_installed_package <PACKAGE-NAME> <MIN-SDK-API-LEVEL> <ABI>
  __logs_the_given_installed_package() {
    [ -z "$1" ] && {
        error "$_0 logs <PACKAGE-NAME> <MIN-SDK-API-LEVEL> <ABI>, <PACKAGE-NAME> is not given."
        return 1
    }

    [ -z "$2" ] && {
        error "$_0 logs <PACKAGE-NAME> <MIN-SDK-API-LEVEL> <ABI>, <MIN-SDK-API-LEVEL> is not given."
        return 1
    }

    is_package_installed "$1" "$2" || {
        error "package [$1] is not installed."
        return 1
    }

    [ -z "$3" ] && {
        error "$_0 logs <PACKAGE-NAME> <MIN-SDK-API-LEVEL> <ABI>, <ABI> is not given."
        return 1
    }

    PACKAGE_INSTALLED_DIR="$MY_INSTALL_DIR/android/$2/$1"

    for ABI in $(cat "$PACKAGE_INSTALLED_DIR/installed-abis")
    do
        if [ "$ABI" = "$3" ] ; then
            break
        else
            unset ABI
        fi
    done

    [ -z "$ABI" ] && {
        error "$_0 logs <PACKAGE-NAME> <MIN-SDK-API-LEVEL> <ABI>, unsupported ABI: $2"
        return 1
    }

    if command -v bat > /dev/null ; then
        VIEWER=bat
    else
        VIEWER=less
    fi

    __logs_the_given_dir() {
        [ -d "$1" ] || return 0
        for item in $(ls "$1")
        do
            item="$1/$item"
            if [ -d "$item" ] ; then
                continue
            fi
            if [ "$VIEWER" = 'bat' ] ; then
                case $item in
                    *.png) ;;
                    *.sh|*/installed-metadata)
                        bat -l bash "$item" ;;
                    *)  bat "$item"
                esac
            else
                "$VIEWER" "$item"
            fi
        done
    }

    __logs_the_given_dir "$PACKAGE_INSTALLED_DIR"
    __logs_the_given_dir "$PACKAGE_INSTALLED_DIR/$3/share/log"

    if [ "$VIEWER" != 'bat' ] ; then
        prompt_user_to_install_bat
    fi
}

# __pack_the_given_installed_package <PACKAGE-NAME> <MIN-SDK-API-LEVEL> <TYPE> [--keep-packing-dir]
# __pack_the_given_installed_package    autoconf             21         tar.xz
  __pack_the_given_installed_package() {
    [ -z "$1" ] && {
        error "__pack_the_given_installed_package <PACKAGE-NAME> <MIN-SDK-API-LEVEL> <TYPE>, <PACKAGE-NAME> is not given."
        return 1
    }

    [ -z "$2" ] && {
        error "__pack_the_given_installed_package <PACKAGE-NAME> <MIN-SDK-API-LEVEL> <TYPE>, <MIN-SDK-API-LEVEL> is not given."
        return 1
    }

    is_integer "$2" || {
        error "__pack_the_given_installed_package <PACKAGE-NAME> <MIN-SDK-API-LEVEL> <TYPE>, <MIN-SDK-API-LEVEL> must be a integer."
        return 1
    }

    [ -z "$3" ] && {
        error "__pack_the_given_installed_package <PACKAGE-NAME> <MIN-SDK-API-LEVEL> <TYPE>, <TYPE> is not given, supported TYPEs are 7z zip aar tar.gz tar.xz tar.bz2"
        return 1
    }

    __load_installed_metadata_of_the_given_package "$1" "$2"

    for option in $(shiftn 3 $@)
    do
        case $option in
            --keep-packing-dir)
                KEEP_PACKING_DIR=yes
                ;;
            -x|--xtrace)
                ;;
            *)  die "$_0 pack <PACKAGE-NAME> <MIN-SDK-API-LEVEL> <TYPE> [--keep-work-dir], unrecognized option: $option"
        esac
    done

    case $3 in
        aar)
            __create_prefab_aar_for_the_given_installed_package $@
            return $?
            ;;
        7z) handle_dependency required exe 7za ;;
        zip)
            handle_dependency required exe zip
            handle_dependency required exe unzip
            ;;
        tar.gz)
            handle_dependency required exe tar
            handle_dependency required exe gzip
            ;;
        tar.xz)
            handle_dependency required exe tar
            handle_dependency required exe xz
            ;;
        tar.bz2)
            handle_dependency required exe tar
            handle_dependency required exe bzip2
            ;;
        '')die "$_0 pack <PACKAGE-NAME> <MIN-SDK-API-LEVEL> <TYPE>, <TYPE> must not be empty." ;;
        *) die "$_0 pack <PACKAGE-NAME> <MIN-SDK-API-LEVEL> <TYPE>, unsupported TYPE: $3, supported TYPEs are 7z zip aar tar.gz tar.xz tar.bz2"
    esac

    unset PACKED_DIR_NAME
    unset PACKED_FILE_NAME

    if [ -z "$INSTALLED_PACKAGE_VERSION" ] ; then
        PACKED_DIR_NAME="$INSTALLED_PACKAGE_NAME-$INSTALLED_TIMESTAMP_UNIX"
    else
        PACKED_DIR_NAME="$INSTALLED_PACKAGE_NAME-$INSTALLED_PACKAGE_VERSION"
    fi

    PACKED_FILE_NAME="$PACKED_DIR_NAME.$3"

    step "create the packing directory"
    printf '%b\n' "$COLOR_PURPLE==>$COLOR_OFF ${COLOR_GREEN}mktemp -d$COLOR_OFF"
    PACKING_DIR=$(mktemp -d)

    step "cd  to the packing directory"
    run cd $PACKING_DIR

    step "make link point to installed package root dir"
    run ln -s "$MY_INSTALL_DIR/android/$INSTALLED_PACKAGE_SDK_API/$INSTALLED_PACKAGE_NAME" "$PACKED_DIR_NAME"

    step "packing"
    case $3 in
        7z)  run 7za a -t7z -r "$PACKED_FILE_NAME" "$PACKED_DIR_NAME/*" ;;
        zip) run zip -9 -r     "$PACKED_FILE_NAME" "$PACKED_DIR_NAME"   ;;
        tar.gz)  run tar zvcf  "$PACKED_FILE_NAME" "$PACKED_DIR_NAME/*" ;;
        tar.xz)  run tar Jvcf  "$PACKED_FILE_NAME" "$PACKED_DIR_NAME/*" ;;
        tar.bz2) run tar jvcf  "$PACKED_FILE_NAME" "$PACKED_DIR_NAME/*" ;;
    esac

    step "check integrity of packed file"
    case $3 in
        7z)    run 7za t -t7z "$PACKED_FILE_NAME" ;;
        zip)   run unzip -t   "$PACKED_FILE_NAME" ;;
        tar.*) run tar   -tf  "$PACKED_FILE_NAME" ;;
    esac

    step "show size of packed file"
    run "du -sh $PACKED_FILE_NAME | cut -f1"

    PACKED_FILE_CACHE_DIR="$MY_BINARY_DIR/android/$INSTALLED_PACKAGE_SDK_API"

    [ -d "$PACKED_FILE_CACHE_DIR" ] || {
        step "create cached binary dir"
        run install -d "$PACKED_FILE_CACHE_DIR"
    }

    step "copy packed file to cache dir"
    run cp "$PACKED_FILE_NAME" "$PACKED_FILE_CACHE_DIR/"

    if [ "$KEEP_PACKING_DIR" = yes ] ; then
        echo
        note "the packing dir [$PACKING_DIR] is not deleted as --keep-packing-dir option is given."
    else
        step "delete the packing directory"
        run rm -rf $PACKING_DIR
    fi
}

# https://developer.android.com/studio/projects/android-library#aar-contents
#
# __create_prefab_aar_for_the_given_installed_package <PACKAGE-NAME> <MIN-SDK-API-LEVEL>
# __create_prefab_aar_for_the_given_installed_package       v8                21
  __create_prefab_aar_for_the_given_installed_package() {
    [ -z "$1" ] && {
        error "__create_prefab_aar_for_the_given_installed_package <PACKAGE-NAME> <MIN-SDK-API-LEVEL>, <PACKAGE-NAME> is not given."
        return 1
    }

    [ -z "$2" ] && {
        error "__create_prefab_aar_for_the_given_installed_package <PACKAGE-NAME> <MIN-SDK-API-LEVEL>, <MIN-SDK-API-LEVEL> is not given."
        return 1
    }

    is_integer "$2" || {
        error "__create_prefab_aar_for_the_given_installed_package <PACKAGE-NAME> <MIN-SDK-API-LEVEL>, <MIN-SDK-API-LEVEL> must be a integer."
        return 1
    }

    __load_installed_metadata_of_the_given_package "$1" "$2"

    unset PACKAGE_HAVE_INCLUDE
    unset PACKAGE_HAVE_LIBRARY

    unset PACKAGE_INSTALLED_DIR
    unset PACKAGE_INSTALLED_ABIS
    unset PACKAGE_INSTALLED_LIBS

    PACKAGE_INSTALLED_DIR="$MY_INSTALL_DIR/android/$2/$1"

    PACKAGE_INSTALLED_ABIS="$(cat "$PACKAGE_INSTALLED_DIR/installed-abis")"

    for INSTALLED_ABI in $PACKAGE_INSTALLED_ABIS
    do
        if [ -d "$PACKAGE_INSTALLED_DIR/$INSTALLED_ABI/include" ] ; then
            PACKAGE_HAVE_INCLUDE=yes
        fi

        if [ -d "$PACKAGE_INSTALLED_DIR/$INSTALLED_ABI/lib-no-versioning" ] ; then
            for item in $(cd "$PACKAGE_INSTALLED_DIR/$INSTALLED_ABI/lib-no-versioning" && ls)
            do
                [ -d "$item" ] && continue

                case $item in
                    lib*.a|lib*.so) PACKAGE_INSTALLED_LIBS="$PACKAGE_INSTALLED_LIBS $item"
                esac
            done
        fi

        if [ -n "$PACKAGE_INSTALLED_LIBS" ] ; then
            PACKAGE_HAVE_LIBRARY=yes
        fi

        if [ "$PACKAGE_HAVE_INCLUDE" != yes ] && [ "$PACKAGE_HAVE_LIBRARY" != yes ] ; then
            die "no libraries in package $1."
        fi
    done

    step "find or install android ndk"
    setup_build_toolchains_env
    NM="$(path_of_tool_in_the_toolchain nm)"
    READELF="$(path_of_tool_in_the_toolchain readelf)"

    step "handle required tools"
    handle_dependency required exe zip
    handle_dependency required exe grep
    handle_dependency required exe tree
    handle_dependency required exe unzip

    step "printf required tools"
    printf_dependency required exe zip
    printf_dependency required exe grep
    printf_dependency required exe tree
    printf_dependency required exe unzip

    step "create the packing directory"
    PACKING_DIR="$MY_HOME_DIR/prefab.d/android/$INSTALLED_PACKAGE_SDK_API/$INSTALLED_PACKAGE_NAME"

    if [ -d "$PACKING_DIR" ] ; then
        run rm -rf "$PACKING_DIR"
    fi
    run install -d "$PACKING_DIR"

    step "cd  to the packing directory"
    run cd $PACKING_DIR

    step "create META-INF entry"
    run install -d META-INF
    cat > META-INF/README <<EOF
built  by ndk-pkg $INSTALLED_BY_NDK_PKG_VERSION in $(format_unix_timestamp "$INSTALLED_TIMESTAMP_UNIX" '+%Y-%m-%d %H:%M:%S' -u) UTC
packed by ndk-pkg $MY_VERSION in $(date -u '+%Y-%m-%d %H:%M:%S') UTC

For more details, please refer to https://github.com/leleliu008/ndk-pkg
EOF
    if [ -f "$PACKAGE_INSTALLED_DIR/LICENSE" ] ; then
        run cp "$PACKAGE_INSTALLED_DIR/LICENSE" META-INF/
    else
        run cp "$PACKAGE_INSTALLED_DIR/LICENSE[1-9]" META-INF/
    fi

    if [ -f "$PACKAGE_INSTALLED_DIR/AUTHORS" ] ; then
        run cp "$PACKAGE_INSTALLED_DIR/AUTHORS" META-INF/
    fi

    unset JAVA_PACKAGE_NAME

    # java package name characters [a-z0-9_.]
    JAVA_PACKAGE_NAME="$(printf '%s\n' "$1" | tr '+-.' '_' | tr A-Z a-z)"

    step "create AndroidManifest.xml entry"
    cat > AndroidManifest.xml <<EOF
<?xml version="1.0" encoding="utf-8"?>
<manifest
    xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.fpliu.ndk.pkg.prefab.android$INSTALLED_PACKAGE_SDK_API.$JAVA_PACKAGE_NAME"
    android:versionCode="$INSTALLED_TIMESTAMP_UNIX"
    android:versionName="$INSTALLED_PACKAGE_VERSION" >

    <uses-sdk
        android:minSdkVersion="$INSTALLED_PACKAGE_SDK_API"
        android:targetSdkVersion="30" />

</manifest>
EOF

    step "create prefab entry"
    run install -d prefab

    # https://google.github.io/prefab/#package-metadata

    unset PREFAB_JSON_VERSION

    if [ -z "$INSTALLED_PACKAGE_VERSION" ] ; then
        PREFAB_JSON_VERSION="$INSTALLED_TIMESTAMP_UNIX"
    else
        unset SED_E

        I=0

        for CHAR in a b c d e f g h i j k l m n o p q r s t u v w x y z
        do
            I=$(expr "$I" + 1)
            SED_E="$SED_E -e s|$CHAR|.$I|g"
        done

        # r3060
        # 1.4.rc5
        # 2022-03-28
        # 2.4+20151223
        # 1.1.1n
        # 9e
        # 2.8.9rel.1
        # 0.14.1-beta
        # 0.99.beta20
        # 3.0-11
        # 1.4g
        # 0.15.2e
        PREFAB_JSON_VERSION="$(printf '%s\n' "$INSTALLED_PACKAGE_VERSION" | tr +- . | sed -e 's|beta|2|' -e 's|rel||' -e 's|rc|.|' -e 's|^r||' $SED_E)"

        printf '%s\n' "$PREFAB_JSON_VERSION" | {
            grep -q '[0-9]*' ||
            grep -q '[0-9]*\.[0-9]*' ||
            grep -q '[0-9]*\.[0-9]*\.[0-9]*' ||
            grep -q '[0-9]*\.[0-9]*\.[0-9]*\.[0-9]*'
        } || die "version[$PREFAB_JSON_VERSION] not expected."
    fi

    cat > prefab/prefab.json <<EOF
{
  "schema_version": 2,
  "name": "$INSTALLED_PACKAGE_NAME",
  "version": "$PREFAB_JSON_VERSION",
  "dependencies": []
}
EOF

    if [ "$PACKAGE_HAVE_LIBRARY" = yes ] ; then
        for LIBRARY_FILENAME in $PACKAGE_INSTALLED_LIBS
        do
            unset LIBRARY_FILENAME_PREFIX
            unset IS_STATIC_LIBRARY

            case $LIBRARY_FILENAME in
                *.a)  LIBRARY_FILENAME_PREFIX="${LIBRARY_FILENAME%.a}"  ; IS_STATIC_LIBRARY=true  ;;
                *.so) LIBRARY_FILENAME_PREFIX="${LIBRARY_FILENAME%.so}" ; IS_STATIC_LIBRARY=false ;;
            esac

            MODULE_DIR="prefab/modules/$LIBRARY_FILENAME"

            run install -d "$MODULE_DIR"

            cat > "$MODULE_DIR/module.json" <<EOF
{
  "export_libraries": [],
  "android": {
    "library_name": "$LIBRARY_FILENAME_PREFIX",
    "export_libraries": []
  }
}
EOF
            for INSTALLED_ABI in $PACKAGE_INSTALLED_ABIS
            do
                ABI_DIR="$MODULE_DIR/libs/android.$INSTALLED_ABI"

                run install -d "$ABI_DIR"

                if [ "$PACKAGE_HAVE_INCLUDE" = yes ] ; then
                    run cp -r "$PACKAGE_INSTALLED_DIR/$INSTALLED_ABI/include" "$ABI_DIR"
                fi

                LIBRARY_FILEPATH="$PACKAGE_INSTALLED_DIR/$INSTALLED_ABI/lib-no-versioning/$LIBRARY_FILENAME"

                run cp "$LIBRARY_FILEPATH" "$ABI_DIR"

                STL=none

                # https://github.com/google/prefab/blob/master/api/src/main/kotlin/com/google/prefab/api/Android.kt#L202
                if [ "$IS_STATIC_LIBRARY" = true ] ; then
                    if   "$NM" "$LIBRARY_FILEPATH" | grep -q 'T __cxa_' ; then
                        die "libc++_static.a has been merged into $LIBRARY_FILEPATH, this may case problems. For more details, please refer to https://developer.android.com/ndk/guides/cpp-support"
                    elif "$NM" "$LIBRARY_FILEPATH" | grep -q 'U __cxa_' ; then
                        STL=c++_shared
                    fi
                else
                    if "$READELF" -d "$LIBRARY_FILEPATH" | grep -q 'libc++_shared\.so' ; then
                        STL=c++_shared
                    elif "$NM" -D "$LIBRARY_FILEPATH" | grep -q 'T __cxa_' ; then
                        # https://softwareengineering.stackexchange.com/questions/262195/whats-wrong-with-statically-linking-the-stl-into-multiple-shared-libraries
                        # https://developer.android.com/ndk/guides/cpp-support
                        die "libc++_static.a has been linked into $LIBRARY_FILEPATH, this may case problems. For more details, please refer to https://developer.android.com/ndk/guides/cpp-support"
                    fi
                fi

                printf '%s\n' "{\"api\": $INSTALLED_PACKAGE_SDK_API,\"ndk\": $BUILD_USE_TOOLCHAIN_VERS_MAJOR,\"abi\": \"$INSTALLED_ABI\",\"stl\": \"$STL\",\"static\":$IS_STATIC_LIBRARY}" > "$ABI_DIR/abi.json"
            done
        done
    else
        # header only
        MODULE_DIR="prefab/modules/$INSTALLED_PACKAGE_NAME"
        run install -d "$MODULE_DIR"
        run cp -r "$PACKAGE_INSTALLED_DIR/armeabi-v7a/include" "$MODULE_DIR"
    fi

    if [ -z "$INSTALLED_PACKAGE_VERSION" ] ; then
        PACKED_FILE_NAME="$INSTALLED_PACKAGE_NAME-$INSTALLED_TIMESTAMP_UNIX.aar"
    else
        PACKED_FILE_NAME="$INSTALLED_PACKAGE_NAME-$INSTALLED_PACKAGE_VERSION.aar"
    fi

    if command -v tree > /dev/null ; then
        step "tree $PWD"
        run tree --dirsfirst
    fi

    step "packing"
    run zip -9 -r "$PACKED_FILE_NAME" .

    step "check integrity of packed file"
    run unzip -t "$PACKED_FILE_NAME"

    step "show size of packed file"
    run du -sh $PACKED_FILE_NAME
}

# __deploy_prefab_aar_for_the_given_installed_package <PACKAGE-NAME> <MIN-SDK-API-LEVEL> <mavenLocal|mavenRemote> [-d] [-x]
  __deploy_prefab_aar_for_the_given_installed_package() {
    [ -z "$1" ] && {
        error "$_0 deploy <PACKAGE-NAME> <MIN-SDK-API-LEVEL> <TO-WHERE>, <PACKAGE-NAME> is not given."
        return 1
    }

    [ -z "$2" ] && {
        error "$_0 deploy <PACKAGE-NAME> <MIN-SDK-API-LEVEL> <TO-WHERE>, <MIN-SDK-API-LEVEL> is not given."
        return 1
    }

    is_integer "$2" || {
        error "$_0 deploy <PACKAGE-NAME> <MIN-SDK-API-LEVEL> <TO-WHERE>, <MIN-SDK-API-LEVEL> must be a integer."
        return 1
    }

    is_package_installed "$1" "$2" || {
        error "package [$1] is not installed."
        return 1
    }

    case $3 in
        mavenLocal|mavenRemote)
            ;;
        *)  die "$_0 deploy <PACKAGE-NAME> <MIN-SDK-API-LEVEL> <TO-WHERE>, <TO-WHERE> shall be mavenLocal or mavenRemote"
    esac

    unset MVN_OPTIONS

    for option in $(shiftn 3 $@)
    do
        case $option in
            -d|--debug)
                MVN_OPTIONS=-X
                ;;
            -x|--xtrace)
                ;;
            *)  die "unrecognized option: $option"
        esac
    done

    __create_prefab_aar_for_the_given_installed_package $@

    handle_dependency required exe mvn

    if [ "$3" = mavenLocal ] ; then
        # https://maven.apache.org/plugins/maven-install-plugin/install-file-mojo.html
        step "deploying to maven local repository"
        run mvn \
            $MVN_OPTIONS \
            install:install-file \
            -Dfile=$PACKED_FILE_NAME \
            -DgroupId=com.fpliu.ndk.pkg.prefab.android.$INSTALLED_PACKAGE_SDK_API \
            -DartifactId=$INSTALLED_PACKAGE_NAME \
            -Dversion=$INSTALLED_PACKAGE_VERSION \
            -Dpackaging=aar
        return $?
    fi

    unset SERVER_ID
    unset SERVER_URL
    unset SERVER_USERNAME
    unset SERVER_PASSWORD
    unset GPG_PASSPHRASE

    step "read config from stdin"
    while read -r LINE
    do
        case $LINE in
            SERVER_ID=*)        SERVER_ID=$(getvalue "$LINE") ;;
            SERVER_URL=*)       SERVER_URL=$(getvalue "$LINE") ;;
            SERVER_USERNAME=*)  SERVER_USERNAME=$(getvalue "$LINE") ;;
            SERVER_PASSWORD=*)  SERVER_PASSWORD=$(getvalue "$LINE") ;;
            GPG_PASSPHRASE=*)   GPG_PASSPHRASE=$(getvalue "$LINE") ;;
        esac
    done

    [ -z "$SERVER_ID" ] && die "SERVER_ID must not be enpty."
    [ -z "$SERVER_URL" ] && die "SERVER_URL must not be enpty."
    [ -z "$SERVER_USERNAME" ] && die "SERVER_USERNAME must not be enpty."
    [ -z "$SERVER_PASSWORD" ] && die "SERVER_PASSWORD must not be enpty."
    [ -z "$GPG_PASSPHRASE"  ] && die "GPG_PASSPHRASE must not be enpty."

    # https://central.sonatype.org/publish/release/
    # https://central.sonatype.org/publish/requirements/

    if [ -z "$INSTALLED_PACKAGE_LICENSE" ] ; then
        error "$1 can not be deployed due to INSTALLED_PACKAGE_LICENSE is empty."
        return 1
    fi

    if [ -z "$INSTALLED_PACKAGE_GIT_URL" ] && [ -z "$INSTALLED_PACKAGE_SVN_URL" ] ; then
        error "$1 can not be deployed due to INSTALLED_PACKAGE_GIT_URL and INSTALLED_PACKAGE_SVN_URL is empty."
        return 1
    fi

    if [ -n "$INSTALLED_PACKAGE_GIT_URL" ] ; then
        INSTALLED_PACKAGE_SCM_TYPE=git
        INSTALLED_PACKAGE_SCM_URL="$INSTALLED_PACKAGE_GIT_URL"
    fi

    if [ -n "$INSTALLED_PACKAGE_SVN_URL" ] ; then
        INSTALLED_PACKAGE_SCM_TYPE=svn
        INSTALLED_PACKAGE_SCM_URL="$INSTALLED_PACKAGE_SVN_URL"
    fi

    POM_FILE="${PACKED_FILE_NAME%.aar}.pom"

    step "generating $POM_FILE"
    cat > "$POM_FILE" <<EOF
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.fpliu.ndk.pkg.prefab.android.$INSTALLED_PACKAGE_SDK_API</groupId>
    <artifactId>$INSTALLED_PACKAGE_NAME</artifactId>
    <version>$INSTALLED_PACKAGE_VERSION</version>
    <packaging>aar</packaging>

    <name>$INSTALLED_PACKAGE_NAME</name>
    <description>$INSTALLED_PACKAGE_SUMMARY</description>
    <url>$INSTALLED_PACKAGE_WEBPAGE</url>

    <scm>
        <connection>scm:$INSTALLED_PACKAGE_SCM_TYPE:$INSTALLED_PACKAGE_SCM_URL</connection>
        <developerConnection>scm:$INSTALLED_PACKAGE_SCM_TYPE:$INSTALLED_PACKAGE_SCM_URL</developerConnection>
        <url>$INSTALLED_PACKAGE_SCM_URL</url>
    </scm>

    <developers>
EOF

    if [ -z "$INSTALLED_PACKAGE_DEVELOPER" ] ; then
        INSTALLED_PACKAGE_DEVELOPER=";"
    fi

    for DEVELOPER in $INSTALLED_PACKAGE_DEVELOPER
    do
        unset DEVELOPER_NAME
        unset DEVELOPER_EMAIL
        unset DEVELOPER_ORGANIZATION_NAME
        unset DEVELOPER_ORGANIZATION_WEBPAGE

        DEVELOPER_NAME="$( printf '%s\n' "$DEVELOPER" | cut -d '|' -f1 | tr '+' ' ')"
        DEVELOPER_EMAIL="$(printf '%s\n' "$DEVELOPER" | cut -d '|' -f2)"
        DEVELOPER_ORGANIZATION_NAME="$(printf '%s\n' "$DEVELOPER" | cut -d '|' -f3 | tr '+' ' ')"
        DEVELOPER_ORGANIZATION_WEBPAGE="$(printf '%s\n' "$DEVELOPER" | cut -d '|' -f4)"

        if [ -z "$DEVELOPER_NAME" ] ; then
            DEVELOPER_NAME="$INSTALLED_PACKAGE_NAME developers"
        fi

        if [ -z "$DEVELOPER_EMAIL" ] ; then
            DEVELOPER_EMAIL="unknown"
        fi

        if [ -z "$DEVELOPER_ORGANIZATION_NAME" ] ; then
            DEVELOPER_ORGANIZATION_NAME="$INSTALLED_PACKAGE_NAME"
        fi

        if [ -z "$DEVELOPER_ORGANIZATION_WEBPAGE" ] ; then
            DEVELOPER_ORGANIZATION_WEBPAGE="$INSTALLED_PACKAGE_WEBPAGE"
        fi

        cat >> "$POM_FILE" <<EOF
        <developer>
            <name>$DEVELOPER_NAME</name>
            <email>$DEVELOPER_EMAIL</email>
            <organization>$DEVELOPER_ORGANIZATION_NAME</organization>
            <organizationUrl>$DEVELOPER_ORGANIZATION_WEBPAGE</organizationUrl>
        </developer>
EOF
    done

    cat >> "$POM_FILE" <<EOF
    </developers>

    <licenses>
EOF

    for item in $INSTALLED_PACKAGE_LICENSE
    do
        unset LICENSE_NAME
        unset LICENSE_URL_

        case $item in
            *\|*)
                LICENSE_NAME=$(printf '%s\n' "$item" | cut -d '|' -f1)
                LICENSE_URL_=$(printf '%s\n' "$item" | cut -d '|' -f3)
                if [ -z "$LICENSE_NAME" ] ; then
                    LICENSE_NAME="$INSTALLED_PACKAGE_NAME License"
                fi
                ;;
            *)  LICENSE_NAME="$item"
                LICENSE_URL_="https://raw.githubusercontent.com/spdx/license-list-data/master/text/$item.txt"
        esac

        cat >> "$POM_FILE" <<EOF
        <license>
            <name>$LICENSE_NAME</name>
            <url>$LICENSE_URL_</url>
        </license>
EOF
    done

    cat >> "$POM_FILE" <<EOF
    </licenses>
</project>
EOF

    on_exit_deploy() {
        rm -f settings.xml
    }

    trap on_exit_deploy EXIT

    # https://maven.apache.org/plugins/maven-gpg-plugin/usage.html
    step "generating settings.xml"
    cat > settings.xml <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd">
  <servers>
    <server>
      <id>$SERVER_ID</id>
      <username>$SERVER_USERNAME</username>
      <password>$SERVER_PASSWORD</password>
    </server>

    <server>
      <id>gpg.passphrase</id>
      <passphrase>$GPG_PASSPHRASE</passphrase>
    </server>
  </servers>
</settings>
EOF

    handle_dependency required exe mvn

    # here I can use maven-deploy-plugin and maven-gpg-plugin
    # maven-gpg-plugin is prefered as it is automatically signed with gpg.
    # 
    # https://maven.apache.org/plugins/maven-gpg-plugin/sign-and-deploy-file-mojo.html
    # https://maven.apache.org/plugins/maven-deploy-plugin/deploy-file-mojo.html
    # https://maven.apache.org/resolver/configuration.html

    step "deploying"
    run mvn \
        --settings settings.xml \
        $MVN_OPTIONS \
        gpg:sign-and-deploy-file \
        -Dfile=$PACKED_FILE_NAME \
        -DgeneratePom=false \
        -DpomFile=$POM_FILE \
        -Daether.checksums.algorithms=MD5,SHA-1,SHA-256,SHA-512 \
        -DrepositoryId=$SERVER_ID \
        -Durl=$SERVER_URL
}

# this fuction should be run in subshell
# __get_packages_that_are_directly_depended_by_the_given_package <PACKAGE-NAME>
  __get_packages_that_are_directly_depended_by_the_given_package() {
    unset PACKAGE_FORMULA_FILEPATH
    PACKAGE_FORMULA_FILEPATH="$(__path_of_formula_of_the_given_package $1)" || return 1

    sed -n '/^[[:space:]]*pkg_set[[:space:]]\{1,\}dep\.pkg[[:space:]]\{1,\}".*"[[:space:]]*/p' "$PACKAGE_FORMULA_FILEPATH" | sed 's/^[[:space:]]*pkg_set[[:space:]]\{1,\}dep\.pkg[[:space:]]\{1,\}"[[:space:]]*\(.*\)[[:space:]]*"[[:space:]]*/\1/'
}

# this fuction should be run in subshell
#
# __get_packages_that_are_recursively_depended_by_the_given_packages <PACKAGE-NAME>...
  __get_packages_that_are_recursively_depended_by_the_given_packages() {
      [ -z "$1" ] && {
          error "__get_packages_that_are_recursively_depended_by_the_given_packages <PACKAGE-NAME>..., <PACKAGE-NAME> is not given."
          return 1
      }

      __get_packages_that_are_recursively_depended_by_the_given_package ";$(printf '%s\n' "$*" | tr ' ' ';')"
}

# this fuction should be run in subshell
#
# __get_packages_that_are_recursively_depended_by_the_given_package <PACKAGE-NAME>
# __get_packages_that_are_recursively_depended_by_the_given_package <PACKAGE-NAME> internal
  __get_packages_that_are_recursively_depended_by_the_given_package() {
    [ -z "$1" ] && {
        error "__get_packages_that_are_recursively_depended_by_the_given_package <PACKAGE-NAME> [internal], <PACKAGE-NAME> is not given."
        return 1
    }

    unset DIRECT_DEPENDENT_PACKAGES

    case $1 in
        *\;*) DIRECT_DEPENDENT_PACKAGES=$(printf '%s\n' "$1" | tr ';' ' ') ;;
        *)    DIRECT_DEPENDENT_PACKAGES=$(__get_packages_that_are_directly_depended_by_the_given_package "$1")
    esac

    [ "$2" != internal ] && {
        DEPTH=1
        RESULT=
    }

    DEPTH=$(expr "$DEPTH" + 1)

    for DIRECT_DEPENDENT_PACKAGE_NAME in $DIRECT_DEPENDENT_PACKAGES
    do
        is_package_available "$DIRECT_DEPENDENT_PACKAGE_NAME" || {
            error "package [$DIRECT_DEPENDENT_PACKAGE_NAME] is not available."
            return 1
        }

        if [ "$(printf '%s\n' "$RESULT" | sed -n "/^$DIRECT_DEPENDENT_PACKAGE_NAME$/p")" = "$DIRECT_DEPENDENT_PACKAGE_NAME" ] ; then
            RESULT=$(printf '%s\n' "$RESULT" | sed "/^$DIRECT_DEPENDENT_PACKAGE_NAME$/d")
        fi

        if [ -z "$RESULT" ] ; then
            RESULT="$DIRECT_DEPENDENT_PACKAGE_NAME"
        else
            RESULT="$DIRECT_DEPENDENT_PACKAGE_NAME
$RESULT"
        fi

        __get_packages_that_are_recursively_depended_by_the_given_package "$DIRECT_DEPENDENT_PACKAGE_NAME" internal
    done

    DEPTH=$(expr "$DEPTH" - 1)

    if [ "$DEPTH" -eq 1 ] ; then
        printf '%s\n' "$RESULT"
    fi
}

__get_dot_file_contents() {
    for PKG in $@
    do
        unset DIRECT_DEPENDENT_PACKAGES
        DIRECT_DEPENDENT_PACKAGES="$(__get_packages_that_are_directly_depended_by_the_given_package "$PKG")"
        if [ -n "$DIRECT_DEPENDENT_PACKAGES" ] ; then
            printf '"%s" -> { "%s" }\n' "$PKG" "$(printf '%s\n' "$DIRECT_DEPENDENT_PACKAGES" | sed 's/ /" "/g')"
            __get_dot_file_contents $DIRECT_DEPENDENT_PACKAGES
        fi
    done
}

# __gen_dependency_graph_recursively_depended_by_the_given_package <PKG> <dot|txt|png> <OUTPUT-FILEPATH>
__gen_dependency_graph_recursively_depended_by_the_given_package() {
    unset DIRECT_DEPENDENT_PACKAGES
    DIRECT_DEPENDENT_PACKAGES="$(__get_packages_that_are_directly_depended_by_the_given_package "$1")"

    if [ -z "$DIRECT_DEPENDENT_PACKAGES" ] ; then
        return 0
    fi

    case $2 in
        dot|txt|png) ;;
        '') die "__gen_dependency_graph_recursively_depended_by_the_given_package <PKG> <dot|txt|png> <OUTPUT-FILEPATH>, format must not be empty." ;;
        *)  die "__gen_dependency_graph_recursively_depended_by_the_given_package <PKG> <dot|txt|png> <OUTPUT-FILEPATH>, unrecognized format: $2"
    esac

    if [ -z "$3" ] ; then
        die "__gen_dependency_graph_recursively_depended_by_the_given_package <PKG> <dot|txt|png> <OUTPUT-FILEPATH>, <OUTPUT-FILEPATH> must be not empty."
    fi

    unset GEN_DEPENDENCY_GRAPH_WORKING_DIR
    unset GEN_DEPENDENCY_GRAPH_DOT_FILEPATH

    GEN_DEPENDENCY_GRAPH_WORKING_DIR=$(mktemp -d) || return 1
    GEN_DEPENDENCY_GRAPH_DOT_FILEPATH="$GEN_DEPENDENCY_GRAPH_WORKING_DIR/dependencies.dot"
    GEN_DEPENDENCY_GRAPH_TXT_FILEPATH="$GEN_DEPENDENCY_GRAPH_WORKING_DIR/dependencies.txt"
    GEN_DEPENDENCY_GRAPH_PNG_FILEPATH="$GEN_DEPENDENCY_GRAPH_WORKING_DIR/dependencies.png"

    printf 'digraph G {\n'       >  "$GEN_DEPENDENCY_GRAPH_DOT_FILEPATH"
    __get_dot_file_contents "$1" >> "$GEN_DEPENDENCY_GRAPH_DOT_FILEPATH"
    printf '}\n'                 >> "$GEN_DEPENDENCY_GRAPH_DOT_FILEPATH"

    if [ "$3" != '/dev/tty' ] ; then
        unset GEN_DEPENDENCY_GRAPH_OUTPUT_DIR

        case $3 in
            /*) GEN_DEPENDENCY_GRAPH_OUTPUT_DIR="$(dirname      "$3")" ;;
             *) GEN_DEPENDENCY_GRAPH_OUTPUT_DIR="$(dirname "$PWD/$3")" ;;
        esac

        if [ !      -d "$GEN_DEPENDENCY_GRAPH_OUTPUT_DIR" ] ; then
            install -d "$GEN_DEPENDENCY_GRAPH_OUTPUT_DIR" || return 1
        fi
    fi

    case $2 in
        dot)
            if [ "$3" = '/dev/tty' ] ; then
                cat   "$GEN_DEPENDENCY_GRAPH_DOT_FILEPATH"
            else
                cp -f "$GEN_DEPENDENCY_GRAPH_DOT_FILEPATH" "$3"
            fi
            ;;
        txt)
            handle_dependency required exe curl || return 1

            # https://github.com/ggerganov/dot-to-ascii
            curl \
                -o "$GEN_DEPENDENCY_GRAPH_TXT_FILEPATH" \
                -s \
                -G \
                --data-urlencode "boxart=1" \
                --data-urlencode "src=$(cat $GEN_DEPENDENCY_GRAPH_DOT_FILEPATH)" \
                "https://dot-to-ascii.ggerganov.com/dot-to-ascii.php" || return 1

            if [ "$3" = '/dev/tty' ] ; then
                cat   "$GEN_DEPENDENCY_GRAPH_TXT_FILEPATH"
            else
                cp -f "$GEN_DEPENDENCY_GRAPH_TXT_FILEPATH" "$3"
            fi
            ;;
        png)
            handle_dependency required exe dot || return 1

            if command -v fc-match > /dev/null ; then
                # Error: fontconfig: Couldn't find font.
                if [ -z "$(fc-match)" ] ; then
                    fetch 'https://github.com/ryanoasis/nerd-fonts/blob/master/patched-fonts/Meslo/M/Regular/complete/Meslo%20LG%20M%20Regular%20Nerd%20Font%20Complete%20Mono%20Windows%20Compatible.ttf?raw=true' --output-dir="$HOME/.fonts" --output-name='Meslo LG M DZ Regular Nerd Font Complete Mono.ttf' || return 1
                fi
            fi

            run dot -Tpng -o "$3" "$GEN_DEPENDENCY_GRAPH_DOT_FILEPATH"
            ;;
    esac
}

__install_the_given_packages() {
    inspect_install_arguments $@

    [ -z "$USER_SPECIFIED_PACKAGES" ] && {
        error "$_0 install <PACKAGE-NAME>..., <PACKAGE-NAME> is not given."
        return 1
    }

    unset PACKAGES_TO_BE_INSTALLED
    PACKAGES_TO_BE_INSTALLED="$(__get_packages_that_are_recursively_depended_by_the_given_packages $USER_SPECIFIED_PACKAGES)"

    if [ $(list_length $PACKAGES_TO_BE_INSTALLED) -gt 1 ] ; then
        PACKAGES_TO_BE_INSTALLED="$(printf '%s\n' "$PACKAGES_TO_BE_INSTALLED" | tr '\n' ' ')"
        printf '%b\n' "$COLOR_PURPLE==>$COLOR_OFF to install$COLOR_GREEN $PACKAGES_TO_BE_INSTALLED $COLOR_OFF\n"
    fi

    for INSTALLING_PACKAGE in $PACKAGES_TO_BE_INSTALLED
    do
        if is_package_installed "$INSTALLING_PACKAGE" "$MIN_SDK_API_LEVEL" ; then
            if [ "$LOG_LEVEL" -gt "$LOG_LEVEL_QUIET" ] ; then
                printf "$COLOR_GREEN%-10s$COLOR_OFF already have been installed.\n" "$INSTALLING_PACKAGE"
            fi
        else
            (__install_the_given_package "$INSTALLING_PACKAGE")
        fi
    done
}

# Note: this function must run in a subshell
__install_the_given_package() {
    printf '%b\n' "${COLOR_PURPLE}=============== Installing ${COLOR_OFF}${COLOR_GREEN}${1}${COLOR_OFF}${COLOR_PURPLE} ===============${COLOR_OFF}"

    # brew install meson
    # Error: The current work directory doesn't exist, cannot proceed.
    # beacuse previous package's work direcotory is deleted.
    cd ~

    unset PACKAGE_INSTALLING_TOP_DIR
    unset PACKAGE_INSTALLING_SRC_DIR
    unset PACKAGE_INSTALLING_BST_DIR

    unset PACKAGE_INSTALL_DIR

    unset NATIVE_BUILDIN_DIR
    unset NATIVE_INSTALL_DIR

    unset CONFIG_XX_UPDATED
    unset STEP_NUM

    unset TARGET_INDEX
    unset TARGET_ITEM

    unset TARGET_OS_VERS

    __install_the_given_package_on_exit() {
        if [ -z "$TARGET_OS_VERS" ] ; then
            :
        else
            is_package_installed "$INSTALLING_PACKAGE" "$TARGET_OS_VERS" && return 0
        fi

        if [ -z "$PACKAGE_INSTALLING_TOP_DIR" ] ; then
            die "package [$INSTALLING_PACKAGE] install failed!"
        else
            if [ "$DRYRUN" = yes ] ; then
                return 0
            fi
            if [ -z "$TARGET_ITEM" ] ; then
                die "package [$INSTALLING_PACKAGE] install failed! you can go to directory[$PACKAGE_INSTALLING_TOP_DIR] to look at the details."
            else
                die "target [$INSTALLING_PACKAGE/$TARGET_ITEM] install failed! you can go to directory[$PACKAGE_INSTALLING_TOP_DIR] to look at the details."
            fi
        fi
    }

    trap __install_the_given_package_on_exit EXIT

    __setup_PATH_env

    bppend_to_PATH "$TOOLCHAIN_BIND"

    step "view formula"
    __view_formula_of_the_given_package "$1" --paging=never

    step "load formula"
    __load_formula_of_the_given_package "$1"

    unset PACKAGE_INSTALL_STATICALLY_LINKED_EXECUTABLE

    if [ "$LINK_TYPE" = 'static-only' ] && [ "$PACKAGE_INSTALL_EXE" = yes ] && [ "$PACKAGE_INSTALL_LIB" != yes ] ; then
        PACKAGE_INSTALL_STATICALLY_LINKED_EXECUTABLE=yes
    fi

    if [ "$PACKAGE_INSTALL_STATICALLY_LINKED_EXECUTABLE" = yes ] ; then
        TARGET_OS_VERS="$SUPPORTED_SDK_API_LEVEL_MAX"
    else
        TARGET_OS_VERS="$MIN_SDK_API_LEVEL"
    fi

    if [ -n "$PACKAGE_SDK_API" ] && [ "$PACKAGE_SDK_API" -gt "$TARGET_OS_VERS" ] ; then
        error "package [$1] install failed!.\n    package supported min sdk-api-level is $PACKAGE_SDK_API\n    but you requested min sdk-api-level is $TARGET_OS_VERS"
        return 1
    fi

    PACKAGE_INSTALL_DIR="$MY_INSTALL_DIR/android/$TARGET_OS_VERS/$1"


    if [ "$CCACHE_ENABLED" = yes ] ; then
        PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD ccache"
    fi

    if [ "$PACKAGE_BUILD_SYSTEM_GMAKE" = yes ] ; then
        if [ "$EXPORT_COMPILE_COMMANDS_JSON" = yes ] && [ "$BEAR_ENABLED" = yes ] ; then
            PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD bear"
        fi
    fi

    PACKAGE_DEP_CMD="$PACKAGE_DEP_CMD find tree hexdump patchelf"

    # https://docs.github.com/en/actions/learn-github-actions/environment-variables#default-environment-variables
    # https://github.com/actions/virtual-environments/issues/5360#issuecomment-1091306746
    if [ "$GITHUB_ACTIONS" = true ] && [ "$NATIVE_OS_TYPE" = ubuntu ] ; then
        step "uninstall automake autoconf libtool used to be installed from APT repo"
        run $sudo apt -y remove automake autoconf libtool
    fi

    step "handle required dependencies"
    for item in $PACKAGE_DEP_CMD
    do
        handle_dependency $(__parse_require_dependency_item exe "$item")
    done
    for item in $PACKAGE_DEP_PYM
    do
        handle_dependency $(__parse_require_dependency_item pym "$item")
    done
    for item in $PACKAGE_DEP_PLM
    do
        handle_dependency $(__parse_require_dependency_item plm "$item")
    done

    step "printf required dependencies"
    __printf_dependency TYPE NAME OP EXPECT ACTUAL LOCATION
    for item in $PACKAGE_DEP_CMD
    do
        printf_dependency $(__parse_require_dependency_item exe "$item")
    done
    for item in $PACKAGE_DEP_PYM
    do
        printf_dependency $(__parse_require_dependency_item pym "$item")
    done
    for item in $PACKAGE_DEP_PLM
    do
        printf_dependency $(__parse_require_dependency_item plm "$item")
    done

    unset PKG_CONFIG
    unset CCACHE
    unset MESON
    unset CMAKE
    unset GMAKE
    unset NINJA

    PKG_CONFIG=$(command -v pkg-config || true)
    CCACHE=$(command -v ccache || true)
    MESON=$(command -v meson || true)
    CMAKE=$(command -v cmake || true)
    GMAKE=$(command -v gmake || command -v make || true)
    NINJA=$(command -v ninja || true)

    PERL_HOME=$(__get_perl_home)
    if [ -n "$PERL_HOME" ] ; then
        bppend_to_PATH "$PERL_HOME/bin"
    fi

    PACKAGE_INSTALLING_TOP_DIR="$MY_HOME_DIR/installing.d/android/$TARGET_OS_VERS/$1"
    PACKAGE_INSTALLING_SRC_DIR="$PACKAGE_INSTALLING_TOP_DIR/src"

    step "create the installing directory"
    if [ -d "$PACKAGE_INSTALLING_TOP_DIR" ] ; then
        run rm -rf "$PACKAGE_INSTALLING_TOP_DIR"
    fi
    run install -d "$PACKAGE_INSTALLING_TOP_DIR"

    step "calculate packages that are depended by $1"
    unset RECURSIVE_DEPENDENT_PACKAGES
    if [ -z "$PACKAGE_DEP_PKG" ] ; then
        note "there's no packages that are depended by $1."
    else
        RECURSIVE_DEPENDENT_PACKAGES="$(__get_packages_that_are_recursively_depended_by_the_given_package "$1")"

        PACKAGE_DEPENDENCY_GRAPH_FILEPATH_DOT="$PACKAGE_INSTALLING_TOP_DIR/dependencies.dot"
        PACKAGE_DEPENDENCY_GRAPH_FILEPATH_TXT="$PACKAGE_INSTALLING_TOP_DIR/dependencies.txt"
        PACKAGE_DEPENDENCY_GRAPH_FILEPATH_PNG="$PACKAGE_INSTALLING_TOP_DIR/dependencies.png"

        __gen_dependency_graph_recursively_depended_by_the_given_package "$1" dot "$PACKAGE_DEPENDENCY_GRAPH_FILEPATH_DOT" || true
        __gen_dependency_graph_recursively_depended_by_the_given_package "$1" txt "$PACKAGE_DEPENDENCY_GRAPH_FILEPATH_TXT" || true
        __gen_dependency_graph_recursively_depended_by_the_given_package "$1" png "$PACKAGE_DEPENDENCY_GRAPH_FILEPATH_PNG" || true

        if [ -f "$PACKAGE_DEPENDENCY_GRAPH_FILEPATH_TXT" ] ; then
            cat "$PACKAGE_DEPENDENCY_GRAPH_FILEPATH_TXT"
        fi
    fi

    step "create common include.h"
    unset COMMON_INCLUDE_H_FILEPATH
    COMMON_INCLUDE_H_FILEPATH="$PACKAGE_INSTALLING_TOP_DIR/include.h"
    create_common_include_h "$COMMON_INCLUDE_H_FILEPATH"
    if command -v bat > /dev/null ; then
        run bat --style=plain --paging=never "$COMMON_INCLUDE_H_FILEPATH"
    else
        run cat "$COMMON_INCLUDE_H_FILEPATH"
    fi

    step "fetch sources if needed"
    __fetch_sources_of_the_given_package "$1"

    step "fetch patches if needed"
    __fetch_patches_of_the_given_package "$1"

    case $PACKAGE_SRC_URL in
        dir://*)
            if [ "$PACKAGE_SRC_PATH" = '/dev/null' ] ; then
                step "create the directory where source files will be stored in"
                run install -d "$PACKAGE_INSTALLING_SRC_DIR"
            elif [ -d "$PACKAGE_SRC_PATH" ] ; then
                if [ -d "$PACKAGE_SRC_PATH/.git" ] && command -v git > /dev/null ; then
                    PACKAGE_GIT_SHA=$(cd "$PACKAGE_SRC_PATH" && git rev-parse HEAD || true)
                fi

                step "create the directory where source files will be copied to"
                run install -d "$PACKAGE_INSTALLING_SRC_DIR"

                step "copy source files to the directory i just created"
                run cp -r "$PACKAGE_SRC_PATH/." "$PACKAGE_INSTALLING_SRC_DIR"
            else
                die "src.url point to dir is not exist."
            fi
            ;;
        *.git)
            if [ -z "$PACKAGE_GIT_SHA" ] ; then
                PACKAGE_GIT_SHA=$(cd "$PACKAGE_SRC_PATH" && git rev-parse HEAD)
            fi

            step "create the directory where source files will be copied to"
            run install -d "$PACKAGE_INSTALLING_SRC_DIR"

            step "copy source files to the directory i just created"
            run cp -r "$PACKAGE_SRC_PATH/." "$PACKAGE_INSTALLING_SRC_DIR"
            ;;
        *.c|*.cc|*.cxx|*.cpp)
            step "create the directory where source files will be copied to"
            run install -d "$PACKAGE_INSTALLING_SRC_DIR"

            step "copy source files to the directory i just created"
            run cp    "$PACKAGE_SRC_PATH"   "$PACKAGE_INSTALLING_SRC_DIR"
            ;;
        *.zip)
            step "create the directory where source file will be uncompressed to"
            run install -d "$PACKAGE_INSTALLING_SRC_DIR"

            step "uncompressed source file to the directory i just created"
            run unzip "$PACKAGE_SRC_PATH" -d "$PACKAGE_INSTALLING_SRC_DIR"
            ;;
        *.tar.xz|*.tar.gz|*.tar.lz|*.tar.bz2|*.tgz|*.txz)
            step "create the directory where source file will be uncompressed to"
            run install -d "$PACKAGE_INSTALLING_SRC_DIR"

            step "uncompressed source file to the directory i just created"
            run tar xf "$PACKAGE_SRC_PATH" -C "$PACKAGE_INSTALLING_SRC_DIR" --strip-components 1
            ;;
        *)  die "unrecognized extension : $PACKAGE_SRC_URL. the supported extensions are .zip .tar.xz .tar.gz .tar.lz .tar.bz2 .tgz .txz"
    esac

    if [ -z "$PACKAGE_BSCRIPT" ] ; then
        PACKAGE_INSTALLING_BST_DIR="$PACKAGE_INSTALLING_SRC_DIR"
    else
        PACKAGE_INSTALLING_BST_DIR="$PACKAGE_INSTALLING_SRC_DIR/$PACKAGE_BSCRIPT"
    fi

    step "list files of source top directory"
    run ls -l "$PACKAGE_INSTALLING_SRC_DIR"

    if [ -n "$PACKAGE_BSCRIPT" ] ; then
        step "list files of build script directory"
        run ls -l "$PACKAGE_INSTALLING_BST_DIR"
    fi

    if [ -n "$PACKAGE_LICENSE" ] ; then
        step "copy or fetch licenses"

        I=0

        for item in $PACKAGE_LICENSE
        do
            unset LICENSE_PATH
            unset LICENSE_URL_

            I=$(expr "$I" + 1)

            case $item in
                *\|*)
                    LICENSE_PATH="$(printf '%s\n' "$item" | cut -d '|' -f2)"
                    LICENSE_URL_="$(printf '%s\n' "$item" | cut -d '|' -f3)"
                    ;;
                *)  LICENSE_URL_="https://raw.githubusercontent.com/spdx/license-list-data/master/text/$item.txt"
            esac

            # https://github.com/spdx/license-list-data

            if [ -z "$LICENSE_PATH" ] ; then
                fetch "$LICENSE_URL_"  --output-dir="$PACKAGE_INSTALLING_TOP_DIR" --output-name="LICENSE$I"
            else
                cp "$PACKAGE_INSTALLING_SRC_DIR/$LICENSE_PATH" "$PACKAGE_INSTALLING_TOP_DIR/LICENSE$I"
            fi
        done

        unset LICENSE_PATH
        unset LICENSE_URL_
    fi

    step "change to build script directory"
    run cd "$PACKAGE_INSTALLING_BST_DIR"

    step "build for native"
    if command -v build0 > /dev/null ; then
        NATIVE_INSTALL_DIR="$MY_HOME_DIR/native/$PACKAGE_NAME"

        if [ -f "$NATIVE_INSTALL_DIR/version.txt" ] ; then
            if [ "$(cat "$NATIVE_INSTALL_DIR/version.txt")" != "$PACKAGE_VERSION" ] ; then
                warn "build for native already have been done, but not same version. we will remove and rebuild it."
                run rm -rf "$NATIVE_INSTALL_DIR"
            fi
        fi

        if [ -f "$NATIVE_INSTALL_DIR/version.txt" ] ; then
            note "build for native already have been done, skipped."
        else
            NATIVE_BUILDIN_DIR="$PACKAGE_INSTALLING_TOP_DIR/native"

            [ "$PACKAGE_BUILD_IN_BSCRIPT_DIR" = yes ] || {
                run install -d "$NATIVE_BUILDIN_DIR"
                run cd         "$NATIVE_BUILDIN_DIR"
            }

            for TOOL in PKG_CONFIG MESON CMAKE GMAKE NINJA
            do
                printf "%19s = %s\n" "$TOOL" "$(eval echo \$$TOOL)"
            done

            echo

            for TOOL in $(list_tools_in_the_toolchain | tr a-z A-Z)
            do
                eval export "$TOOL=\"\$${TOOL}_FOR_BUILD\""
                printf "%19s = %s\n" "$TOOL" "$(eval echo \$$TOOL)"
            done

            for FLAG in $(list_flags_used_by_tools_in_the_toolchain)
            do
                eval export "$FLAG=\"\$${FLAG}_FOR_BUILD\""
                printf "\n%19s = " "$FLAG"
                FIRST=yes
                for item in $(eval echo \$$FLAG | tr ':' ' ')
                do
                    if [ "$FIRST" = yes ] ; then
                        FIRST=no
                        printf '%s\n' "$item"
                    else
                        printf '%s\n' "                      $item"
                    fi
                done
            done

            echo

            printf "\n%19s = " PATH
            FIRST=yes
            for item in $(printf '%s\n' "$PATH" | tr ' ' '|' | tr ':' ' ')
            do
                if [ "$FIRST" = yes ] ; then
                    FIRST=no
                    printf '%s\n' "$item" | tr '|' ' '
                else
                    printf '%s\n' "                      $item" | tr '|' ' '
                fi
            done

            cat <<EOF

        BUILD_NJOBS = $BUILD_NJOBS

PACKAGE_INSTALLING_TOP_DIR = $PACKAGE_INSTALLING_TOP_DIR
PACKAGE_INSTALLING_SRC_DIR = $PACKAGE_INSTALLING_SRC_DIR
PACKAGE_INSTALLING_BST_DIR = $PACKAGE_INSTALLING_BST_DIR

 NATIVE_BUILDIN_DIR = $NATIVE_BUILDIN_DIR
 NATIVE_INSTALL_DIR = $NATIVE_INSTALL_DIR

                PWD = $PWD

EOF

            run build0

            if [ -d "$NATIVE_INSTALL_DIR" ] ; then
                printf '%s\n' "$PACKAGE_VERSION" > "$NATIVE_INSTALL_DIR/version.txt"
            fi

            if [ -d "$NATIVE_INSTALL_DIR/bin" ] ; then
                export PATH="$NATIVE_INSTALL_DIR/bin:$PATH"
            fi
        fi
    else
        note "no build0  function defined in formula, skipped."
    fi

    if [ "$CCACHE_ENABLED" = yes ] ; then
        ccache -s > "$PACKAGE_INSTALLING_TOP_DIR/ccache-s.txt"
    fi

    step "do some preparation works"
    if command -v prepare > /dev/null ; then
        if [ "$PWD" != "$PACKAGE_INSTALLING_BST_DIR" ] ; then
            run cd "$PACKAGE_INSTALLING_BST_DIR"
        fi
        prepare "$1"
    else
        case $PACKAGE_BUILD_SYSTEM in
            autogen)
                note "no prepare function defined in formula."
                run NOCONFIGURE=yes ./autogen.sh
                ;;
            autotools)
                note "no prepare function defined in formula."
                run autoreconf -ivf
                ;;
            *)  note "no prepare function defined in formula, skipped."
        esac
    fi

    for TARGET_ITEM in $TARGET_LIST
    do
        TARGET_INDEX=$(expr ${TARGET_INDEX-0} + 1)
        step "${COLOR_PURPLE}Installing ${COLOR_OFF}${COLOR_GREEN}$1 $TARGET_ITEM${COLOR_OFF}"
        (__install_the_given_package_for_the_given_target "$1" "$TARGET_ITEM")
    done

    [ "$DRYRUN" = yes ] && exit

    if [ -n "$PACKAGE_DEP_PKG" ] ; then
        step "record dependencies files."
        for file in $PACKAGE_DEPENDENCY_GRAPH_FILEPATH_DOT $PACKAGE_DEPENDENCY_GRAPH_FILEPATH_TXT $PACKAGE_DEPENDENCY_GRAPH_FILEPATH_PNG
        do
            if [    -f "$file" ] ; then
                run cp "$file" "$PACKAGE_INSTALL_DIR"
            fi
        done
    fi

    step "install LICENSEs"
    if [        -f "$PACKAGE_INSTALLING_TOP_DIR/LICENSE1" ] ; then
        if [    -f "$PACKAGE_INSTALLING_TOP_DIR/LICENSE2" ] ; then
            run mv "$PACKAGE_INSTALLING_TOP_DIR/LICENSE[1-9]" "$PACKAGE_INSTALL_DIR"
        else
            run mv "$PACKAGE_INSTALLING_TOP_DIR/LICENSE1"     "$PACKAGE_INSTALL_DIR/LICENSE"
        fi
    else
        warn "no LICENSEs, skipped."
    fi

    if [ -f "$PACKAGE_INSTALLING_SRC_DIR/AUTHORS" ] ; then
        step "install AUTHORS"
        run cp -r "$PACKAGE_INSTALLING_SRC_DIR/AUTHORS" "$PACKAGE_INSTALL_DIR"
    fi

    step "record installed abis"
    run cp "$PACKAGE_INSTALLING_TOP_DIR/installed-abis" "$PACKAGE_INSTALL_DIR/installed-abis"

    step "record installed metadata"
    __record_installed_metadata_of_the_given_package "$1"

    step "record installed files"
    __record_installed_files_of_the_given_package "$1"

    if [ "$CCACHE_ENABLED" = yes ] ; then
        step "show ccache statistics summary"
        note "Before Build:"
        run  cat "$PACKAGE_INSTALLING_TOP_DIR/ccache-s.txt"
        note "After  Build:"
        run  ccache -s
    fi

    if [ "$KEEP_INSTALLING_DIR" != yes ] ; then
        step "delete the installing directory."
        run rm -rf "$PACKAGE_INSTALLING_TOP_DIR"
    fi

    step "list installed files in a tree-like format"
    __tree_the_given_installed_package "$1" "$TARGET_OS_VERS" $TREE_ARGS

    echo
    success "$1 installed successfully."
}

__install_the_given_package_for_the_given_target() {
    unset STEP2_NUM

    step2 "config variables for ${COLOR_GREEN}$@${COLOR_OFF}"
    __config_variables_for_the_given_target $@

    step2 "printf variables for ${COLOR_GREEN}$@${COLOR_OFF}"
    __printf_variables_for_the_given_target $@

    step2 "create needed directories for ${COLOR_GREEN}$@${COLOR_OFF}"
    run install -d "$TARGET_WORKING_DIR/build"
    run install -d "$TARGET_WORKING_DIR/include"
    run install -d "$TARGET_WORKING_DIR/lib"
    run install -d "$TARGET_WORKING_DIR/bin"

    step2 "create linker script"
    # https://developer.android.com/ndk/guides/stable_apis#c_library
    # Note that on Android, unlike Linux, there are no separate libpthread or librt libraries.
    # That functionality is included directly in libc, which does not need to be explicitly linked against.
    run "echo '!<arch>' > '$TARGET_WORKING_DIR/lib/libpthread.a'"
    run "echo '!<arch>' > '$TARGET_WORKING_DIR/lib/librt.a'"

    if [ "$ANDROID_NDK_VERS_MAJOR" -ge 23 ] ; then
        # https://github.com/rust-windowing/android-ndk-rs/issues/149
        if [ "$TARGET_OS_ARCH" = "x86_64" ] ; then
            LIBCLANG_RT_BUILTINS_FILEPATH="$("$CC" -print-libgcc-file-name)"
        fi
        run "echo 'INPUT($LIBCLANG_RT_BUILTINS_FILEPATH -l:libunwind.a)' > '$TARGET_WORKING_DIR/lib/libgcc.a'"
    fi

    if [ "$PACKAGE_INSTALL_STATICALLY_LINKED_EXECUTABLE" = yes ] ; then
        run "echo 'INPUT($SYSTEM_LIBRARY_DIR/libc.a)'  > '$TARGET_WORKING_DIR/lib/libc.a'"
        run "echo 'INPUT($SYSTEM_LIBRARY_DIR/libm.a)'  > '$TARGET_WORKING_DIR/lib/libm.a'"
        run "echo 'INPUT($SYSTEM_LIBRARY_DIR/libz.a)'  > '$TARGET_WORKING_DIR/lib/libz.a'"
        run "echo 'INPUT($SYSTEM_LIBRARY_DIR/libdl.a)' > '$TARGET_WORKING_DIR/lib/libdl.a'"
    fi

    step2 "create symbolic link for CC and CXX to use ccache"
    if [ "$CCACHE_ENABLED" = yes ] ; then
        if [ -z "$CCACHE" ] ; then
            die "ccache is not installed."
        fi
        run ln -sf "$CCACHE" "$TARGET_WORKING_DIR/bin/$(basename "$CC")"
        run ln -sf "$CCACHE" "$TARGET_WORKING_DIR/bin/$(basename "$CXX")"
        run export PATH="'$TARGET_WORKING_DIR/bin:$PATH'"
    else
        note "ccache is disabled, skipped."
    fi

    [ -n "$RECURSIVE_DEPENDENT_PACKAGES" ] && {
        step2 "create symbolic links for dependency libs"
        case $LINK_TYPE in
            static-only|static-prefered) LINK_LIBRARY_TYPE=a  ;;
            shared-only|shared-prefered) LINK_LIBRARY_TYPE=so ;;
        esac

        for DEPENDENCY_PACKAGE_NAME in $RECURSIVE_DEPENDENT_PACKAGES
        do
            DEPENDENCY_PACKAGE_TARGET_INSTALLED_LIBRARY_DIR="$MY_INSTALL_DIR/android/$TARGET_OS_VERS/$DEPENDENCY_PACKAGE_NAME/$TARGET_OS_ABI/lib"
            if [ -d "$DEPENDENCY_PACKAGE_TARGET_INSTALLED_LIBRARY_DIR" ] ; then
                cd  "$DEPENDENCY_PACKAGE_TARGET_INSTALLED_LIBRARY_DIR"
                for item in $(find . -maxdepth 1 -mindepth 1 -name "lib*.$LINK_LIBRARY_TYPE" -exec basename {} \;)
                do
                    if [ -e "$TARGET_WORKING_DIR/lib/$item" ] ; then
                        continue
                    else
                        ln -sf $DEPENDENCY_PACKAGE_TARGET_INSTALLED_LIBRARY_DIR/$item $TARGET_WORKING_DIR/lib/$item
                    fi
                done
            fi
        done

        unset LINK_LIBRARY_TYPE
    }

    if [ "$PACKAGE_BUILD_IN_BSCRIPT_DIR" = yes ] ; then
        if [ "$PWD" != "$PACKAGE_INSTALLING_BST_DIR" ] ; then
            run cd "$PACKAGE_INSTALLING_BST_DIR"
        fi
    else
        run cd "$TARGET_BUILDIN_DIR"
    fi

    [ "$DRYRUN" = yes ] && {
        [ -z "$SHELL" ] && SHELL=$(command -v zsh || command -v bash || command -v sh)
        [ -z "$SHELL" ] && SHELL=sh
        exec "$SHELL"
    }

    if [ -d        "$TARGET_INSTALL_DIR" ] ; then
        run rm -rf "$TARGET_INSTALL_DIR"
    fi

    step2 "build for ${COLOR_GREEN}$@${COLOR_OFF}"

    if [ "$PACKAGE_BUILD_SYSTEM_CARGO" = yes ] ; then
        run rustup target add "$RUST_TARGET"
    fi

    if command -v build > /dev/null ; then
        build $@
    else
        case $PACKAGE_BUILD_SYSTEM in
            autogen)   configure ;;
            autotools) configure ;;
            configure) configure ;;
            cmake*)    cmakew ;;
            meson)     mesonw ;;
            ninja)     ninja clean && ninja && ninja install ;;
            gmake)     gmakew clean && gmakew && gmakew install ;;
            cargo)     cargow install ;;
            go)        gow ;;
        esac
    fi

    step2 "list installed for ${COLOR_GREEN}$@${COLOR_OFF}"
    run ls -l "$TARGET_INSTALL_DIR"

    step2 "install logs for ${COLOR_GREEN}$@${COLOR_OFF}"
    __install_logs_for_the_given_target $@

    step2 "adjust ELF files for ${COLOR_GREEN}$@${COLOR_OFF}"
    __adjust_elf_files_for_the_given_target $@

    if [ -d "$TARGET_INSTALL_DIR/lib" ] ; then
        step2 "adjust .la files for ${COLOR_GREEN}$@${COLOR_OFF}"
        __adjust_la_files_for_the_given_target $@

        step2 "adjust .pc files for ${COLOR_GREEN}$@${COLOR_OFF}"
        __adjust_pc_files_for_the_given_target $@

        step2 "install no versioning libraries for ${COLOR_GREEN}$@${COLOR_OFF}"

        TARGET_NOVERSIOING_LIBRARY_DIR="$TARGET_INSTALL_DIR/lib-no-versioning"

        run install -d "$TARGET_NOVERSIOING_LIBRARY_DIR/cmake/$PACKAGE_NAME"

        find "$TARGET_INSTALL_DIR/lib" -maxdepth 1 -mindepth 1 -name 'lib*.a'  -exec cp -v {} "$TARGET_NOVERSIOING_LIBRARY_DIR" \;
        find "$TARGET_INSTALL_DIR/lib" -maxdepth 1 -mindepth 1 -name 'lib*.so' -exec cp -v {} "$TARGET_NOVERSIOING_LIBRARY_DIR" \;

        for SO_FILE_PATH_HAVE_VERSION in $(find "$TARGET_INSTALL_DIR/lib" -maxdepth 1 -mindepth 1 -name 'lib*.so.*')
        do
            unset SO_FILE_NAME_NO_VERSION
            SO_FILE_NAME_NO_VERSION="$(basename "$SO_FILE_PATH_HAVE_VERSION" | sed 's/\(lib.*\.so\)\..*/\1/')"

            if [ ! -f "$TARGET_NOVERSIOING_LIBRARY_DIR/$SO_FILE_NAME_NO_VERSION" ] ; then
                run cp "$SO_FILE_PATH_HAVE_VERSION" "$TARGET_NOVERSIOING_LIBRARY_DIR/$SO_FILE_NAME_NO_VERSION"
            fi
        done

        cd "$TARGET_NOVERSIOING_LIBRARY_DIR"

        step2 "adjust no versioning .so files for ${COLOR_GREEN}$@${COLOR_OFF}"
        __adjust_no_versioning_so_files_for_the_given_target $@

        step2 "create cmake config files for ${COLOR_GREEN}$@${COLOR_OFF}"
        __create_cmake_config_files_for_the_given_target $@
    fi

    run "echo '$TARGET_OS_ABI' >> $PACKAGE_INSTALLING_TOP_DIR/installed-abis"
}

# http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#dynamic_section
__adjust_no_versioning_so_files_for_the_given_target() {
    for sofile in $(find . -maxdepth 1 -mindepth 1 -name 'lib*.so' -exec basename {} \;)
    do
        DT_SONAME="$(patchelf --print-soname "$sofile")"

        case $DT_SONAME in
            '') ;;
            lib*.so)
                ;;
            lib*.so.*)
                run patchelf --set-soname "$sofile" "$sofile"
                ;;
            *)  die "unexpected so file: $sofile\n    DT_SONAME: $DT_SONAME"
        esac

        for DT_NEEDED in $(patchelf --print-needed "$sofile")
        do
            case $DT_NEEDED in
                lib*.so)
                    ;;
                lib*.so.*)
                    unset NEW_DT_NEEDED
                    NEW_DT_NEEDED="$(printf '%s\n' "$DT_NEEDED" | sed 's|\(.*\.so\).*|\1|g')"
                    run patchelf --replace-needed  "$DT_NEEDED" "$NEW_DT_NEEDED" "$sofile"
                    ;;
                */*)
                    unset NEW_DT_NEEDED
                    NEW_DT_NEEDED="$(basename "$DT_NEEDED")"
                    case $NEW_DT_NEEDED in
                        lib*.so)
                            run patchelf --replace-needed  "$DT_NEEDED" "$NEW_DT_NEEDED" "$sofile"
                            ;;
                        lib*.so.*)
                            NEW_DT_NEEDED="$(printf '%s\n' "$NEW_DT_NEEDED" | sed 's|\(.*\.so\).*|\1|g')"
                            run patchelf --replace-needed  "$DT_NEEDED" "$NEW_DT_NEEDED" "$sofile"
                            ;;
                        *)  die "unexpected so file: $sofile\n    DT_NEEDED: $DT_NEEDED"
                    esac
                    ;;
                *)  die "unexpected so file: $sofile\n    DT_NEEDED: $DT_NEEDED"
            esac
        done
    done
}

__create_cmake_config_files_for_the_given_target() {
    TARGET_CMAKE_CONFIG_FILEPATH="$TARGET_NOVERSIOING_LIBRARY_DIR/cmake/$PACKAGE_NAME/${PACKAGE_NAME}Config.cmake"

    cat > "$TARGET_CMAKE_CONFIG_FILEPATH" << EOF
# generated by ndk-pkg $MY_VERSION

get_filename_component(${PACKAGE_NAME}_INSTALL_DIR "\${CMAKE_CURRENT_LIST_DIR}/../../../" ABSOLUTE)

set(${PACKAGE_NAME}_INCLUDE_DIR "\${${PACKAGE_NAME}_INSTALL_DIR}/include")
set(${PACKAGE_NAME}_LIBRARY_DIR "\${${PACKAGE_NAME}_INSTALL_DIR}/lib-no-versioning")

EOF

    unset CMAKE_IMPORTED_TARGETS

    for libfilename in $(find . -maxdepth 1 -mindepth 1 -a \( -name 'lib*.a' -o -name 'lib*.so' \) -exec basename {} \;)
    do
        case $libfilename in
            lib*.a)  LIBRARY_TYPE=STATIC ;;
            lib*.so) LIBRARY_TYPE=SHARED ;;
            *)       die "unrecognized library filename: $libfilename"
        esac

        CMAKE_IMPORTED_TARGET="$PACKAGE_NAME::$libfilename"

        if [ -z "$CMAKE_IMPORTED_TARGETS" ] ; then
            CMAKE_IMPORTED_TARGETS="$CMAKE_IMPORTED_TARGET"
        else
            CMAKE_IMPORTED_TARGETS="$CMAKE_IMPORTED_TARGETS;$CMAKE_IMPORTED_TARGET"
        fi

        cat >> "$TARGET_CMAKE_CONFIG_FILEPATH" << EOF

if (NOT TARGET  $CMAKE_IMPORTED_TARGET)
    add_library($CMAKE_IMPORTED_TARGET STATIC IMPORTED)
    set_target_properties($CMAKE_IMPORTED_TARGET PROPERTIES
        IMPORTED_LOCATION             "\${${PACKAGE_NAME}_LIBRARY_DIR}/$libfilename"
        INTERFACE_INCLUDE_DIRECTORIES "\${${PACKAGE_NAME}_INCLUDE_DIR}"
    )
endif()
EOF
    done

    cat >> "$TARGET_CMAKE_CONFIG_FILEPATH" << EOF

set(${PACKAGE_NAME}_IMPORTED_TARGETS "$CMAKE_IMPORTED_TARGETS")
EOF

    cat > "$TARGET_NOVERSIOING_LIBRARY_DIR/cmake/$PACKAGE_NAME/${PACKAGE_NAME}ConfigVersion.cmake" << EOF
# generated by ndk-pkg $MY_VERSION
#
# https://cmake.org/cmake/help/latest/command/find_package.html#config-mode-version-selection

set(PACKAGE_VERSION $PACKAGE_VERSION)

if ("\${PACKAGE_VERSION}" VERSION_LESS "\${PACKAGE_FIND_VERSION}")
    set(PACKAGE_VERSION_COMPATIBLE FALSE)
else()
    set(PACKAGE_VERSION_COMPATIBLE TRUE)
    if ("\${PACKAGE_VERSION}" VERSION_EQUAL "\${PACKAGE_FIND_VERSION}")
        set(PACKAGE_VERSION_EXACT TRUE)
    endif()
endif()
EOF
}

__adjust_elf_files_for_the_given_target() {
    for x in bin sbin lib
    do
        if [ -d "$TARGET_INSTALL_DIR/$x" ] ; then
            for y in $(ls "$TARGET_INSTALL_DIR/$x")
            do
                FILEPATH="$TARGET_INSTALL_DIR/$x/$y"

                if [ -d "$FILEPATH" ] ; then
                    continue
                fi

                unset FILE_HEADER_EXPACT
                unset FILE_HEADER_ACTUAL

                FILE_HEADER_ACTUAL="$(hexdump -n 20 -v -e '1/1 "%02X" ""' "$FILEPATH")"

                # http://www.sco.com/developers/gabi/latest/ch4.eheader.html
                case $FILE_HEADER_ACTUAL in
                    7F454C46*)
                        unset ELF_TYPE

                        case $y in
                            *.o)    ELF_TYPE=01 ;;
                            *.so*)  ELF_TYPE=03 ;;
                            *)      ELF_TYPE="$(printf '%s\n' "$FILE_HEADER_ACTUAL" | cut -c33-34)"
                        esac

                        case $TARGET_OS_ABI in
                            armeabi-v7a) FILE_HEADER_EXPACT="7F454C46010101000000000000000000${ELF_TYPE}002800" ;;
                            arm64-v8a)   FILE_HEADER_EXPACT="7F454C46020101000000000000000000${ELF_TYPE}00B700" ;;
                            x86)         FILE_HEADER_EXPACT="7F454C46010101000000000000000000${ELF_TYPE}000300" ;;
                            x86_64)      FILE_HEADER_EXPACT="7F454C46020101000000000000000000${ELF_TYPE}003E00" ;;
                        esac

                        if [ "$FILE_HEADER_EXPACT" != "$FILE_HEADER_ACTUAL" ] ; then
                            die "ELF file header mismatch: $FILEPATH\n    expect : $FILE_HEADER_EXPACT\n    actual : $FILE_HEADER_ACTUAL"
                        fi

                        if [ "$x" = bin ] || [ "$x" = sbin ] ; then
                            if [ "$ELF_TYPE" = 03 ] ; then
                                # https://source.android.com/security/enhancements/enhancements50
                                # Android 5.0 and later only support position-independent executables (-fPIE)
                                if ! "$READELF" -d "$FILEPATH" | grep FLAGS_1 | grep -q PIE ; then
                                    die "invalid elf file: $FILEPATH. It is not Position Independent Executable."
                                fi

                                unset PT_INTERP
                                PT_INTERP="$(patchelf --print-interpreter "$FILEPATH")"

                                if [ -n "$PT_INTERP" ] && [ "$PT_INTERP" != "$DYNAMIC_LINKER_PATH" ] ; then
                                    die "ELF file PT_INTERP mismatch: $FILEPATH\n    expect : $DYNAMIC_LINKER_PATH\n    actual : $PT_INTERP"
                                fi
                            fi
                        fi

                        if [ "$BUILD_TYPE" = release ] ; then
                            run "$STRIP" $STRIP_ARG "$FILEPATH" || true
                        fi
                esac
            done
        fi
    done
}

__adjust_la_files_for_the_given_target() {
    [ -d "$TARGET_INSTALL_DIR/lib" ] || {
        note "no .la files installed, skipped"
        return 0
    }

    LA_FILES="$(find "$TARGET_INSTALL_DIR/lib" -name "*.la")"

    [ -z "$LA_FILES" ] && {
        note "no .la files installed, skipped"
        return 0
    }

    for lafile in $LA_FILES
    do
        sed_in_place 's|-lpthread||g'              "$lafile"
        sed_in_place 's|-Wl,--strip-debug||g'      "$lafile"
        sed_in_place "s|-L$MY_HOME_DIR[^' ]*||g"   "$lafile"
        sed_in_place "s|-L$SYSTEM_LIBRARY_DIR||g"  "$lafile"
        sed_in_place "s|--sysroot $SYSROOT||g"     "$lafile"
    done
}

__adjust_pc_files_for_the_given_target() {
    [ -d "$TARGET_INSTALL_DIR/lib/pkgconfig" ] || {
        note "no .pc files installed, skipped"
        return 0
    }

    PC_FILES="$(find "$TARGET_INSTALL_DIR/lib/pkgconfig" -name "*.pc")"

    [ -z "$PC_FILES" ] && {
        note "no .pc files installed, skipped"
        return 0
    }

    for pcfile in $PC_FILES
    do
        sed_in_place "s|$TARGET_INSTALL_DIR|\${pcfiledir}/../..|g" "$pcfile"
        sed_in_place 's|-lpthread||g'              "$pcfile"
        sed_in_place 's|-Wl,--strip-debug||g'      "$pcfile"
        sed_in_place "s|-L$MY_HOME_DIR[^' ]*||g"   "$pcfile"
        sed_in_place "s|-L$SYSTEM_LIBRARY_DIR||g"  "$pcfile"
        sed_in_place "s|--sysroot $SYSROOT||"      "$pcfile"

        if grep 'Libs.private:' "$pcfile" > /dev/null ; then
            LIBS_CONTENT=$(awk '/Libs:/{print}' "$pcfile")
            LIBS_PRIVATE_CONTENT=$(awk -F: '/Libs.private:/{print $2}' "$pcfile")
            sed_in_place "s|$LIBS_CONTENT|$LIBS_CONTENT$LIBS_PRIVATE_CONTENT|" "$pcfile"
            sed_in_place '/Libs.private/d' "$pcfile"
        fi
    done
}

__install_logs_for_the_given_target() {
    TARGET_LOG_DIR="$TARGET_INSTALL_DIR/share/log"

    for item in "$TARGET_BUILDIN_DIR" "$PACKAGE_INSTALLING_BST_DIR"
    do
        for item2 in 'config.log' 'compile_commands.json' 'install.log.txt'
        do
            if [ -f "$item/$item2" ] ; then
                if [ !          -d "$TARGET_LOG_DIR" ] ; then
                    run install -d "$TARGET_LOG_DIR"
                fi
                run install -m 644 "$item/$item2" "$TARGET_LOG_DIR"
            fi
        done
    done
}

install_incs() {
    while [ -n "$1" ]
    do
        unset X1
        unset X2
        X1=$(printf '%s\n' "$1" | cut -d: -f1)
        X2=$(printf '%s\n' "$1" | cut -d: -f2)

        if [ "$X1" = "$X2" ] ; then
            unset X2
        fi

        install -v -d         "$TARGET_INSTALL_DIR/include/$X2"
        install -v -m 644 $X1 "$TARGET_INSTALL_DIR/include/$X2"

        shift
    done
}

install_libs() {
    install -v -d "$TARGET_INSTALL_DIR/lib"
    for item in $@
    do
        case $item in
            *.a) install -v -m 644 $item "$TARGET_INSTALL_DIR/lib" ;;
            *)   install -v -m 755 $item "$TARGET_INSTALL_DIR/lib" ;;
        esac
    done
}

install_pcfs() {
    install -v -d        "$TARGET_INSTALL_DIR/lib/pkgconfig" &&
    install -v -m 644 $@ "$TARGET_INSTALL_DIR/lib/pkgconfig"
}

install_bins() {
    install -v -d        "$TARGET_INSTALL_DIR/bin" &&
    install -v -m 755 $@ "$TARGET_INSTALL_DIR/bin"
}

install_etcs() {
    install -v -d        "$TARGET_INSTALL_DIR/etc" &&
    install -v -m 644 $@ "$TARGET_INSTALL_DIR/etc"
}

install_mans() {
    for item in $@
    do
        unset NUMBER
        NUMBER=$(printf '%s\n' "$item" | cut -c ${#item}-${#item})
        case $NUMBER in
            [1-8]);;
            *)    die "$item: not a manpage."
        esac
        install -v -d           "$TARGET_INSTALL_DIR/share/man/man$NUMBER" &&
        install -v -m 644 $item "$TARGET_INSTALL_DIR/share/man/man$NUMBER"
    done
}

# install_completion <fish|bash|zsh> <COMMAND> <FILE-PATH>
  install_completion() {
    case $1 in
        bash)
            install -v -d          "$TARGET_INSTALL_DIR/share/bash/completions" &&
            install -v -m 644 "$3" "$TARGET_INSTALL_DIR/share/bash/completions/$2"
            ;;
        fish)
            install -v -d          "$TARGET_INSTALL_DIR/share/fish/vendor_completions.d" &&
            install -v -m 644 "$3" "$TARGET_INSTALL_DIR/share/fish/vendor_completions.d/$2.fish"
            ;;
        zsh)
            install -v -d          "$TARGET_INSTALL_DIR/share/zsh/site-functions" &&
            install -v -m 644 "$3" "$TARGET_INSTALL_DIR/share/zsh/site-functions/_$2"
            ;;
        *)  die "install_completion unsupported shell: $1"
    esac
}

install_pc_file() {
    install -v -d "$TARGET_INSTALL_DIR/lib/pkgconfig" &&
    cat >         "$TARGET_INSTALL_DIR/lib/pkgconfig/$1.pc"
}

# __show_infomation_of_all_available_packages [--json|--yaml|--shell]
  __show_infomation_of_all_available_packages() {
    case $1 in
        --json) __show_infomation_as_json__of_all_available_packages ;;
        --yaml) __show_infomation_as_yaml__of_all_available_packages ;;
        --shell)__show_infomation_as_shell_of_all_available_packages ;;
        '')     __show_infomation_as_mixed_of_all_available_packages ;;
        *)    die "__show_infomation_of_all_available_packages [--json|--yaml|--shell], unrecognized option: $1"
    esac
}

__show_infomation_as_mixed_of_all_available_packages() {
    FIRST=yes

    for PACKAGE in $(__list_available_packages)
    do
        if [ "$FIRST" = yes ] ; then
            FIRST=no
        else
            printf '%s\n' '========'
        fi
        __show_infomation_of_the_given_package "$PACKAGE"
    done
}

__show_infomation_as_json__of_all_available_packages() {
    printf '%s\n' '['

    FIRST=yes

    for PACKAGE in $(__list_available_packages)
    do
        if [ "$FIRST" = yes ] ; then
            FIRST=no
        else
            printf '%s\n' ','
        fi
        __show_infomation_as_json__of_the_given_package "$PACKAGE"
    done

    printf '%s\n' ']'
}

__show_infomation_as_yaml__of_all_available_packages() {
    FIRST=yes

    for PACKAGE in $(__list_available_packages)
    do
        if [ "$FIRST" = yes ] ; then
            FIRST=no
        else
            printf '%s\n' '---'
        fi
        __show_infomation_as_yaml__of_the_given_package "$PACKAGE"
    done
}

__show_infomation_as_shell_of_all_available_packages() {
    FIRST=yes

    for PACKAGE in $(__list_available_packages)
    do
        if [ "$FIRST" = yes ] ; then
            FIRST=no
        else
            printf '%s\n' '#---'
        fi
        __show_infomation_as_shell_of_the_given_package "$PACKAGE"
    done
}

# __show_infomation_as_json__of_the_given_package <PACKAGE-NAME>
  __show_infomation_as_json__of_the_given_package() {
    __load_formula_of_the_given_package "$1"

    handle_dependency required exe jq >&2

    if [ "$PACKAGE_BUILD_IN_PARALLEL" = yes ] ; then
        PARALLEL=true
    else
        PARALLEL=false
    fi

    jq  --null-input \
        --arg name "$PACKAGE_NAME" \
        --arg version "$PACKAGE_VERSION" \
        --arg summary "$PACKAGE_SUMMARY" \
        --arg webpage "$PACKAGE_WEBPAGE" \
        --arg license "$PACKAGE_LICENSE" \
        --arg git_url "$PACKAGE_GIT_URL" \
        --arg git_sha "$PACKAGE_GIT_SHA" \
        --arg git_tag "$PACKAGE_GIT_TAG" \
        --arg src_url "$PACKAGE_SRC_URL" \
        --arg src_sha "$PACKAGE_SRC_SHA" \
        --arg fix_url "$PACKAGE_FIX_URL" \
        --arg fix_sha "$PACKAGE_FIX_SHA" \
        --arg dep_cmd "$PACKAGE_DEP_CMD" \
        --arg dep_pym "$PACKAGE_DEP_PYM" \
        --arg dep_plm "$PACKAGE_DEP_PLM" \
        --arg dep_pkg "$PACKAGE_DEP_PKG" \
        --arg bsystem "$PACKAGE_BUILD_SYSTEM" \
        --arg binsrcd "$PACKAGE_BUILD_IN_BSCRIPT_DIR" \
        --arg sdk_api "$PACKAGE_SDK_API" \
        --arg parallel "$PARALLEL" \
        --arg cdefine "$PACKAGE_CDEFINE" \
        --arg ccflags "$PACKAGE_CCFLAGS" \
        --arg xxflags "$PACKAGE_XXFLAGS" \
        --arg ldflags "$PACKAGE_LDFLAGS" \
        --arg developer "$PACKAGE_DEVELOPER" \
'{
    "name":$name,
    "version":$version,
    "summary":$summary,
    "webpage":$webpage,
    "license":$license,
    "git": {
        "url":$git_url,
        "tag":$git_tag,
        "sha":$git_sha
    },
    "src": {
        "url":$src_url,
        "sha":$src_sha
    },
    "fix": {
        "url":$fix_url,
        "sha":$fix_sha
    },
    "dep": {
        "cmd":$dep_cmd,
        "pkg":$dep_pkg,
        "pym":$dep_pym,
        "plm":$dep_plm
    },
    "build": {
        "system":$bsystem,
        "ccflags":$ccflags,
        "cdefine":$cdefine,
        "xxflags":$xxflags,
        "ldflags":$ldflags,
        "binsrcd":$binsrcd,
        "parallel":$parallel
    },
    "sdk_api":$sdk_api,
    "developer":$developer
}'
}

# __show_infomation_as_yaml__of_the_given_package <PACKAGE-NAME>
  __show_infomation_as_yaml__of_the_given_package() {
    __load_formula_of_the_given_package "$1"

    cat <<EOF
name: $PACKAGE_NAME
version: $PACKAGE_VERSION
summary: $PACKAGE_SUMMARY
webpage: $PACKAGE_WEBPAGE
license: $PACKAGE_LICENSE

git:
    url: $PACKAGE_GIT_URL
    sha: $PACKAGE_GIT_SHA
    tag: $PACKAGE_GIT_TAG

src:
    url: $PACKAGE_SRC_URL
    sha: $PACKAGE_SRC_SHA

fix:
    url: $PACKAGE_FIX_URL
    sha: $PACKAGE_FIX_SHA

dep:
    cmd: $PACKAGE_DEP_CMD
    pym: $PACKAGE_DEP_PYM
    plm: $PACKAGE_DEP_PLM
    pkg: $PACKAGE_DEP_PKG

build:
    system: $PACKAGE_BUILD_SYSTEM
    binsrcd: $PACKAGE_BUILD_IN_BSCRIPT_DIR
    cdefine: $PACKAGE_CDEFINE
    ccflags: $PACKAGE_CCFLAGS
    xxflags: $PACKAGE_XXFLAGS
    ldflags: $PACKAGE_LDFLAGS
    parallel: $PARALLEL

sdk_api: $PACKAGE_SDK_API

developer: $PACKAGE_DEVELOPER
EOF
}

# __show_infomation_as_shell_of_the_given_package <PACKAGE-NAME>
  __show_infomation_as_shell_of_the_given_package() {
    __load_formula_of_the_given_package "$1"

    while read KEY
    do
        printf "%s='%s'\n" "${PACKAGE_NAME_UPPERCASE_UNDERSCORE}_${KEY}" "$(eval echo \$$KEY)"
    done <<EOF
PACKAGE_NAME
PACKAGE_SUMMARY
PACKAGE_WEBPAGE
PACKAGE_GIT_URL
PACKAGE_GIT_SHA
PACKAGE_GIT_TAG
PACKAGE_SVN_URL
PACKAGE_SRC_URL
PACKAGE_SRC_SHA
PACKAGE_SRC_NAME
PACKAGE_SRC_PATH
PACKAGE_SRC_TYPE
PACKAGE_FIX_URL
PACKAGE_FIX_SHA
PACKAGE_FIX_NAME
PACKAGE_FIX_PATH
PACKAGE_FIX_TYPE
PACKAGE_VERSION
PACKAGE_VERSION_MAJOR
PACKAGE_VERSION_MINOR
PACKAGE_VERSION_PATCH
PACKAGE_VERSION_TWEAK
PACKAGE_DEVELOPER
PACKAGE_LICENSE
PACKAGE_BSCRIPT
PACKAGE_BSYSTEM
PACKAGE_BINBSTD
PACKAGE_BUILD_SYSTEM
PACKAGE_BUILD_SYSTEM_GO
PACKAGE_BUILD_SYSTEM_RAKE
PACKAGE_BUILD_SYSTEM_NINJA
PACKAGE_BUILD_SYSTEM_GMAKE
PACKAGE_BUILD_SYSTEM_CMAKE
PACKAGE_BUILD_SYSTEM_XMAKE
PACKAGE_BUILD_SYSTEM_MESON
PACKAGE_BUILD_SYSTEM_CARGO
PACKAGE_BUILD_SYSTEM_AUTOGENSH
PACKAGE_BUILD_SYSTEM_AUTOTOOLS
PACKAGE_BUILD_SYSTEM_CONFIGURE
PACKAGE_BUILD_SYSTEM_NDK_BUILD
PACKAGE_BUILD_IN_BSCRIPT_DIR
PACKAGE_BUILD_IN_PARALLEL
PACKAGE_DEP_CMD
PACKAGE_DEP_PYM
PACKAGE_DEP_PLM
PACKAGE_DEP_PKG
PACKAGE_CDEFINE
PACKAGE_CCFLAGS
PACKAGE_XXFLAGS
PACKAGE_LDFLAGS
PACKAGE_FORMULA_FILEPATH
PACKAGE_SDK_API
EOF
}

# __show_infomation_of_the_given_package <PACKAGE-NAME> [OPTIONS]
#
# __show_infomation_of_the_given_package @all
# __show_infomation_of_the_given_package @all --json
# __show_infomation_of_the_given_package @all --yaml
# __show_infomation_of_the_given_package @all --shell
#
# __show_infomation_of_the_given_package curl
# __show_infomation_of_the_given_package curl --json
# __show_infomation_of_the_given_package curl --yaml
# __show_infomation_of_the_given_package curl --shell
#
# __show_infomation_of_the_given_package curl version
# __show_infomation_of_the_given_package curl webpage
  __show_infomation_of_the_given_package() {
    [ -z "$1" ] && {
        error "__show_infomation_of_the_given_package <PACKAGE-NAME> [ARGUMENTS], <PACKAGE-NAME> is not given."
        return 1
    }

    case $1 in
        @all) shift ; __show_infomation_of_all_available_packages $@ ; return $?
    esac

    unset SHOW_INFOMATION_ARGS
    unset MIN_SDK_API_LEVEL

    for arg in $@
    do
        case $arg in
            "$1")
                ;;
            -x|--xtrace)
                ;;
            --min-sdk-api-level=*)
                MIN_SDK_API_LEVEL=$(getvalue "$arg")
                is_integer "$MIN_SDK_API_LEVEL" || die "--min-sdk-api-level=<VALUE>, <VALUE> must be a integer."
                ;;
            *)  if [ -z "$SHOW_INFOMATION_ARGS" ] ; then
                    SHOW_INFOMATION_ARGS="$arg"
                else
                    SHOW_INFOMATION_ARGS="$SHOW_INFOMATION_ARGS $arg"
                fi
        esac
    done

    case $SHOW_INFOMATION_ARGS in
        --json)
            __show_infomation_as_json__of_the_given_package "$1"
            ;;
        --yaml)
            __show_infomation_as_yaml__of_the_given_package "$1"
            ;;
        --shell)
            __show_infomation_as_shell_of_the_given_package "$1"
            ;;
        formula)
            __path_of_formula_of_the_given_package "$1"
            ;;
        installed-dir)
            if is_package_installed "$1" "$MIN_SDK_API_LEVEL" ; then
                printf '%s\n' "$MY_INSTALL_DIR/android/$MIN_SDK_API_LEVEL/$1"
            else
                error "package [$1] is not installed."
                return 1
            fi
            ;;
        installed-abis)
            if is_package_installed "$1" "$MIN_SDK_API_LEVEL" ; then
                cat "$MY_INSTALL_DIR/android/$MIN_SDK_API_LEVEL/$1/installed-abis"
            else
                error "package [$1] is not installed."
                return 1
            fi
            ;;
        installed-metadata-raw)
            if is_package_installed "$1" "$MIN_SDK_API_LEVEL" ; then
                cat "$MY_INSTALL_DIR/$1/android/$MIN_SDK_API_LEVEL/installed-metadata"
            else
                error "package [$1] is not installed."
                return 1
            fi
            ;;
        installed-metadata-json)
            if is_package_installed "$1" "$MIN_SDK_API_LEVEL" ; then
                cat "$MY_INSTALL_DIR/$1/android/$MIN_SDK_API_LEVEL/installed-metadata"
            else
                error "package [$1] is not installed."
                return 1
            fi
            ;;
        installed-files)
            if is_package_installed "$1" "$MIN_SDK_API_LEVEL" ; then
                cat "$MY_INSTALL_DIR/android/$MIN_SDK_API_LEVEL/$1/installed-files"
            else
                error "package [$1] is not installed."
                return 1
            fi
            ;;
        installed-datetime-unix)
            __load_installed_metadata_of_the_given_package "$1" "$MIN_SDK_API_LEVEL"
            printf '%s\n' "$INSTALLED_TIMESTAMP_UNIX"
            ;;
        installed-datetime-formatted)
            __load_installed_metadata_of_the_given_package "$1" "$MIN_SDK_API_LEVEL"
            format_unix_timestamp "$INSTALLED_TIMESTAMP_UNIX" '+%Y-%m-%d %H:%M:%S'
            ;;
        installed-pkg-version)
            __load_installed_metadata_of_the_given_package "$1" "$MIN_SDK_API_LEVEL"
            printf '%s\n' "$INSTALLED_PACKAGE_VERSION"
            ;;
        '') __show_infomation_as_mixed_of_the_given_package $@
            ;;
        *)  __load_formula_of_the_given_package "$1"
            __PACKAGE_GET__KEY__="$(printf '%s\n' "$2" | tr '+-.' '_' | tr a-z A-Z)"
            eval echo \$PACKAGE_$__PACKAGE_GET__KEY__
    esac
}

# __show_infomation_as_mixed_of_the_given_package <PACKAGE-NAME>
  __show_infomation_as_mixed_of_the_given_package() {
    __load_formula_of_the_given_package "$1"

    cat <<EOF
name    : $PACKAGE_NAME
version : $PACKAGE_VERSION
summary : $PACKAGE_SUMMARY
webpage : $PACKAGE_WEBPAGE
src.url : $PACKAGE_SRC_URL
src.path: $PACKAGE_SRC_PATH
depends : $PACKAGE_DEP_PKG
EOF

    unset INSTALLED_API_LEVELS

    if [ -d "$MY_INSTALL_DIR/android" ] ; then
         cd "$MY_INSTALL_DIR/android" >/dev/null
    else
        return 0
    fi

    for item in $(ls)
    do
        case $item in
            [1-9][0-9])
                is_package_installed "$1" "$item" && INSTALLED_API_LEVELS="$INSTALLED_API_LEVELS $item"
        esac
    done

    for MIN_SDK_API_LEVEL in $INSTALLED_API_LEVELS
    do
        __load_installed_metadata_of_the_given_package "$1" "$MIN_SDK_API_LEVEL" || return 1

        printf "installed:\n    android-$MIN_SDK_API_LEVEL:\n"

        unset INSTALLED_ABIS
        unset INSTALLED_ABIS_LENGTH

        INSTALLED_ABIS=$(cat "$PACKAGE_INSTALLED_DIR/installed-abis")
        INSTALLED_ABIS_LENGTH=$(list_length $INSTALLED_ABIS)

        MAX=0
        for ABI in $INSTALLED_ABIS
        do
            ABI_PATH="$PACKAGE_INSTALLED_DIR/$ABI"
            ABI_PATH_LENGTH="${#ABI_PATH}"
            if [ "$ABI_PATH_LENGTH" -gt "$MAX" ] ; then
                MAX=$ABI_PATH_LENGTH
            fi
        done

        for ABI in '' $INSTALLED_ABIS
        do
            ABI_PATH="$PACKAGE_INSTALLED_DIR/$ABI"

            unset ABI_SIZE
            ABI_SIZE="$(du -sh "$ABI_PATH" | cut -f1)"

            printf "        - %-${MAX}s %s\n" "$ABI_PATH" "$ABI_SIZE"
        done

        cat <<EOF
        installed at : $(format_unix_timestamp $INSTALLED_TIMESTAMP_UNIX '+%Y-%m-%d %H:%M:%S') CST
        pkg-version  : $INSTALLED_PACKAGE_VERSION
        build using  : $BUILD_USE_TOOLCHAIN_NAME $BUILD_USE_TOOLCHAIN_VERS
EOF
    done
}

__record_installed_files_of_the_given_package() {
    if [ -z "$2" ] ; then
        INSTALLED_FILES_FILEPATH="$PACKAGE_INSTALL_DIR/installed-files"
        printf '%s\n' "-- Installing: $INSTALLED_FILES_FILEPATH"

        touch "$INSTALLED_FILES_FILEPATH"
        return 0

        # TODO
        exec 7> "$INSTALLED_FILES_FILEPATH"

        __record_installed_files_of_the_given_package "$1" "$PACKAGE_INSTALL_DIR"

        exec 7>&-

        sed_in_place "s|$PACKAGE_INSTALL_DIR/||" "$INSTALLED_FILES_FILEPATH"
    else
        for file in $(ls $2)
        do
            file="$2/$file"
            if [ -d "$file" ] ; then
                __record_installed_files_of_the_given_package "$1" "$file"
            else
                printf '%s %s\n' $(md5sum "$file") "$file" >&7
            fi
        done
    fi
}

# __record_installed_metadata_of_the_given_package <PACKAGE-NAME>
  __record_installed_metadata_of_the_given_package() {
    [ -z "$1" ] && {
        error "__record_installed_metadata_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is not given."
        return 1
    }

    INSTALLED_METADATA_FILEPATH="$PACKAGE_INSTALL_DIR/installed-metadata"

    printf '%b\n' "-- Installing: $INSTALLED_METADATA_FILEPATH"

    cat > "$INSTALLED_METADATA_FILEPATH" <<EOF
#This file is automatically generated by ndk-pkg.
#Please do not manually modify this file.

INSTALLED_BY_NDK_PKG_VERSION='$MY_VERSION'

INSTALLED_TIMESTAMP_UNIX='$TIMESTAMP_UNIX'

INSTALLED_PACKAGE_NAME='$PACKAGE_NAME'

INSTALLED_PACKAGE_VERSION='$PACKAGE_VERSION'
INSTALLED_PACKAGE_SUMMARY='$PACKAGE_SUMMARY'
INSTALLED_PACKAGE_WEBPAGE='$PACKAGE_WEBPAGE'
INSTALLED_PACKAGE_LICENSE='$PACKAGE_LICENSE'

INSTALLED_PACKAGE_DEVELOPER='$PACKAGE_DEVELOPER'

INSTALLED_PACKAGE_GIT_URL='$PACKAGE_GIT_URL'
INSTALLED_PACKAGE_GIT_SHA='$PACKAGE_GIT_SHA'
INSTALLED_PACKAGE_GIT_TAG='$PACKAGE_GIT_TAG'

INSTALLED_PACKAGE_SVN_URL='$PACKAGE_SVN_URL'

INSTALLED_PACKAGE_SRC_URL='$PACKAGE_SRC_URL'
INSTALLED_PACKAGE_SRC_SHA='$PACKAGE_SRC_SHA'

INSTALLED_PACKAGE_FIX_URL='$PACKAGE_FIX_URL'
INSTALLED_PACKAGE_FIX_SHA='$PACKAGE_FIX_SHA'

INSTALLED_PACKAGE_DEP_PKG='$PACKAGE_DEP_PKG'
INSTALLED_PACKAGE_DEP_CMD='$PACKAGE_DEP_CMD'
INSTALLED_PACKAGE_DEP_PYM='$PACKAGE_DEP_PYM'
INSTALLED_PACKAGE_DEP_PLM='$PACKAGE_DEP_PLM'

INSTALLED_PACKAGE_SDK_API='$TARGET_OS_VERS'

BUILD_USE_TOOLCHAIN_NAME='$TOOLCHAIN_NAME'
BUILD_USE_TOOLCHAIN_VERS='$TOOLCHAIN_VERS'
BUILD_USE_TOOLCHAIN_VERS_MAJOR='$TOOLCHAIN_VERS_MAJOR'
EOF
}

# __load_installed_metadata_of_the_given_package <PACKAGE-NAME> <MIN-SDK-API-LEVEL>
  __load_installed_metadata_of_the_given_package() {
    [ -z "$1" ] && {
        error "__load_installed_metadata_of_the_given_package <PACKAGE-NAME> <MIN-SDK-API-LEVEL>, <PACKAGE-NAME> is not given."
        return 1
    }

    [ -z "$2" ] && {
        error "__load_installed_metadata_of_the_given_package <PACKAGE-NAME> <MIN-SDK-API-LEVEL>, <MIN-SDK-API-LEVEL> is not given."
        return 1
    }

    is_package_installed "$1" "$2" || {
        error "package [$1] is not installed."
        return 1
    }

    unset INSTALLED_BY_NDK_PKG_VERSION

    unset INSTALLED_TIMESTAMP_UNIX

    unset INSTALLED_PACKAGE_NAME
    unset INSTALLED_PACKAGE_VERSION
    unset INSTALLED_PACKAGE_SUMMARY
    unset INSTALLED_PACKAGE_WEBPAGE
    unset INSTALLED_PACKAGE_LICENSE
    unset INSTALLED_PACKAGE_DEVELOPER

    unset INSTALLED_PACKAGE_GIT_URL
    unset INSTALLED_PACKAGE_GIT_SHA
    unset INSTALLED_PACKAGE_GIT_TAG

    unset INSTALLED_PACKAGE_SVN_URL

    unset INSTALLED_PACKAGE_SRC_URL
    unset INSTALLED_PACKAGE_SRC_SHA

    unset INSTALLED_PACKAGE_FIX_URL
    unset INSTALLED_PACKAGE_FIX_SHA

    unset INSTALLED_PACKAGE_DEP_PKG
    unset INSTALLED_PACKAGE_DEP_CMD
    unset INSTALLED_PACKAGE_DEP_PYM
    unset INSTALLED_PACKAGE_DEP_PLM

    unset INSTALLED_PACKAGE_BUILD_SYSTEM

    unset INSTALLED_PACKAGE_SDK_API

    unset BUILD_USE_TOOLCHAIN_NAME
    unset BUILD_USE_TOOLCHAIN_VERS
    unset BUILD_USE_TOOLCHAIN_VERS_MAJOR

    PACKAGE_INSTALLED_DIR="$MY_INSTALL_DIR/android/$2/$1"

    INSTALLED_METADATA_FILEPATH="$PACKAGE_INSTALLED_DIR/installed-metadata"

    . "$INSTALLED_METADATA_FILEPATH" || return 1

    if [ -z "$INSTALLED_BY_NDK_PKG_VERSION" ] ; then
        error "$INSTALLED_METADATA_FILEPATH is broken. value of INSTALLED_BY_NDK_PKG_VERSION must not be empty."
        return 1
    fi

    if [ -z "$INSTALLED_TIMESTAMP_UNIX" ] ; then
        error "$INSTALLED_METADATA_FILEPATH is broken. value of INSTALLED_TIMESTAMP_UNIX must not be empty."
        return 1
    fi

    if [ -z "$INSTALLED_PACKAGE_NAME" ] ; then
        error "$INSTALLED_METADATA_FILEPATH is broken. value of INSTALLED_PACKAGE_NAME must not be empty."
        return 1
    fi

    if [ -z "$INSTALLED_PACKAGE_VERSION" ] ; then
        error "$INSTALLED_METADATA_FILEPATH is broken. value of INSTALLED_PACKAGE_VERSION must not be empty."
        return 1
    fi

    if [ -z "$INSTALLED_PACKAGE_SUMMARY" ] ; then
        error "$INSTALLED_METADATA_FILEPATH is broken. value of INSTALLED_PACKAGE_SUMMARY must not be empty."
        return 1
    fi

    if [ -z "$INSTALLED_PACKAGE_WEBPAGE" ] ; then
        error "$INSTALLED_METADATA_FILEPATH is broken. value of INSTALLED_PACKAGE_WEBPAGE must not be empty."
        return 1
    fi

    if [ "$INSTALLED_PACKAGE_NAME" != "$1" ] ; then
        error "$INSTALLED_METADATA_FILEPATH is broken. INSTALLED_PACKAGE_NAME mismatch.\n    Actually: $INSTALLED_PACKAGE_NAME\n    Expected: $1"
        return 1
    fi

    if [ "${#INSTALLED_TIMESTAMP_UNIX}" -ne 10 ] ; then
        error "$INSTALLED_METADATA_FILEPATH is broken. length of \$INSTALLED_TIMESTAMP_UNIX must be 10."
        return 1
    fi

    is_integer "$INSTALLED_PACKAGE_SDK_API" || {
        error "$INSTALLED_METADATA_FILEPATH is broken. value of INSTALLED_PACKAGE_SDK_API must be a integer."
        return 1
    }

    is_integer "$BUILD_USE_TOOLCHAIN_VERS_MAJOR" || {
        error "$INSTALLED_METADATA_FILEPATH is broken. value of BUILD_USE_TOOLCHAIN_VERS_MAJOR must be a integer."
        return 1
    }
}

# __config_variables_for_the_given_target <PACKAGE-NAME> <TARGET>
# __config_variables_for_the_given_target      curl       x86_64
__config_variables_for_the_given_target() {
    TARGET_OS_KIND=linux
    TARGET_OS_TYPE=android
    TARGET_OS_NAME=Android
    TARGET_OS_ABI=$2
    TARGET_OS_ARCH=$(print_target_arch_by_abi "$TARGET_OS_ABI")

    TARGET_TRIPLE=$(print_target_triple_by_arch "$TARGET_OS_ARCH")

    TARGET_TRIPLE2=$(printf '%s\n' "$TARGET_TRIPLE" | sed 's/armv7a/arm/')

    case $TARGET_OS_ARCH in
        i686|armv7a)
            TARGET_OS_BIT=32
            DYNAMIC_LINKER_PATH='/system/bin/linker'
            ;;
        x86_64|aarch64)
            TARGET_OS_BIT=64
            DYNAMIC_LINKER_PATH='/system/bin/linker64'
            ;;
    esac

    for tool in $(list_tools_in_the_toolchain)
    do
        if [ "$tool" = 'cpp' ] ; then
            CPP="$CC -E"
        else
            eval $(printf '%s\n' "$tool" | tr a-z A-Z)=$(path_of_tool_in_the_toolchain "$tool")
        fi
    done

    SYSTEM_INCLUDE_DIR="$SYSROOT/usr/include"
    SYSTEM_LIBRARY_DIR="$SYSROOT/usr/lib/$TARGET_TRIPLE2/$TARGET_OS_VERS"

    # https://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html#Invoking-GCC
     CCFLAGS="--sysroot $SYSROOT -Qunused-arguments -fPIC -Wl,--as-needed"
    CPPFLAGS="--sysroot $SYSROOT -Qunused-arguments -I$SYSTEM_INCLUDE_DIR/$TARGET_TRIPLE2"
     LDFLAGS="--sysroot $SYSROOT -L$SYSTEM_LIBRARY_DIR -Wl,--as-needed"

    if [ "$PACKAGE_INSTALL_STATICALLY_LINKED_EXECUTABLE" = yes ] ; then
        CCFLAGS="$CCFLAGS -static --static -ffunction-sections -fdata-sections -Wl,--gc-sections -Wl,--no-dynamic-linker"
        LDFLAGS="$LDFLAGS -static --static -ffunction-sections -fdata-sections -Wl,--gc-sections -Wl,--no-dynamic-linker"
    else
        # CCFLAGS="$CCFLAGS -Wl,--dynamic-linker=$DYNAMIC_LINKER_PATH"
        # LDFLAGS="$LDFLAGS -Wl,--dynamic-linker=$DYNAMIC_LINKER_PATH"
        :
    fi

    if [ "$BUILD_TYPE" = release ] ; then
        CCFLAGS="$CCFLAGS -Wl,--strip-debug -Os -DNDEBUG"
        LDFLAGS="$LDFLAGS -Wl,--strip-debug"
    fi

    for item in $PACKAGE_CDEFINE
    do
        CPPFLAGS="$CPPFLAGS -D$item"
    done

    CPPFLAGS="$CPPFLAGS -include $COMMON_INCLUDE_H_FILEPATH"

    if [ -n "$PACKAGE_CCFLAGS" ] ; then
        CCFLAGS="$CCFLAGS $PACKAGE_CCFLAGS"
    fi

    if [ -n "$PACKAGE_LDFLAGS" ] ; then
        LDFLAGS="$LDFLAGS $PACKAGE_LDFLAGS"
    fi

    # https://www.freedesktop.org/wiki/Software/pkg-config/CrossCompileProposal
    unset PKG_CONFIG_SYSROOT_DIR
    unset PKG_CONFIG_LIBDIR
    unset PKG_CONFIG_PATH

    # https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_ROOT_PATH.html
    # https://cmake.org/cmake/help/latest/variable/CMAKE_IGNORE_PATH.html
    # https://cmake.org/cmake/help/latest/variable/CMAKE_PREFIX_PATH.html
    # https://cmake.org/cmake/help/latest/variable/CMAKE_INCLUDE_PATH.html
    # https://cmake.org/cmake/help/latest/variable/CMAKE_LIBRARY_PATH.html
    unset CMAKE_FIND_ROOT_PATH
    unset CMAKE_IGNORE_PATH
    unset CMAKE_PREFIX_PATH
    unset CMAKE_INCLUDE_PATH
    unset CMAKE_LIBRARY_PATH

    for DEPENDENCY_PACKAGE_NAME in $RECURSIVE_DEPENDENT_PACKAGES
    do
        DEPENDENCY_PACKAGE_TARGET_INSTALLED_INSTALL_DIR="$MY_INSTALL_DIR/android/$TARGET_OS_VERS/$DEPENDENCY_PACKAGE_NAME/$TARGET_OS_ABI"
        DEPENDENCY_PACKAGE_TARGET_INSTALLED_INCLUDE_DIR="$DEPENDENCY_PACKAGE_TARGET_INSTALLED_INSTALL_DIR/include"
        DEPENDENCY_PACKAGE_TARGET_INSTALLED_LIBRARY_DIR="$DEPENDENCY_PACKAGE_TARGET_INSTALLED_INSTALL_DIR/lib"
        DEPENDENCY_PACKAGE_TARGET_INSTALLED_PKGCONF_DIR="$DEPENDENCY_PACKAGE_TARGET_INSTALLED_INSTALL_DIR/lib/pkgconfig"

        DEPENDENCY_PACKAGE_NAME_UNDERSCORE=$(printf '%s\n' "$DEPENDENCY_PACKAGE_NAME" | tr '+-.' '_')

        eval "${DEPENDENCY_PACKAGE_NAME_UNDERSCORE}_INSTALL_DIR='$DEPENDENCY_PACKAGE_TARGET_INSTALLED_INSTALL_DIR'"
        eval "${DEPENDENCY_PACKAGE_NAME_UNDERSCORE}_INCLUDE_DIR='$DEPENDENCY_PACKAGE_TARGET_INSTALLED_INCLUDE_DIR'"
        eval "${DEPENDENCY_PACKAGE_NAME_UNDERSCORE}_LIBRARY_DIR='$DEPENDENCY_PACKAGE_TARGET_INSTALLED_LIBRARY_DIR'"

        CPPFLAGS="-I$DEPENDENCY_PACKAGE_TARGET_INSTALLED_INCLUDE_DIR $CPPFLAGS"
         LDFLAGS="-L$DEPENDENCY_PACKAGE_TARGET_INSTALLED_LIBRARY_DIR $LDFLAGS"

        if [ -z "$PKG_CONFIG_PATH" ] ; then
            PKG_CONFIG_PATH="$DEPENDENCY_PACKAGE_TARGET_INSTALLED_PKGCONF_DIR"
        else
            PKG_CONFIG_PATH="$PKG_CONFIG_PATH:$DEPENDENCY_PACKAGE_TARGET_INSTALLED_PKGCONF_DIR"
        fi

        if [ -z "$CMAKE_FIND_ROOT_PATH" ] ; then
            CMAKE_FIND_ROOT_PATH="$DEPENDENCY_PACKAGE_TARGET_INSTALLED_INSTALL_DIR"
        else
            CMAKE_FIND_ROOT_PATH="$CMAKE_FIND_ROOT_PATH;$DEPENDENCY_PACKAGE_TARGET_INSTALLED_INSTALL_DIR"
        fi

        for item in bin sbin
        do
            if [ -d "$DEPENDENCY_PACKAGE_TARGET_INSTALLED_INSTALL_DIR/$item" ] ; then
                if [ -z "$CMAKE_IGNORE_PATH" ] ; then
                    CMAKE_IGNORE_PATH="$DEPENDENCY_PACKAGE_TARGET_INSTALLED_INSTALL_DIR/$item"
                else
                    CMAKE_IGNORE_PATH="$CMAKE_IGNORE_PATH;$DEPENDENCY_PACKAGE_TARGET_INSTALLED_INSTALL_DIR/$item"
                fi
            fi
        done
    done

    for DEPENDENCY_PACKAGE_NAME in $PACKAGE_DEP_PKG
    do
        # https://android.googlesource.com/platform/bionic/+/master/docs/status.md

        if [ "$DEPENDENCY_PACKAGE_NAME" = libexecinfo ] ; then
            if [ "$TARGET_OS_VERS" -lt 33 ] ; then
                # https://android.googlesource.com/platform/bionic/+/master/libc/include/execinfo.h
                # https://android.googlesource.com/platform/bionic/+/master/libc/bionic/execinfo.cpp
                CPPFLAGS="$CPPFLAGS -include $libexecinfo_INCLUDE_DIR/execinfo.h"
                LDFLAGS="$LDFLAGS -l:libexecinfo.a"
            fi
        fi

        if [ "$DEPENDENCY_PACKAGE_NAME" = libgetloadavg ] ; then
            if [ "$TARGET_OS_VERS" -lt 29 ] ; then
                # https://android.googlesource.com/platform/bionic/+/master/libc/include/stdlib.h#157
                # https://android.googlesource.com/platform/bionic/+/master/libc/bionic/getloadavg.cpp
                # int getloadavg(double __averages[], int __n) __INTRODUCED_IN(29);
                CPPFLAGS="$CPPFLAGS -include $libgetloadavg_INCLUDE_DIR/getloadavg.h"
                LDFLAGS="$LDFLAGS -l:libgetloadavg.a"
            fi
        fi

        if [ "$DEPENDENCY_PACKAGE_NAME" = libglob ] ; then
            # https://pubs.opengroup.org/onlinepubs/9699919799/functions/glob.html
            # https://android.googlesource.com/platform/bionic/+/master/libc/include/glob.h
            if [ "$TARGET_OS_VERS" -lt 28 ] ; then
                LDFLAGS="$LDFLAGS -l:libglob.a"
            fi
        fi

        if [ "$DEPENDENCY_PACKAGE_NAME" = liblanginfo ] ; then
            # https://pubs.opengroup.org/onlinepubs/9699919799/functions/nl_langinfo.html
            # https://android.googlesource.com/platform/bionic/+/master/libc/include/langinfo.h
            if [ "$TARGET_OS_VERS" -lt 26 ] ; then
                LDFLAGS="$LDFLAGS -l:liblanginfo.a"
            fi
        fi

        if [ "$DEPENDENCY_PACKAGE_NAME" = libmblen ] ; then
            # https://android.googlesource.com/platform/bionic/+/master/libc/include/stdlib.h#163
            # https://android.googlesource.com/platform/bionic/+/master/libc/bionic/mblen.cpp
            # int mblen(const char* __s, size_t __n) __INTRODUCED_IN_NO_GUARD_FOR_NDK(26);
            if [ "$TARGET_OS_VERS" -lt 26 ] ; then
                CPPFLAGS="$CPPFLAGS -include $libmblen_INCLUDE_DIR/mblen.h"
                LDFLAGS="$LDFLAGS -l:libmblen.a"
            fi
        fi

        if [ "$DEPENDENCY_PACKAGE_NAME" = libgetdomainname ] ; then
            # https://android.googlesource.com/platform/bionic/+/master/libc/include/unistd.h#313
            # https://android.googlesource.com/platform/bionic/+/master/libc/bionic/getdomainname.cpp
            # int getdomainname(char* __buf, size_t __buf_size) __INTRODUCED_IN(26);
            if [ "$TARGET_OS_VERS" -lt 26 ] ; then
                CPPFLAGS="$CPPFLAGS -include $libgetdomainname_INCLUDE_DIR/getdomainname.h"
                LDFLAGS="$LDFLAGS -l:libgetdomainname.a"
            fi
        fi

        if [ "$DEPENDENCY_PACKAGE_NAME" = libstrchrnul ] ; then
            # https://android.googlesource.com/platform/bionic/+/master/libc/include/string.h#68
            # char* strchrnul(char* __s, int __ch) __RENAME(strchrnul) __attribute_pure__ __INTRODUCED_IN(24);
            if [ "$TARGET_OS_VERS" -lt 24 ] ; then
                CPPFLAGS="$CPPFLAGS -include $libstrchrnul_INCLUDE_DIR/strchrnul.h"
                LDFLAGS="$LDFLAGS -l:libstrchrnul.a"
            fi
        fi

        if [ "$DEPENDENCY_PACKAGE_NAME" = libgetdtablesize ] ; then
            CPPFLAGS="$CPPFLAGS -include $libgetdtablesize_INCLUDE_DIR/getdtablesize.h"
            # https://android.googlesource.com/platform/bionic/+/72dc1c22dc6a92dea925398c9e3880364ab29c1c/libc/bionic/getdtablesize.c
            LDFLAGS="$LDFLAGS -l:libgetdtablesize.a"
        fi
    done

    unset DEPENDENCY_PACKAGE_NAME
    unset DEPENDENCY_PACKAGE_NAME_UNDERSCORE
    unset DEPENDENCY_PACKAGE_TARGET_INSTALLED_INSTALL_DIR
    unset DEPENDENCY_PACKAGE_TARGET_INSTALLED_INCLUDE_DIR
    unset DEPENDENCY_PACKAGE_TARGET_INSTALLED_LIBRARY_DIR
    unset DEPENDENCY_PACKAGE_TARGET_INSTALLED_PKGCONF_DIR

    TARGET_INSTALL_DIR="$PACKAGE_INSTALL_DIR/$TARGET_OS_ABI"
    TARGET_WORKING_DIR="$PACKAGE_INSTALLING_TOP_DIR/$TARGET_OS_ABI"
    TARGET_BUILDIN_DIR="$TARGET_WORKING_DIR/build"

    CPPFLAGS="-I$TARGET_WORKING_DIR/include -I$PACKAGE_INSTALLING_TOP_DIR $CPPFLAGS"
     LDFLAGS="-L$TARGET_WORKING_DIR/lib     -L$PACKAGE_INSTALLING_TOP_DIR  $LDFLAGS"

    if [ "$LOG_LEVEL" -ge "$LOG_LEVEL_VERBOSE" ] ; then
        CCFLAGS="$CCFLAGS -v -Wl,-v"
        LDFLAGS="$LDFLAGS -v -Wl,-v"
    fi

      CFLAGS="$CCFLAGS"
    CXXFLAGS="$CCFLAGS"

    if [ -n "$PACKAGE_XXFLAGS" ] ; then
        CXXFLAGS="$CXXFLAGS $PACKAGE_XXFLAGS"
    fi

    PKG_CONFIG_LIBDIR="$PKG_CONFIG_PATH"

    # https://cmake.org/cmake/help/latest/manual/cmake-env-variables.7.html#manual:cmake-env-variables(7)
    if [ "$PACKAGE_BUILD_SYSTEM_CMAKE" = yes ] ; then
        unset CMAKE_PREFIX_PATH
        unset CMAKE_APPLE_SILICON_PROCESSOR
        unset CMAKE_BUILD_PARALLEL_LEVEL
        unset CMAKE_BUILD_TYPE
        unset CMAKE_CONFIGURATION_TYPES
        unset CMAKE_CONFIG_TYPE
        unset CMAKE_EXPORT_COMPILE_COMMANDS
        unset CMAKE_GENERATOR
        unset CMAKE_GENERATOR_INSTANCE
        unset CMAKE_GENERATOR_PLATFORM
        unset CMAKE_GENERATOR_TOOLSET
        unset CMAKE_INSTALL_MODE
        unset CMAKE_C_COMPILER_LAUNCHER
        unset CMAKE_C_LINKER_LAUNCHER
        unset CMAKE_CXX_COMPILER_LAUNCHER
        unset CMAKE_CXX_LINKER_LAUNCHER
        unset CMAKE_MSVCIDE_RUN_PATH
        unset CMAKE_NO_VERBOSE
        unset CMAKE_OSX_ARCHITECTURES
        unset CMAKE_TOOLCHAIN_FILE
        unset DESTDIR
        unset CTEST_INTERACTIVE_DEBUG_MODE
        unset CTEST_OUTPUT_ON_FAILURE
        unset CTEST_PARALLEL_LEVEL
        unset CTEST_PROGRESS_OUTPUT
        unset CTEST_USE_LAUNCHERS_DEFAULT
        unset DASHBOARD_TEST_FROM_CTEST

        # https://cmake.org/cmake/help/latest/envvar/CMAKE_BUILD_PARALLEL_LEVEL.html
        export CMAKE_BUILD_PARALLEL_LEVEL="$BUILD_NJOBS"

        # https://cmake.org/cmake/help/latest/envvar/CMAKE_GENERATOR.html
        if [ "$PACKAGE_BUILD_SYSTEM_NINJA" = yes ] ; then
            export CMAKE_GENERATOR='Ninja'
        else
            export CMAKE_GENERATOR='Unix Makefiles'
        fi

        # https://cmake.org/cmake/help/latest/envvar/CMAKE_EXPORT_COMPILE_COMMANDS.html
        if [ "$EXPORT_COMPILE_COMMANDS_JSON" = yes ] ; then
            export CMAKE_EXPORT_COMPILE_COMMANDS=ON
        else
            export CMAKE_EXPORT_COMPILE_COMMANDS=OFF
        fi

    fi

    if [ "$PACKAGE_BUILD_SYSTEM_CARGO" = yes ] ; then
        unset RUST_TARGET
        unset RUST_TARGET_UPPERCASE_UNDERSCORE

        RUST_TARGET=$(printf '%s\n' "$TARGET_TRIPLE" | sed 's/armv7a/armv7/')

        RUST_TARGET_UPPERCASE_UNDERSCORE=$(printf '%s\n' "$RUST_TARGET" | tr a-z A-Z | tr - _)

        # https://doc.rust-lang.org/cargo/reference/config.html#environment-variables
        # https://doc.rust-lang.org/cargo/reference/environment-variables.html
        export "CARGO_TARGET_${RUST_TARGET_UPPERCASE_UNDERSCORE}_AR"="$AR"
        export "CARGO_TARGET_${RUST_TARGET_UPPERCASE_UNDERSCORE}_LINKER"="$CC"

        # this environment variable is not defined by Rust, but it is widely used by third-party project.
        export RUST_TARGET

        export CARGO_BUILD_JOBS="$BUILD_NJOBS"

        export RUSTFLAGS="-Clink-arg=-L$TARGET_WORKING_DIR/lib -Clink-arg=-L$PACKAGE_INSTALLING_TOP_DIR"

        if [ "$PACKAGE_INSTALL_STATICALLY_LINKED_EXECUTABLE" = yes ] ; then
            export RUSTFLAGS="$RUSTFLAGS -Clink-arg=-static -Clink-arg=-ffunction-sections -Clink-arg=-fdata-sections -Clink-arg=-Wl,--gc-sections -Clink-arg=-Wl,--no-dynamic-linker"
        fi

        for DEPENDENCY_PACKAGE_NAME in $PACKAGE_DEP_PKG
        do
            if [ "$DEPENDENCY_PACKAGE_NAME" = libgetloadavg ] ; then
                if [ "$TARGET_OS_VERS" -lt 29 ] ; then
                    # https://android.googlesource.com/platform/bionic/+/master/libc/include/stdlib.h#157
                    # https://android.googlesource.com/platform/bionic/+/master/libc/bionic/getloadavg.cpp
                    # int getloadavg(double __averages[], int __n) __INTRODUCED_IN(29);
                    # CPPFLAGS="$CPPFLAGS -include $libgetloadavg_INCLUDE_DIR/getloadavg.h"
                    export RUSTFLAGS="$RUSTFLAGS -Clink-arg=$libgetloadavg_LIBRARY_DIR/libgetloadavg.a"
                fi
            fi

            if [ "$DEPENDENCY_PACKAGE_NAME" = libglob ] ; then
                # https://pubs.opengroup.org/onlinepubs/9699919799/functions/glob.html
                # https://android.googlesource.com/platform/bionic/+/master/libc/include/glob.h
                if [ "$TARGET_OS_VERS" -lt 28 ] ; then
                    export RUSTFLAGS="$RUSTFLAGS -Clink-arg=$libglob_LIBRARY_DIR/libglob.a"
                fi
            fi

            if [ "$DEPENDENCY_PACKAGE_NAME" = liblanginfo ] ; then
                # https://pubs.opengroup.org/onlinepubs/9699919799/functions/nl_langinfo.html
                # https://android.googlesource.com/platform/bionic/+/master/libc/include/langinfo.h
                if [ "$TARGET_OS_VERS" -lt 26 ] ; then
                    export RUSTFLAGS="$RUSTFLAGS -Clink-arg=$liblanginfo_LIBRARY_DIR/liblanginfo.a"
                fi
            fi

            if [ "$DEPENDENCY_PACKAGE_NAME" = libmblen ] ; then
                # https://android.googlesource.com/platform/bionic/+/master/libc/include/stdlib.h#163
                # https://android.googlesource.com/platform/bionic/+/master/libc/bionic/mblen.cpp
                # int mblen(const char* __s, size_t __n) __INTRODUCED_IN_NO_GUARD_FOR_NDK(26);
                if [ "$TARGET_OS_VERS" -lt 26 ] ; then
                    CPPFLAGS="$CPPFLAGS -include $libmblen_INCLUDE_DIR/mblen.h"
                    export RUSTFLAGS="$RUSTFLAGS -Clink-arg=$libmblen_LIBRARY_DIR/libmblen.a"
                fi
            fi

            if [ "$DEPENDENCY_PACKAGE_NAME" = libgetdomainname ] ; then
                # https://android.googlesource.com/platform/bionic/+/master/libc/include/unistd.h#313
                # https://android.googlesource.com/platform/bionic/+/master/libc/bionic/getdomainname.cpp
                # int getdomainname(char* __buf, size_t __buf_size) __INTRODUCED_IN(26);
                if [ "$TARGET_OS_VERS" -lt 26 ] ; then
                    # CPPFLAGS="$CPPFLAGS -include $libgetdomainname_INCLUDE_DIR/getdomainname.h"
                    export RUSTFLAGS="$RUSTFLAGS -Clink-arg=$libgetdomainname_LIBRARY_DIR/libgetdomainname.a"
                fi
            fi

            if [ "$DEPENDENCY_PACKAGE_NAME" = libstrchrnul ] ; then
                # https://android.googlesource.com/platform/bionic/+/master/libc/include/string.h#68
                # char* strchrnul(char* __s, int __ch) __RENAME(strchrnul) __attribute_pure__ __INTRODUCED_IN(24);
                if [ "$TARGET_OS_VERS" -lt 24 ] ; then
                    # CPPFLAGS="$CPPFLAGS -include $libstrchrnul_INCLUDE_DIR/strchrnul.h"
                    export RUSTFLAGS="$RUSTFLAGS -Clink-arg=$libstrchrnul_LIBRARY_DIR/libstrchrnul.a"
                fi
            fi

            if [ "$DEPENDENCY_PACKAGE_NAME" = libgetdtablesize ] ; then
                # CPPFLAGS="$CPPFLAGS -include $libgetdtablesize_INCLUDE_DIR/getdtablesize.h"
                # https://android.googlesource.com/platform/bionic/+/72dc1c22dc6a92dea925398c9e3880364ab29c1c/libc/bionic/getdtablesize.c
                export RUSTFLAGS="$RUSTFLAGS -Clink-arg=$libgetdtablesize_LIBRARY_DIR/libgetdtablesize.a"
            fi
        done

        # https://libraries.io/cargo/cc
        # https://crates.io/crates/cc
        # https://docs.rs/cc/latest/cc/
        # https://github.com/alexcrichton/cc-rs
        export HOST_CC="$CC_FOR_BUILD"
        export HOST_CFLAGS="$CFLAGS_FOR_BUILD"

        export HOST_CXX="$CXX_FOR_BUILD"
        export HOST_CXXFLAGS="$CXXFLAGS_FOR_BUILD"

        export HOST_AR="$AR_FOR_BUILD"

        export TARGET_CC="$CC"
        export TARGET_CFLAGS="$CFLAGS $CPPFLAGS $LDFLAGS"

        export TARGET_CXX="$CXX"
        export TARGET_CXXFLAGS="$CXXFLAGS $CPPFLAGS $LDFLAGS"

        export TARGET_AR="$AR"


        # https://libraries.io/cargo/pkg-config
        # https://crates.io/crates/pkg-config
        # https://docs.rs/pkg-config/latest/pkg_config/
        # https://github.com/rust-lang/pkg-config-rs
        export TARGET_PKG_CONFIG_ALLOW_CROSS=1


        # https://libraries.io/cargo/cmake
        # https://crates.io/crates/cmake
        # https://docs.rs/cmake/latest/cmake/
        # https://github.com/alexcrichton/cmake-rs
        # this variable is not motioned in their document. you must read the source code of cmake-rs crate.
        export TARGET_CMAKE_TOOLCHAIN_FILE="$TARGET_WORKING_DIR/toolchain.cmake"

        install -d "$TARGET_WORKING_DIR"

        printf '%s\n' "
        set(ANDROID_ABI "${TARGET_OS_ABI}")
        set(ANDROID_PLATFORM "android-${TARGET_OS_VERS}")
        set(ANDROID_USE_LEGACY_TOOLCHAIN_FILE OFF)
        include(${ANDROID_NDK_HOME}/build/cmake/android.toolchain.cmake)
        " > "$TARGET_CMAKE_TOOLCHAIN_FILE"


        for item in $RECURSIVE_DEPENDENT_PACKAGES
        do
            case $item in
                openssl)
                    unset OPENSSL_DIR
                    # https://docs.rs/openssl/0.10.35/openssl/
                    export OPENSSL_DIR="$openssl_INSTALL_DIR"
                    ;;
            esac
        done
    fi

    if [ "$PACKAGE_BUILD_SYSTEM_GO" = yes ] ; then
        # https://golang.org/doc/install/source#environment
        export CGO_ENABLED=1
        export CGO_CFLAGS="$CFLAGS"
        export CGO_CXXFLAGS="$CXXFLAGS"
        export CGO_CPPFLAGS="$CPPFLAGS"
        export CGO_LDFLAGS="$LDFLAGS"

        export GO111MODULE='auto'

        if [ "$COUNTRY" = china ] ; then
            export GOPROXY='https://goproxy.cn'
        fi

        export GOOS="$TARGET_OS_TYPE"

        case $TARGET_OS_ARCH in
            armv7*)  export GOARCH=arm   ;;
            arm64*)  export GOARCH=arm64 ;;
            aarch64) export GOARCH=arm64 ;;
            i386)    export GOARCH=386   ;;
            i686)    export GOARCH=386   ;;
            x86_64)  export GOARCH=amd64 ;;
        esac
    fi
}

# __printf_variables_for_the_given_target <PACKAGE-NAME> <TARGET>
# __printf_variables_for_the_given_target      curl       x86_64
__printf_variables_for_the_given_target() {
    printf '%s\n' "
        BUILD_NJOBS = $BUILD_NJOBS
        BUILD_TYPE  = $BUILD_TYPE

     TIMESTAMP_UNIX = $TIMESTAMP_UNIX

     NATIVE_OS_KIND = $NATIVE_OS_KIND
     NATIVE_OS_TYPE = $NATIVE_OS_TYPE
     NATIVE_OS_NAME = $NATIVE_OS_NAME
     NATIVE_OS_VERS = $NATIVE_OS_VERS
     NATIVE_OS_ARCH = $NATIVE_OS_ARCH
     NATIVE_OS_NCPU = $NATIVE_OS_NCPU
     NATIVE_OS_LIBC = $NATIVE_OS_LIBC
     NATIVE_OS_SUBS = $NATIVE_OS_SUBS

     TARGET_OS_KIND = $TARGET_OS_KIND
     TARGET_OS_TYPE = $TARGET_OS_TYPE
     TARGET_OS_NAME = $TARGET_OS_NAME
     TARGET_OS_VERS = $TARGET_OS_VERS
     TARGET_OS_ARCH = $TARGET_OS_ARCH
     TARGET_OS_ABI  = $TARGET_OS_ABI
     TARGET_OS_BIT  = $TARGET_OS_BIT
     TARGET_TRIPLE  = $TARGET_TRIPLE
     TARGET_INDEX   = $TARGET_INDEX

     TOOLCHAIN_NAME = $TOOLCHAIN_NAME
     TOOLCHAIN_VERS = $TOOLCHAIN_VERS
     TOOLCHAIN_ROOT = $TOOLCHAIN_ROOT
     TOOLCHAIN_BIND = $TOOLCHAIN_BIND

   ANDROID_NDK_HOME = $ANDROID_NDK_HOME
   ANDROID_NDK_ROOT = $ANDROID_NDK_ROOT

            SYSROOT = $SYSROOT

 SYSTEM_INCLUDE_DIR = $SYSTEM_INCLUDE_DIR
 SYSTEM_LIBRARY_DIR = $SYSTEM_LIBRARY_DIR
    "

    for TOOL in $(list_tools_in_the_toolchain | tr a-z A-Z)
    do
        eval export "$TOOL=\"\$$TOOL\""
        printf "%19s = %s\n" "$TOOL" "$(eval echo \$$TOOL)"
    done

    echo

    for TOOL in $(list_tools_in_the_toolchain | tr a-z A-Z)
    do
        eval export "${TOOL}_FOR_BUILD=\"\$${TOOL}_FOR_BUILD\""
        printf "%19s = %s\n" "${TOOL}_FOR_BUILD" "$(eval echo \$${TOOL}_FOR_BUILD)"
    done

    echo

    for FLAG in $(list_flags_used_by_tools_in_the_toolchain)
    do
        eval export "$FLAG=\"\$$FLAG\""
        printf "\n%19s = " "$FLAG"
        FIRST=yes
        for item in $(eval echo \$$FLAG | tr ':' ' ')
        do
            if [ "$FIRST" = yes ] ; then
                FIRST=no
                printf '%s\n' "$item"
            else
                printf '%s\n' "                      $item"
            fi
        done
    done

    echo

    for FLAG in $(list_flags_used_by_tools_in_the_toolchain)
    do
        printf "\n%19s = " "${FLAG}_FOR_BUILD"
        FIRST=yes
        for item in $(eval echo \$${FLAG}_FOR_BUILD | tr ':' ' ')
        do
            if [ "$FIRST" = yes ] ; then
                FIRST=no
                printf '%s\n' "$item"
            else
                printf '%s\n' "                      $item"
            fi
        done
    done

    echo

    printf "\n%19s = " PATH
    FIRST=yes
    for item in $(printf '%s\n' "$PATH" | tr ' ' '|' | tr ':' ' ')
    do
        if [ "$FIRST" = yes ] ; then
            FIRST=no
            printf '%s\n' "$item" | tr '|' ' '
        else
            printf '%s\n' "                      $item" | tr '|' ' '
        fi
    done

    if [ "$PACKAGE_BUILD_SYSTEM_CMAKE" = yes ] ; then
        echo
        env | sed -n '/^CMAKE_/p'
    fi

    if [ "$PACKAGE_BUILD_SYSTEM_CARGO" = yes ] ; then
        echo
        env | sed -n '/CARGO/p'
        echo
        env | sed -n '/RUST/p'
        echo
        cat <<EOF
    HOST_AR       = $HOST_AR
    HOST_CC       = $HOST_CC
    HOST_CXX      = $HOST_CXX
    HOST_CFLAGS   = $HOST_CFLAGS
    HOST_CXXFLAGS = $HOST_CXXFLAGS

  TARGET_AR       = $TARGET_AR
  TARGET_CC       = $TARGET_CC
  TARGET_CXX      = $TARGET_CXX
  TARGET_CFLAGS   = $TARGET_CFLAGS
  TARGET_CXXFLAGS = $TARGET_CXXFLAGS
EOF
    fi

    if [ "$PACKAGE_BUILD_SYSTEM_GO" = yes ] ; then
        echo
        for item_ in $(go env | tr ' ' '|')
        do
            unset item0
            unset item1
            unset item2

            item0=$(printf '%s\n' "$item_" | tr '|' ' ')
            item1=$(printf '%s\n' "$item0" | cut -d= -f1)
            item2=$(printf '%s\n' "$item0" | cut -d= -f2 | sed 's/^"//' | sed 's/"$//')

            printf '      %-12s = %s\n' "$item1" "$item2"
        done
    fi

    printf '%s\n' "
PACKAGE_INSTALLING_TOP_DIR = $PACKAGE_INSTALLING_TOP_DIR
PACKAGE_INSTALLING_SRC_DIR = $PACKAGE_INSTALLING_SRC_DIR
PACKAGE_INSTALLING_BST_DIR = $PACKAGE_INSTALLING_BST_DIR

 TARGET_WORKING_DIR = $TARGET_WORKING_DIR
 TARGET_BUILDIN_DIR = $TARGET_BUILDIN_DIR
 TARGET_INSTALL_DIR = $TARGET_INSTALL_DIR
   "

    if [ "$LOG_LEVEL" -ge "$LOG_LEVEL_VERBOSE" ] ; then
        echo
        run export -p
        echo
    fi
}

gow() {
    # https://pkg.go.dev/cmd/go
    # https://pkg.go.dev/cmd/link

    unset GO_BUILD_ARGS
    unset GO_BUILD_ARGV_V
    unset GO_BUILD_ARGV_X
    unset GO_BUILD_ARGV_O
    unset GO_BUILD_ARGV_MOD
    unset GO_BUILD_ARGV_TAGS
    unset GO_BUILD_ARGV_LDFLAGS

    unset GO_BUILD_ARGS_EXTRA

    while [ -n "$1" ]
    do
        case $1 in
            -v) shift ; GO_BUILD_ARGV_V='-v' ;;
            -x) shift ; GO_BUILD_ARGV_X='-x' ;;
            -o) shift ; GO_BUILD_ARGV_O="$1" ; shift ;;
            -X) shift
                if [ -z "$GO_BUILD_ARGV_LDFLAGS" ] ; then
                    GO_BUILD_ARGV_LDFLAGS="-X $1"
                else
                    GO_BUILD_ARGV_LDFLAGS="$GO_BUILD_ARGV_LDFLAGS -X $1"
                fi
                shift
                ;;
            -ldflags)
                shift
                if [ -z "$GO_BUILD_ARGV_LDFLAGS" ] ; then
                    GO_BUILD_ARGV_LDFLAGS="$1"
                else
                    GO_BUILD_ARGV_LDFLAGS="$1 $GO_BUILD_ARGV_LDFLAGS"
                fi
                shift
                ;;
            *)  GO_BUILD_ARGS_EXTRA="$GO_BUILD_ARGS_EXTRA $1" ; shift
        esac
    done

    GO_BUILD_ARGS='-trimpath'

    if [ -z "$GO_BUILD_ARGV_V" ] ; then
        if [ "$LOG_LEVEL" -gt "$LOG_LEVEL_QUIET" ] ; then
            GO_BUILD_ARGS="$GO_BUILD_ARGS -v"
        fi
    else
        GO_BUILD_ARGS="$GO_BUILD_ARGS -v"
    fi

    if [ -z "$GO_BUILD_ARGV_X" ] ; then
        if [ "$LOG_LEVEL" -ge "$LOG_LEVEL_VERBOSE" ] ; then
            GO_BUILD_ARGS="$GO_BUILD_ARGS -x"
        fi
    else
        GO_BUILD_ARGS="$GO_BUILD_ARGS -x"
    fi

    if [ -z "$GO_BUILD_ARGV_LDFLAGS" ] ; then
        GO_BUILD_ARGS="$GO_BUILD_ARGS -ldflags '-s -w'"
    else
        GO_BUILD_ARGS="$GO_BUILD_ARGS -ldflags '-s -w $GO_BUILD_ARGV_LDFLAGS'"
    fi

    if [ -z "$GO_BUILD_ARGV_O" ] ; then
        GO_BUILD_ARGS="$GO_BUILD_ARGS -o $TARGET_BUILDIN_DIR/"
    else
        GO_BUILD_ARGS="$GO_BUILD_ARGS -o $TARGET_BUILDIN_DIR/$GO_BUILD_ARGV_O"
    fi

    GO_BUILD_ARGS="$GO_BUILD_ARGS $GO_BUILD_ARGS_EXTRA"

    run go build $GO_BUILD_ARGS

    for item in $(ls "$TARGET_BUILDIN_DIR")
    do
        case $item in
            *.a)  run install_libs "$TARGET_BUILDIN_DIR/$item" ;;
            *.so) run install_libs "$TARGET_BUILDIN_DIR/$item" ;;
            *)    run install_bins "$TARGET_BUILDIN_DIR/$item" ;;
        esac
    done
}

cargow() {
    case $1 in
        build)
            # https://doc.rust-lang.org/cargo/commands/cargo-clean.html
            # https://doc.rust-lang.org/cargo/commands/cargo-build.html

            unset CARGO_BUILD_ARGS
            unset CARGO_BUILD_ARG_VV
            unset CARGO_BUILD_ARG_TARGET
            unset CARGO_BUILD_ARG_RELEASE

            for arg in $@
            do
                case $arg in
                    --vv)      CARGO_BUILD_ARG_VV=set      ;;
                    --target)  CARGO_BUILD_ARG_TARGET=set  ;;
                    --release) CARGO_BUILD_ARG_RELEASE=set ;;
                esac
            done

            CARGO_BUILD_ARGS="$@"

            if [ -z "$CARGO_BUILD_ARG_VV" ] ; then
                CARGO_BUILD_ARGS="$CARGO_BUILD_ARGS -vv"
            fi

            if [ -z "$CARGO_BUILD_ARG_RELEASE" ] ; then
                CARGO_BUILD_ARGS="$CARGO_BUILD_ARGS --release"
            fi

            if [ -z "$CARGO_BUILD_ARG_TARGET" ] ; then
                CARGO_BUILD_ARGS="$CARGO_BUILD_ARGS --target $RUST_TARGET"
            fi

            run cargo clean && run cargo $CARGO_BUILD_ARGS
            ;;
        install)
            # https://doc.rust-lang.org/cargo/commands/cargo-clean.html
            # https://doc.rust-lang.org/cargo/commands/cargo-install.html

            unset CARGO_INSTALL_ARGS
            unset CARGO_INSTALL_ARG_TARGET
            unset CARGO_INSTALL_ARG_PATH
            unset CARGO_INSTALL_ARG_ROOT
            unset CARGO_INSTALL_ARG_VV

            for arg in $@
            do
                case $arg in
                    --target) CARGO_INSTALL_ARG_TARGET=set ;;
                    --path)   CARGO_INSTALL_ARG_PATH=set   ;;
                    --root)   CARGO_INSTALL_ARG_ROOT=set   ;;
                    --vv)     CARGO_INSTALL_ARG_VV=set     ;;
                esac
            done

            CARGO_INSTALL_ARGS="$@"

            if [ -z "$CARGO_INSTALL_ARG_VV" ] ; then
                CARGO_INSTALL_ARGS="$CARGO_INSTALL_ARGS -vv"
            fi

            if [ -z "$CARGO_INSTALL_ARG_TARGET" ] ; then
                CARGO_INSTALL_ARGS="$CARGO_INSTALL_ARGS --target $RUST_TARGET"
            fi

            if [ -z "$CARGO_INSTALL_ARG_PATH" ] ; then
                CARGO_INSTALL_ARGS="$CARGO_INSTALL_ARGS --path $PACKAGE_INSTALLING_BST_DIR"
            fi

            if [ -z "$CARGO_INSTALL_ARG_ROOT" ] ; then
                CARGO_INSTALL_ARGS="$CARGO_INSTALL_ARGS --root=$TARGET_INSTALL_DIR"
            fi

            run cargo clean && run cargo $CARGO_INSTALL_ARGS
            ;;
        cbuild|cinstall)
            unset CARGO_CINSTALL_ARGS
            unset CARGO_CINSTALL_ARG_Q
            unset CARGO_CINSTALL_ARG_V
            unset CARGO_CINSTALL_ARG_VV
            unset CARGO_CINSTALL_ARG_DEBUG
            unset CARGO_CINSTALL_ARG_RELEASE
            unset CARGO_CINSTALL_ARG_TARGET
            unset CARGO_CINSTALL_ARG_PREFIX

            for arg in $@
            do
                case $arg in
                    -q|--quiet)   CARGO_CINSTALL_ARG_Q=set       ;;
                    -v|--verbose) CARGO_CINSTALL_ARG_V=set       ;;
                    -vv)          CARGO_CINSTALL_ARG_VV=set      ;;
                    --debug)      CARGO_CINSTALL_ARG_DEBUG=set   ;;
                    --release)    CARGO_CINSTALL_ARG_RELEASE=set ;;
                    --target)     CARGO_CINSTALL_ARG_TARGET=set  ;;
                    --prefix)     CARGO_CINSTALL_ARG_PREFIX=set  ;;
                esac
            done

            CARGO_CINSTALL_ARGS="$@"

            if [ -z "$CARGO_CINSTALL_ARG_Q" ] && [ -z "$CARGO_CINSTALL_ARG_V" ] && [ -z "$CARGO_CINSTALL_ARG_VV" ] ; then
                CARGO_CINSTALL_ARGS="$CARGO_CINSTALL_ARGS -vv"
            fi

            if [ -z "$CARGO_CINSTALL_ARG_DEBUG" ] && [ -z "$CARGO_CINSTALL_ARG_RELEASE" ] ; then
                CARGO_CINSTALL_ARGS="$CARGO_CINSTALL_ARGS --release"
            fi

            if [ -z "$CARGO_CINSTALL_ARG_TARGET" ] ; then
                CARGO_CINSTALL_ARGS="$CARGO_CINSTALL_ARGS --target $RUST_TARGET"
            fi

            if [ -z "$CARGO_CINSTALL_ARG_PREFIX" ] ; then
                CARGO_CINSTALL_ARGS="$CARGO_CINSTALL_ARGS --prefix $TARGET_INSTALL_DIR"
            fi

            run cargo $CARGO_CINSTALL_ARGS
            ;;
        *) cargo $@
    esac
}

config_url() {
    printf '%s\n' "http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=$1;hb=HEAD"
}

# run in a subshell
configure() {
    if [ -z "$CONFIG_XX_UPDATED" ] ; then
        CONFIG_XX_UPDATED=yes
        # https://www.gnu.org/software/gettext/manual/html_node/config_002eguess.html
        # https://git.savannah.gnu.org/cgit/config.git/tree/
        for item in config.sub config.guess
        do
            for file in $(find "$PACKAGE_INSTALLING_BST_DIR" -name "$item")
            do
                CONFIG_XX="$MY_SOURCE_DIR/config/$item"
                if [ ! -f "$CONFIG_XX" ] ; then
                    fetch "$(config_url "$item")" --output-path="$CONFIG_XX"
                    run chmod a+x "$CONFIG_XX"
                    if [ "$item" = 'config.sub' ] ; then
                        sed_in_place 's/arm64-*/arm64-*|arm64e-*/g' "$CONFIG_XX"
                    fi
                fi
                run cp -f "$CONFIG_XX" "$file"
            done
        done
    fi

    if [ "$STEP_MESSAGE" = 'build for native' ] ; then
        if run "$PACKAGE_INSTALLING_BST_DIR"/configure \
            --prefix="$NATIVE_INSTALL_DIR" \
            $@ ; then
            echo
        else
            if [ -f "$TARGET_BUILDIN_DIR/config.log" ] ; then
                run cat "$TARGET_BUILDIN_DIR/config.log"
            elif [ -f "$PACKAGE_INSTALLING_BST_DIR/config.log" ] ; then
                run cat "$PACKAGE_INSTALLING_BST_DIR/config.log"
            fi
            return 1
        fi
    else
        export ac_cv_func_faccessat=yes
        export ac_cv_func_sigsetmask=no

        export ac_cv_func_malloc_0_nonnull=yes
        export ac_cv_func_calloc_0_nonnull=yes
        export ac_cv_func_realloc_0_nonnull=yes

        CONFIGURE_ARGS="
            --host='$TARGET_TRIPLE'
            --prefix='$TARGET_INSTALL_DIR'
            --disable-option-checking
            --disable-rpath
            --disable-nls
            --enable-largefile
            CC='$CC'
            CFLAGS='$CFLAGS'
            CXX='$CXX'
            CXXFLAGS='$CXXFLAGS'
            CPP='$CPP'
            CPPFLAGS='$CPPFLAGS'
            LDFLAGS='$LDFLAGS'
            AR='$AR'
            RANLIB='$RANLIB'
            PKG_CONFIG='$PKG_CONFIG'
            PKG_CONFIG_PATH='$PKG_CONFIG_PATH'
            PKG_CONFIG_LIBDIR='$PKG_CONFIG_LIBDIR'
            CC_FOR_BUILD='$CC_FOR_BUILD'"

        if [ "$LOG_LEVEL" -ge "$LOG_LEVEL_DEBUG" ] ; then
            CONFIGURE_ARGS="$CONFIGURE_ARGS --enable-debug"
        else
            CONFIGURE_ARGS="$CONFIGURE_ARGS --disable-debug"
        fi

        case $INSTALL_LIB in
            static) CONFIGURE_ARGS="$CONFIGURE_ARGS --enable-static --disable-shared" ;;
            shared) CONFIGURE_ARGS="$CONFIGURE_ARGS --enable-shared --disable-static" ;;
            both)   CONFIGURE_ARGS="$CONFIGURE_ARGS --enable-static --enable-shared"  ;;
            yes)    CONFIGURE_ARGS="$CONFIGURE_ARGS --enable-static --enable-shared"  ;;
            no)     CONFIGURE_ARGS="$CONFIGURE_ARGS --disable-static --disable-shared";;
        esac

        if run $PACKAGE_INSTALLING_BST_DIR/configure $CONFIGURE_ARGS $@ ; then
            echo
        else
            # https://docs.github.com/en/actions/learn-github-actions/environment-variables#default-environment-variables
            if [ "$GITHUB_ACTIONS" = true ] ; then
                if [ -f "$TARGET_BUILDIN_DIR/config.log" ] ; then
                    run cat "$TARGET_BUILDIN_DIR/config.log"
                elif [ -f "$PACKAGE_INSTALLING_BST_DIR/config.log" ] ; then
                    run cat "$PACKAGE_INSTALLING_BST_DIR/config.log"
                fi
            fi
            return 1
        fi
    fi

    if [ "$LOG_LEVEL" -ge "$LOG_LEVEL_VERBOSE" ] ; then
        for Makefile in $(find "$PACKAGE_INSTALLING_BST_DIR" -name Makefile)
        do
            sed_in_place 's|\t@|\t|g'     "$Makefile"
            sed_in_place 's|@echo|echo|g' "$Makefile"
        done
        unset Makefile
    fi

    gmakew clean &&
    gmakew       &&
    gmakew install
}

# gmake wrapper
gmakew() {
    unset GMAKE_OPTIONS
    unset GMAKE_OPTION_SETTED_C
    unset GMAKE_OPTION_SETTED_w
    unset GMAKE_OPTION_SETTED_j

    for option in $@
    do
        case $option in
            -C)           GMAKE_OPTION_SETTED_C=yes ;;
            -w)           GMAKE_OPTION_SETTED_w=yes ;;
            -j)           GMAKE_OPTION_SETTED_j=yes ;;
            -j[1-9])      GMAKE_OPTION_SETTED_j=yes ;;
            -j[1-9][0-9]) GMAKE_OPTION_SETTED_j=yes ;;
        esac
    done

    if [ "$GMAKE_OPTION_SETTED_w" != yes ] ; then
        GMAKE_OPTIONS="$GMAKE_OPTIONS -w"
    fi

    if [ "$GMAKE_OPTION_SETTED_C" != yes ] ; then
        if [ "$PACKAGE_BUILD_IN_BSCRIPT_DIR" != yes ] ; then
            if [ "$STEP_MESSAGE" = 'build for native' ] ; then
                GMAKE_OPTIONS="$GMAKE_OPTIONS -C $NATIVE_BUILDIN_DIR"
            else
                GMAKE_OPTIONS="$GMAKE_OPTIONS -C $TARGET_BUILDIN_DIR"
            fi
        fi
    fi

    if [ "$GMAKE_OPTION_SETTED_j" != yes ] ; then
        GMAKE_OPTIONS="$GMAKE_OPTIONS -j$BUILD_NJOBS"
    fi

    if [ "$LOG_LEVEL" -ge "$LOG_LEVEL_DEBUG" ] ; then
        GMAKE_OPTIONS="$GMAKE_OPTIONS --debug V=1"
    fi

    if [ "$EXPORT_COMPILE_COMMANDS_JSON" = yes ] && [ "$BEAR_ENABLED" = yes ] ; then
        run bear -- $GMAKE $GMAKE_OPTIONS $*
    else
        run         $GMAKE $GMAKE_OPTIONS $*
    fi
}

# https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html#cross-compiling
# https://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_ROOT_PATH.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_PREFIX_PATH.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_INSTALL_PREFIX.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html
# https://cmake.org/cmake/help/latest/variable/BUILD_SHARED_LIBS.html
# https://cmake.org/cmake/help/latest/command/enable_testing.html?highlight=build_testing
# https://developer.android.com/ndk/guides/cmake
# run in a subshell
cmakew() {
    CMAKE_CONFIG_OPTIONS="-Wno-dev -DCMAKE_EXPORT_COMPILE_COMMANDS=$CMAKE_EXPORT_COMPILE_COMMANDS -DBUILD_TESTING=OFF"

    # https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_DEBUG_MODE.html
    if [ "$LOG_LEVEL" -ge "$LOG_LEVEL_DEBUG" ] ; then
        CMAKE_CONFIG_OPTIONS="$CMAKE_CONFIG_OPTIONS -DCMAKE_FIND_DEBUG_MODE=TRUE"
    fi

    if [ "$STEP_MESSAGE" = 'build for native' ] ; then
        CMAKE_CONFIG_OPTIONS="$CMAKE_CONFIG_OPTIONS -DBUILD_SHARED_LIBS=OFF -DCMAKE_INSTALL_PREFIX='$NATIVE_INSTALL_DIR'"

        # https://stackoverflow.com/questions/11143062/getting-cmake-to-build-out-of-source-without-wrapping-scripts
        if command_exists_in_filesystem_and_version_matched cmake ge 3.13.0 ; then
            CMAKE_CONFIG_OPTIONS="$CMAKE_CONFIG_OPTIONS -S $PACKAGE_INSTALLING_BST_DIR -B $NATIVE_BUILDIN_DIR"
        else
            CMAKE_CONFIG_OPTIONS="$CMAKE_CONFIG_OPTIONS -H$PACKAGE_INSTALLING_BST_DIR -B$NATIVE_BUILDIN_DIR"
        fi

        run $CMAKE $CMAKE_CONFIG_OPTIONS $@ &&
        run $CMAKE --build   "$NATIVE_BUILDIN_DIR" -- -j$BUILD_NJOBS &&
        run $CMAKE --install "$NATIVE_BUILDIN_DIR"
    else
        # CMAKE_HOST_SYSTEM_NAME = $(uname -s)
        # CMAKE_HOST_SYSTEM_NAME on Cygwin and MSYS2 is not Windows
        if [ "$NATIVE_OS_KIND" = 'windows' ] ; then
            CMAKE_CONFIG_OPTIONS="$CMAKE_CONFIG_OPTIONS -DANDROID_HOST_TAG=windows-x86_64"
        fi

        case $BUILD_TYPE in
            debug)   CMAKE_CONFIG_OPTIONS="$CMAKE_CONFIG_OPTIONS -DCMAKE_BUILD_TYPE=Debug"   ;;
            release) CMAKE_CONFIG_OPTIONS="$CMAKE_CONFIG_OPTIONS -DCMAKE_BUILD_TYPE=Release" ;;
        esac

        if [ "$LOG_LEVEL" -eq "$LOG_LEVEL_QUIET" ] ; then
            CMAKE_CONFIG_OPTIONS="$CMAKE_CONFIG_OPTIONS -DCMAKE_VERBOSE_MAKEFILE=OFF -DCMAKE_COLOR_MAKEFILE=OFF"
        else
            CMAKE_CONFIG_OPTIONS="$CMAKE_CONFIG_OPTIONS -DCMAKE_VERBOSE_MAKEFILE=ON  -DCMAKE_COLOR_MAKEFILE=ON"
        fi

        case $TARGET_OS_ARCH in
            armv7a)  CMAKE_SYSTEM_PROCESSOR=armv7-a ;;
            aarch64) CMAKE_SYSTEM_PROCESSOR=aarch64 ;;
            i686)    CMAKE_SYSTEM_PROCESSOR=i686    ;;
            x86_64)  CMAKE_SYSTEM_PROCESSOR=x86_64  ;;
        esac

        case $INSTALL_LIB in
            static) BUILD_SHARED_LIBS=OFF ;;
            *)      BUILD_SHARED_LIBS=ON
        esac

        CMAKE_CONFIG_OPTIONS="$CMAKE_CONFIG_OPTIONS
        -DCMAKE_TOOLCHAIN_FILE='$ANDROID_NDK_HOME/build/cmake/android.toolchain.cmake'
        -DCMAKE_SYSTEM_PROCESSOR=$CMAKE_SYSTEM_PROCESSOR
        -DCMAKE_FIND_ROOT_PATH='$CMAKE_FIND_ROOT_PATH'
        -DCMAKE_LIBRARY_PATH='$SYSTEM_LIBRARY_DIR'
        -DCMAKE_IGNORE_PATH='$CMAKE_IGNORE_PATH'
        -DCMAKE_INSTALL_PREFIX='$TARGET_INSTALL_DIR'
        -DCMAKE_C_FLAGS='$CFLAGS $CPPFLAGS $LDFLAGS'
        -DCMAKE_CXX_FLAGS='$CXXFLAGS $CPPFLAGS $LDFLAGS'
        -DBUILD_SHARED_LIBS=$BUILD_SHARED_LIBS
        -DANDROID_TOOLCHAIN=clang
        -DANDROID_ABI=$TARGET_OS_ABI
        -DANDROID_ARM_NEON=TRUE
        -DANDROID_STL=c++_shared
        -DANDROID_PLATFORM=$TARGET_OS_VERS
        -DANDROID_USE_LEGACY_TOOLCHAIN_FILE=OFF"

        if [ "$CCACHE_ENABLED" = yes ] ; then
            CMAKE_CONFIG_OPTIONS="$CMAKE_CONFIG_OPTIONS -DNDK_CCACHE=$CCACHE"
        fi

        # https://stackoverflow.com/questions/11143062/getting-cmake-to-build-out-of-source-without-wrapping-scripts
        if command_exists_in_filesystem_and_version_matched cmake ge 3.13.0 ; then
            CMAKE_CONFIG_OPTIONS="$CMAKE_CONFIG_OPTIONS -S $PACKAGE_INSTALLING_BST_DIR -B $TARGET_BUILDIN_DIR"
        else
            CMAKE_CONFIG_OPTIONS="$CMAKE_CONFIG_OPTIONS -H$PACKAGE_INSTALLING_BST_DIR -B$TARGET_BUILDIN_DIR"
        fi

        run $CMAKE $CMAKE_CONFIG_OPTIONS $@ &&
        run $CMAKE --build   "$TARGET_BUILDIN_DIR" -- -j$BUILD_NJOBS &&
        run $CMAKE --install "$TARGET_BUILDIN_DIR"
    fi
}

# https://github.com/xmake-io/xmake/issues/2003
# run in a subshell
xmakew() {
    export XMAKE_ROOT=y

    XMAKE=$(command -v xmake)

    [ -z "$XMAKE" ] && die "command not found: xmake"

    run xmake --version

    XMAKE_CONFIG_OPTIONS="$@"

    XMAKE_CONFIG_OPTION_CLEAN=
    XMAKE_CONFIG_OPTION_MODE=
    XMAKE_CONFIG_OPTION_vD=

    for arg in $@
    do
        case $arg in
            -c|--clean)  XMAKE_CONFIG_OPTION_CLEAN=set ;;
            -m|--mode=*) XMAKE_CONFIG_OPTION_MODE=set  ;;
            -vD)         XMAKE_CONFIG_OPTION_vD=set ;;
        esac
    done

    if [ "$LOG_LEVEL" -ge "$LOG_LEVEL_DEBUG" ] && [ -z "$XMAKE_CONFIG_OPTION_vD" ]; then
        XMAKE_CONFIG_OPTIONS="$XMAKE_CONFIG_OPTION_vD -vD"
    fi

    if [ -z "$XMAKE_CONFIG_OPTION_CLEAN" ] ; then
        XMAKE_CONFIG_OPTIONS="$XMAKE_CONFIG_OPTIONS --clean"
    fi

    if [ -z "$XMAKE_CONFIG_OPTION_MODE" ] ; then
        XMAKE_CONFIG_OPTIONS="$XMAKE_CONFIG_OPTIONS --mode=$BUILD_TYPE"
    fi

    if [ "$STEP_MESSAGE" = 'build for native' ] ; then
        run $XMAKE config $XMAKE_CONFIG_OPTIONS --project=$PACKAGE_INSTALLING_BST_DIR --buildir=$NATIVE_BUILDIN_DIR &&
        run $XMAKE --jobs=$BUILD_NJOBS &&
        run $XMAKE install -o "$NATIVE_INSTALL_DIR"
    else
        XMAKE_CONFIG_OPTIONS="$XMAKE_CONFIG_OPTIONS --plat=android --arch=$TARGET_OS_ABI --ndk_sdkver=$TARGET_OS_VERS --toolchain=ndk --ndk=$ANDROID_NDK_HOME --buildir=$TARGET_BUILDIN_DIR"

        run $XMAKE config $XMAKE_CONFIG_OPTIONS &&
        run $XMAKE --jobs=$BUILD_NJOBS &&
        run $XMAKE install -o "$TARGET_INSTALL_DIR"
    fi
}

# https://mesonbuild.com/Cross-compilation.html
# run in a subshell
mesonw() {
    case $TARGET_OS_ARCH in
        armv7*)
            HOST_MACHINE_CPU_FAMILY='arm'
            HOST_MACHINE_CPU_NAME="$TARGET_OS_ARCH"
            ;;
        arm64*|aarch64)
            HOST_MACHINE_CPU_FAMILY='aarch64'
            HOST_MACHINE_CPU_NAME='armv8a'
            ;;
        i386|i686)
            HOST_MACHINE_CPU_FAMILY='x86'
            HOST_MACHINE_CPU_NAME="$TARGET_OS_ARCH"
            ;;
        x86_64)
            HOST_MACHINE_CPU_FAMILY='x86_64'
            HOST_MACHINE_CPU_NAME="$TARGET_OS_ARCH"
            ;;
    esac

    MESON_CROSS_FILE="$TARGET_BUILDIN_DIR/cross-file"

    cat > "$MESON_CROSS_FILE" <<EOF
[host_machine]
system = '$TARGET_OS_TYPE'
endian = 'little'
cpu_family = '$HOST_MACHINE_CPU_FAMILY'
cpu = '$HOST_MACHINE_CPU_NAME'

[binaries]
c = '$CC'
cpp = '$CXX'
ar = '$AR'
strip = '$STRIP'
cmake = '$CMAKE'
pkgconfig = '$PKG_CONFIG'

EOF

    # https://mesonbuild.com/Machine-files.html#meson-builtin-options
    if command_exists_in_filesystem_and_version_matched meson lt 0.56.0 ; then
        cat >> "$MESON_CROSS_FILE" <<EOF
[properties]
c_args = $(to_meson_array $CFLAGS $CPPFLAGS)
c_link_args = $(to_meson_array $LDFLAGS)
cpp_args = $(to_meson_array $CXXFLAGS $CPPFLAGS)
cpp_link_args = $(to_meson_array $LDFLAGS)
EOF
    else
        cat >> "$MESON_CROSS_FILE" <<EOF
[built-in options]
c_args = $(to_meson_array $CFLAGS $CPPFLAGS)
c_link_args = $(to_meson_array $LDFLAGS)
cpp_args = $(to_meson_array $CXXFLAGS $CPPFLAGS)
cpp_link_args = $(to_meson_array $LDFLAGS)
EOF
    fi

    unset MESON_ARGUMENT_DEFAULT_LIBRARY

    case $INSTALL_LIB in
        static|shared|both) MESON_ARGUMENT_DEFAULT_LIBRARY="-Ddefault_library=$INSTALL_LIB"
    esac

    run "$MESON" setup \
        --prefix="$TARGET_INSTALL_DIR" \
        --buildtype=$BUILD_TYPE \
        --backend=ninja \
        --pkg-config-path="$PKG_CONFIG_PATH" \
        --build.pkg-config-path="$PKG_CONFIG_PATH_FOR_BUILD" \
        --cross-file="$MESON_CROSS_FILE" \
        $MESON_ARGUMENT_DEFAULT_LIBRARY \
        $@ "$TARGET_BUILDIN_DIR" "$PACKAGE_INSTALLING_BST_DIR" &&
    {
        if command -v build_configed > /dev/null ; then
            build_configed
        fi
    } &&
    run ninja -C "$TARGET_BUILDIN_DIR" &&
    run ninja -C "$TARGET_BUILDIN_DIR" install
}

to_meson_array() {
    RESULT="[''"
    for item in $@
    do
        RESULT="$RESULT, '$item'"
    done
    RESULT="$RESULT]"
    printf '%s\n' "$RESULT"
}

# https://developer.android.com/ndk/guides/ndk-build
ndk_build() {
    # https://developer.android.com/ndk/downloads/revision_history#expandable-33
    # Android NDK r7 (November 2011)
    if [ "$CCACHE_ENABLED" = yes ] ; then
        export NDK_CCACHE=$CCACHE
    fi

    NDK_BUILD_ARGS="NDK_PROJECT_PATH=. APP_BUILD_SCRIPT=Android.mk APP_PLATFORM=android-$TARGET_OS_VERS APP_STRIP_MODE=-S"

    case $BUILD_TYPE in
        debug)   NDK_BUILD_ARGS="$NDK_BUILD_ARGS NDK_DEBUG=1" ;;
        release) NDK_BUILD_ARGS="$NDK_BUILD_ARGS NDK_DEBUG=0" ;;
    esac

    if [ "$EXPORT_COMPILE_COMMANDS_JSON" = yes ] ; then
        NDK_BUILD_ARGS="$NDK_BUILD_ARGS GEN_COMPILE_COMMANDS_DB=true"
    fi

    if [ "$LOG_LEVEL" -ge "$LOG_LEVEL_VERBOSE" ] ; then
        NDK_BUILD_ARGS="$NDK_BUILD_ARGS V=1"
    fi

    if [ "$LOG_LEVEL" -ge "$LOG_LEVEL_DEBUG" ] ; then
        NDK_BUILD_ARGS="$NDK_BUILD_ARGS NDK_LOG=1"
    fi

    run ndk-build $NDK_BUILD_ARGS
}

########################################################################

create_common_include_h() {
    [ -z  "$1" ] && die "create_common_include_h <FILEPATH>, <FILEPATH> must not be empty."
    cat > "$1" <<EOF
#ifndef NDK_PKG_COMMON_H
#define NDK_PKG_COMMON_H

// https://pubs.opengroup.org/onlinepubs/000095399/functions/rindex.html
#define rindex(a,b) strrchr((a),(b))

// https://pubs.opengroup.org/onlinepubs/000095399/functions/bcmp.html
#define bcmp(b1,b2,len) memcmp((b1), (b2), (size_t)(len))

// https://linux.die.net/man/2/wait3
#define wait3(status,options,rusage) waitpid(-1,status,options)

// https://stackoverflow.com/questions/32826175/ftello-and-fseeko-android-build-errors
// https://linux.die.net/man/3/ftello
// int   fseeko(FILE* __fp, off_t __offset, int __whence) __RENAME(fseeko64) __INTRODUCED_IN(24);
// off_t ftello(FILE* __fp) __RENAME(ftello64) __INTRODUCED_IN(24);
#if __ANDROID_API__ < 24
    #define ftello(f) ftell(f)
    #define fseeko    fseek
#endif

#endif
EOF
}

list_all_installed_libs() {
    if [ -d "$MY_INSTALL_DIR" ] ; then
        cd  "$MY_INSTALL_DIR"
    else
        return 0
    fi

    for item in *
    do
        if is_package_installed "$item" "$MIN_SDK_API_LEVEL" ; then
            if [ -d  "$MY_INSTALL_DIR/$item/libs" ] ; then
                find "$MY_INSTALL_DIR/$item/libs" -name "lib*\.a"
            fi
        fi
    done
}

__ldd() {
    setup_build_toolchains_env

    [ -z "$1" ] && {
        error "__ldd <PACKAGE-NAME> <ABI>, <PACKAGE-NAME> is not given."
        return 1
    }

    is_package_installed "$1" "$MIN_SDK_API_LEVEL" || {
        error "package [$1] is not installed."
        return 1
    }


    if [ -z "$3" ] ; then
        die "type is not specified."
    fi

    if [ -z "$4" ] ; then
        die "name is not specified."
    fi

    TARGET_OS_ARCH=$(print_target_arch_by_abi "$2")
    TARGET_TRIPLE=$(print_target_triple_by_arch "$TARGET_OS_ARCH")
    READELF="$(path_of_tool_in_the_toolchain readelf)"

    ldd_recursion() {
        [ -z "$1" ] && {
            error "ldd_recursion <PACKAGE-NAME> <ABI>, <PACKAGE-NAME> is not given."
            return 1
        }

        is_package_installed "$1" "$MIN_SDK_API_LEVEL" || {
            error "package [$1] is not installed."
            return 1
        }

        if [ -z "$3" ] ; then
            die "type is not specified."
        fi
        if [ -z "$4" ] ; then
            die "name is not specified."
        fi

        FILE_PATH="$MY_INSTALL_DIR/$1/$2/$3/$4"
        [ -f "$FILE_PATH" ] || die "$FILE_PATH not exist."
        printf '%s\n' "$FILE_PATH"

        DLL=$("$READELF" -d "$FILE_PATH" | sed -n "/\.so/p" | sed 's/.*\[\(.*\)\].*/\1/')
        for item in $DLL
        do
            ldd_recursion $(read_ldd_cache $item) $(expr "$5" + 1)
        done
    }

    ldd_recursion "$1" "$2" "$3" "$4" 0
}

# list_dynamic_library_names_of_the_given_package <PACKAGE-NAME>
  list_dynamic_library_names_of_the_given_package() {
    [ -z "$1" ] && {
        error "list_dynamic_library_names_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is not given."
        return 1
    }

    is_package_installed "$1" "$MIN_SDK_API_LEVEL" || {
        error "package [$1] is not installed."
        return 1
    }

    ABI=$(__list_supported_target_abis | head -n 1)
    TARGET_LIBRARY_DIR="$MY_INSTALL_DIR/$1/$ABI/lib"
    if [ -d  "$TARGET_LIBRARY_DIR" ] ; then
        find "$TARGET_LIBRARY_DIR" -name "*.so*" -a -maxdepth 0 -a \( -type f -o -type l \) -exec basename {} \;
    fi
}

__list_supported_target_sdk_api_levels() {
    if [ -z "$TOOLCHAIN_BIND" ] ; then
        setup_build_toolchains_env > /dev/null
    fi
    ls "$TOOLCHAIN_BIND" | sed -n '/aarch64-linux-android[1-9][0-9]-clang++/p' | cut -d- -f3 | sed 's/android//'
}

__list_supported_target_archs() {
    list armv7a aarch64 i686 x86_64
}

__list_supported_target_abis() {
    list armeabi-v7a arm64-v8a x86 x86_64
}

__list_supported_target_triples() {
    for ARCH in $(__list_supported_target_archs)
    do
        print_target_triple_by_arch "$ARCH"
    done
}

# print_target_arch_by_abi <ABI>
  print_target_arch_by_abi() {
    [ -z "$1" ] && {
        error "print_target_arch_by_abi <ABI>, <ABI> is not given."
        return 1
    }

    case $1 in
        armeabi-v7a) printf '%s\n' armv7a  ;;
        arm64-v8a)   printf '%s\n' aarch64 ;;
        x86)         printf '%s\n' i686    ;;
        x86_64)      printf '%s\n' x86_64  ;;
    esac
}

# print_target_abi_by_arch <ARCH>
  print_target_abi_by_arch() {
    [ -z "$1" ] && {
        error "print_target_abi_by_arch <ARCH>, <ARCH> is not given."
        return 1
    }

    case $1 in
        armv7a)      printf '%s\n' armeabi-v7a ;;
        aarch64)     printf '%s\n' arm64-v8a   ;;
        i686)        printf '%s\n' x86         ;;
        x86_64)      printf '%s\n' x86_64      ;;
    esac
}

# print_target_triple_by_arch <ARCH>
  print_target_triple_by_arch() {
    [ -z "$1" ] && {
        error "print_target_triple_by_arch <ARCH>, <ARCH> is not given."
        return 1
    }

    case $1 in
        armv7a) printf '%s\n' "armv7a-linux-androideabi" ;;
        *)      printf '%s\n' "$1-linux-android"         ;;
    esac
}

list_tools_in_the_toolchain() {
    list cc cxx cpp as ld ar ranlib nm size strip strings objdump objcopy readelf
}

list_flags_used_by_tools_in_the_toolchain() {
    list CFLAGS CXXFLAGS CPPFLAGS LDFLAGS PKG_CONFIG_PATH PKG_CONFIG_LIBDIR
}

# this function should be run in a subshell
#
# path_of_tool_in_the_toolchain <TOOL-NAME>
  path_of_tool_in_the_toolchain() {
    unset TOOL_FILENAME

    case $1 in
        cc)  TOOL_FILENAME="$TARGET_TRIPLE$TARGET_OS_VERS-clang"   ;;
        cxx) TOOL_FILENAME="$TARGET_TRIPLE$TARGET_OS_VERS-clang++" ;;
        ld)  TOOL_FILENAME="$(printf '%s\n' "$TARGET_TRIPLE" | sed 's/armv7a/arm/')-$1"
            # https://github.com/android/ndk/wiki/Changelog-r22
             if [ ! -e "$TOOLCHAIN_BIND/$TOOL_FILENAME" ] ; then
                 TOOL_FILENAME=ld.lld
             fi
             ;;
        *)   TOOL_FILENAME="$(printf '%s\n' "$TARGET_TRIPLE" | sed 's/armv7a/arm/')-$1"

             # https://github.com/android/ndk/wiki/Changelog-r23
             if [ ! -e "$TOOLCHAIN_BIND/$TOOL_FILENAME" ] ; then
                 TOOL_FILENAME=llvm-$1
             fi
    esac

    TOOL_FILEPATH="$TOOLCHAIN_BIND/$TOOL_FILENAME"

    [ -e "$TOOL_FILEPATH" ] || {
        error "path_of_tool_in_the_toolchain <TOOL-NAME>, $1[$TOOL_FILEPATH] is not exist."
        return 1
    }

    [ -x "$TOOL_FILEPATH" ] || {
        error "path_of_tool_in_the_toolchain <TOOL-NAME>, $1[$TOOL_FILEPATH] is not executable."
        return 1
    }

    printf '%s\n' "$TOOL_FILEPATH"
}

ndk_version() {
    if   command -v cut  > /dev/null && command -v grep > /dev/null ; then
        grep "Pkg.Revision" "$ANDROID_NDK_HOME/source.properties" | cut -d " " -f3
    elif command -v awk  > /dev/null ; then
        awk -F= '/Pkg.Revision/{print(substr($2, 2))}' "$ANDROID_NDK_HOME/source.properties"
    elif command -v sed  > /dev/null ; then
        sed -n  "/Pkg.Revision/p" "$ANDROID_NDK_HOME/source.properties" | sed  's/Pkg\.Revision = \(.*\).*/\1/'
    elif command -v gsed > /dev/null ; then
        gsed -n "/Pkg.Revision/p" "$ANDROID_NDK_HOME/source.properties" | gsed 's/Pkg\.Revision = \(.*\).*/\1/'
    elif command -v ruby > /dev/null ; then
        ruby <<EOF
File.open(ENV['ANDROID_NDK_HOME'] + '/source.properties', 'r') {|f|
  f.each_line {|lineText|
    if (lineText =~ /Pkg.Revision =.*/)
        puts lineText.gsub('Pkg.Revision = ', '')
    end
  }
  f.close
}
EOF
    elif command -v perl > /dev/null ; then
        perl << EOF
open(DATA, "<$ANDROID_NDK_HOME/source.properties") or die "$ANDROID_NDK_HOME/source.propertiesæ–‡ä»¶æ— æ³•æ‰“å¼€, $!";
while(<DATA>) {
    if ("\$_" =~ m/Pkg.Revision/) {
        print substr("\$_", 15);
    }
}
EOF
    elif command -v node > /dev/null ; then
        node << EOF
const fs = require('fs');

const buffer = fs.readFileSync("$ANDROID_NDK_HOME/source.properties");
if (buffer instanceof Error) {
    console.log(buffer);
    process.exit(1);
}

const text = buffer.toString();
const lines = text.split('\n');
lines.forEach((line, index, lines) => {
    const matched = line.match(/\d+\.\d+\.\d+/);
    if (matched) {
        console.log(matched[0]);
    }
});
EOF
    else
        PYTHON=$(command -v python3) ||
        PYTHON=$(command -v python)  ||
        PYTHON=$(command -v python2)

        if [ -z "$PYTHON" ] ; then
            die "please install Python."
        else
            "$PYTHON" << EOF
import re;
file = open("$ANDROID_NDK_HOME/source.properties");
lines = file.readlines();
for line in lines:
    if -1 != line.find("Pkg.Revision"):
        print(re.findall("[0-9]{1,2}\.[0-9]{1,2}\.[0-9]{1,7}", line)[0]);
EOF
        fi
    fi
}

is_a_valid_android_ndk_root_dir() {
    [ -d "$1" ] &&
    [ -f "$1/source.properties" ] &&
    [ -f "$1/build/cmake/android.toolchain.cmake" ] &&
    [ -d "$1/toolchains/llvm/prebuilt/$ANDROID_NDK_TOOLCHAIN_HOST_TAG" ] &&
    [ -d "$1/toolchains/llvm/prebuilt/$ANDROID_NDK_TOOLCHAIN_HOST_TAG/bin" ] &&
    [ -d "$1/toolchains/llvm/prebuilt/$ANDROID_NDK_TOOLCHAIN_HOST_TAG/sysroot" ]
}

ndkmanager_list_all_available_for_windows() {
    # https://developer.android.google.cn/ndk/downloads
    cat <<EOF
48a0a7b38fb1c69cae6d17b70e03aab8d6138e65a30f8d3faebeb0dc09bf6940|https://dl.google.com/android/repository/android-ndk-r23c-windows.zip
36270f8b2cfdd940f410bd8ffe6ce86ffaa8e87ff1c4fd4a8be5130268357778|https://dl.google.com/android/repository/android-ndk-r23b-windows.zip
f71307c5c572e2c163d602b3704b8bc024bec0c43ba2800de36bd10f3a21492b|https://dl.google.com/android/repository/android-ndk-r21e-windows-x86_64.zip
EOF
}

ndkmanager_list_all_available_for_darwin() {
    # https://developer.android.google.cn/ndk/downloads
    cat <<EOF
baf793127741eda36f2eabe69cdec23a70c814deb3c75df8744af35aed21e59d|https://dl.google.com/android/repository/android-ndk-r23c-darwin.zip
e067b7402fdae85bfbe8af1822afd573b8e73dce443a8292fdaeb2e8dc3aeb86|https://dl.google.com/android/repository/android-ndk-r23b-darwin.zip
437278103a3db12632c05b1be5c41bbb8522791a67e415cc54411a65366f499d|https://dl.google.com/android/repository/android-ndk-r21e-darwin-x86_64.zip
EOF
}

ndkmanager_list_all_available_for_linux_x86_64() {
    # https://developer.android.google.cn/ndk/downloads
    cat <<EOF
6ce94604b77d28113ecd588d425363624a5228d9662450c48d2e4053f8039242|https://dl.google.com/android/repository/android-ndk-r23c-linux.zip
c6e97f9c8cfe5b7be0a9e6c15af8e7a179475b7ded23e2d1c1fa0945d6fb4382|https://dl.google.com/android/repository/android-ndk-r23b-linux.zip
ad7ce5467e18d40050dc51b8e7affc3e635c85bd8c59be62de32352328ed467e|https://dl.google.com/android/repository/android-ndk-r21e-linux-x86_64.zip
EOF
}

ndkmanager_list_all_available_for_android_aarch64() {
    # https://github.com/leleliu008/test/releases
    cat <<EOF
5fdca02b4a4c168671b0e077d0adfe38f9e2fb960664c71df6bd1bd3bad9f55c|https://github.com/leleliu008/test/releases/download/android-ndk-r23b-linux-aarch64/android-ndk-r23b-linux-aarch64.zip
EOF
}

ndkmanager_list_all_available() {
    case $NATIVE_OS_KIND in
        windows) ndkmanager_list_all_available_for_windows ;;
        darwin)  ndkmanager_list_all_available_for_darwin  ;;
        linux)
            case $NATIVE_OS_ARCH in
                x86_64)  ndkmanager_list_all_available_for_linux_x86_64 ;;
                aarch64) ndkmanager_list_all_available_for_android_aarch64 ;;
            esac
    esac
}

ndkmanager_install_the_given_rversion() {
    [ -z "$1" ] && {
        error "ndk-pkg ndkmanager install <Rversion>, <Rversion> is not given."
        return 1
    }

    case $1 in
        r2[1-3][a-e]) ;;
        *)  die "ndkmanager install unrecognized argument: $1"
    esac

    ANDROID_NDK_INSTALL_DIR="$MY_HOME_DIR/android-ndk-$1"

    if [ -f "$ANDROID_NDK_INSTALL_DIR/.installed" ] && is_a_valid_android_ndk_root_dir "$ANDROID_NDK_INSTALL_DIR" ; then
        success "Android NDK $1 already have been installed to $ANDROID_NDK_INSTALL_DIR."
        ANDROID_NDK_HOME="$ANDROID_NDK_INSTALL_DIR"
        ANDROID_NDK_ROOT="$ANDROID_NDK_HOME"
        return 0
    fi

    ANDROID_NDK_SELECTED=$(ndkmanager_list_all_available | sed -n "/android-ndk-$1/p")

    if [ -z "$ANDROID_NDK_SELECTED" ] ; then
        die "$1 versioned Android NDK not available."
    fi

    ANDROID_NDK_URL=$(printf '%s\n' "$ANDROID_NDK_SELECTED" | cut -d '|' -f2)
    ANDROID_NDK_SHA=$(printf '%s\n' "$ANDROID_NDK_SELECTED" | cut -d '|' -f1)

    if [ "${#ANDROID_NDK_SHA}" -ne 64 ] ; then
        die "$ANDROID_NDK_SHA is not sha256sum"
    fi

    fetch "$ANDROID_NDK_URL" --sha256="$ANDROID_NDK_SHA" --output-dir="$MY_HOME_DIR" || return 1

    unset ANDROID_NDK_FILEPATH
    unset ANDROID_NDK_FILENAME

    ANDROID_NDK_FILEPATH="$FETCH_OUTPUT_PATH"
    ANDROID_NDK_FILENAME="$FETCH_OUTPUT_NAME"

    if [ -f "$ANDROID_NDK_INSTALL_DIR/.installed" ] ; then
        success "$ANDROID_NDK_FILEPATH already have been installed to $ANDROID_NDK_INSTALL_DIR."
    else
        if [ -d "$ANDROID_NDK_INSTALL_DIR" ] ; then
            run rm -rf "$ANDROID_NDK_INSTALL_DIR" || return 1
        fi
        case $ANDROID_NDK_URL in
            *.zip)
                handle_dependency required exe unzip &&
                run unzip -q "$ANDROID_NDK_FILEPATH" -d "$MY_HOME_DIR" &&
                run touch "$ANDROID_NDK_INSTALL_DIR/.installed"
                ;;
            *.tar.xz)
                handle_dependency required exe tar &&
                handle_dependency required exe xz &&
                run tar xf   "$ANDROID_NDK_FILEPATH" -C "$MY_HOME_DIR" &&
                run touch "$ANDROID_NDK_INSTALL_DIR/.installed"
                ;;
        esac
    fi

    if is_a_valid_android_ndk_root_dir "$ANDROID_NDK_INSTALL_DIR" ; then
        ANDROID_NDK_HOME="$ANDROID_NDK_INSTALL_DIR"
        ANDROID_NDK_ROOT="$ANDROID_NDK_HOME"
    else
        return 1
    fi
}

ndkmanager_help() {
    printf '%b\n' "
${COLOR_GREEN}ndkmanager ls-available${COLOR_OFF}
    list available Android NDK

${COLOR_GREEN}ndkmanager ls-available --only-rversion${COLOR_OFF}
    list available Android NDK, only show rversion

${COLOR_GREEN}ndkmanager install <RVERSION>${COLOR_OFF}
    install specified rversion of Android NDK to ~/.ndk-pkg
    example: ndkmanager install r23b
"
}

# ndkmanager ls-available [--only-rversion]
# ndkmanager install r23b
ndkmanager() {
    set -e

    case $1 in
        ''|-h|--help)
            ndkmanager_help
            ;;
        ls-available)
            shift
            case $1 in
                --only-rversion)
                    ndkmanager_list_all_available | cut -d- -f3
                    ;;
                '') ndkmanager_list_all_available ;;
                *)  die "ndkmanager ls-available unrecognized argument: $1"
            esac
            ;;
        install)
            shift
            ndkmanager_install_the_given_rversion $@
            ;;
        *)  die "ndkmanager unrecognized argument: $@"
    esac
}

setup_build_toolchains_env() {
    debug() {
        if [ -n "$LOG_LEVEL" ] && [ "$LOG_LEVEL" -ge "$LOG_LEVEL_DEBUG" ] ; then
            printf '%b\n' "$*"
        fi
    }
 
    if [ -n "$ANDROID_NDK_HOME" ] ; then
        if [ "$NATIVE_OS_SUBS" = cygwin ] ; then
            case "$ANDROID_NDK_HOME" in
                [A-Z]:*) ANDROID_NDK_HOME="$(cygpath "$ANDROID_NDK_HOME")"
            esac
        fi
        if is_a_valid_android_ndk_root_dir "$ANDROID_NDK_HOME" ; then
            debug "you have set the ${COLOR_RED}ANDROID_NDK_HOME${COLOR_OFF} environment variable and point to ${COLOR_GREEN}$ANDROID_NDK_HOME${COLOR_OFF}, which is used as the android ndk home."
            export ANDROID_NDK_HOME="$ANDROID_NDK_HOME"
            export ANDROID_NDK_ROOT="$ANDROID_NDK_HOME"
        else
            debug "you have set the ${COLOR_RED}ANDROID_NDK_HOME${COLOR_OFF} environment variable and point to ${COLOR_GREEN}$ANDROID_NDK_HOME${COLOR_OFF}, but it is not a valid android ndk home directory."
            unset ANDROID_NDK_HOME
        fi
    fi

    if [ -z "$ANDROID_NDK_HOME" ] && [ -n  "$ANDROID_NDK_ROOT" ] ; then
        if is_a_valid_android_ndk_root_dir "$ANDROID_NDK_ROOT" ; then
            debug "you have set the ${COLOR_RED}ANDROID_NDK_ROOT${COLOR_OFF} environment variable and point to ${COLOR_GREEN}$ANDROID_NDK_ROOT${COLOR_OFF}, which is used as the android ndk home."
            export ANDROID_NDK_HOME="$ANDROID_NDK_ROOT"
            export ANDROID_NDK_ROOT="$ANDROID_NDK_ROOT"
        else
            debug "you have set the ${COLOR_RED}ANDROID_NDK_ROOT${COLOR_OFF} environment variable and point to ${COLOR_GREEN}$ANDROID_NDK_ROOT${COLOR_OFF}, but it is not a valid android ndk home directory."
            unset ANDROID_NDK_ROOT
        fi
    fi

    # https://developer.android.com/studio/command-line/variables
    if [ -z "$ANDROID_NDK_HOME" ] && [ -n  "$ANDROID_HOME" ] ; then
        if is_a_valid_android_ndk_root_dir "$ANDROID_HOME/ndk-bundle" ; then
            debug "you have set the ${COLOR_RED}ANDROID_HOME${COLOR_OFF} environment variable and point to ${COLOR_GREEN}$ANDROID_HOME${COLOR_OFF}, ${COLOR_GREEN}$ANDROID_HOME/ndk-bundle${COLOR_OFF}, which is used as the android ndk home."
            export ANDROID_NDK_HOME="$ANDROID_HOME/ndk-bundle"
            export ANDROID_NDK_ROOT="$ANDROID_HOME/ndk-bundle"
        else
            debug "you have set the ${COLOR_RED}ANDROID_HOME${COLOR_OFF} environment variable and point to ${COLOR_GREEN}$ANDROID_HOME${COLOR_OFF}, ${COLOR_GREEN}$ANDROID_HOME/ndk-bundle${COLOR_OFF} direcotory is not exist."
        fi
    fi

    if [ -z "$ANDROID_NDK_HOME" ] ; then
        for item in $(find "$MY_HOME_DIR" -maxdepth 1 -mindepth 1 -type d -name "android-ndk-r2[1-4][a-e]" | sort -r)
        do
            if is_a_valid_android_ndk_root_dir "$item" ; then
                export ANDROID_NDK_HOME="$item"
                export ANDROID_NDK_ROOT="$item"
                break
            else
                continue
            fi
        done
    fi

    if [ -z "$ANDROID_NDK_HOME" ] ; then
        note "Android NDK Not Found on your build machine, I will install it for you."

        if [ "$NATIVE_OS_SUBS" = termux ] ; then
            TO_INSTALL_ANDROID_NDK_REVERSION=r23b
        else
            TO_INSTALL_ANDROID_NDK_REVERSION=r23c
        fi

        if ndkmanager install "$TO_INSTALL_ANDROID_NDK_REVERSION" ; then
            export ANDROID_NDK_HOME
            export ANDROID_NDK_ROOT
        else
            die "install Android NDK failed."
        fi
    fi

    unset ANDROID_NDK_VERS
    unset ANDROID_NDK_VERS_MAJOR

    ANDROID_NDK_VERS="$(ndk_version)"
    ANDROID_NDK_VERS_MAJOR="$(printf '%s\n' "$ANDROID_NDK_VERS" | cut -d. -f1)"

    export ANDROID_NDK_VERS

    run "env | sed -n '/ANDROID_/p'"

    # Android NDK version must be r19 or newer.
    if [ "$ANDROID_NDK_VERS_MAJOR" -lt 19 ] ; then
        die "your installed android-ndk [$ANDROID_NDK_HOME] version is $ANDROID_NDK_VERS, please update to r19 or newer."
    fi

    TOOLCHAIN_NAME='android-ndk'
    TOOLCHAIN_VERS="$ANDROID_NDK_VERS"
    TOOLCHAIN_ROOT="$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/$ANDROID_NDK_TOOLCHAIN_HOST_TAG"
    TOOLCHAIN_BIND="$TOOLCHAIN_ROOT/bin"

    TOOLCHAIN_VERS_MAJOR="$ANDROID_NDK_VERS_MAJOR"

    SYSROOT="$TOOLCHAIN_ROOT/sysroot"

    bppend_to_PATH "$ANDROID_NDK_HOME"
    #bppend_to_PATH "$TOOLCHAIN_BIND"
}

is_a_valid_android_sdk_home_dir() {
    true
}

install_android_sdk_if_needed() {
    set -e

    # https://developer.android.com/studio/command-line/variables

    if [ -n "$ANDROID_HOME" ] ; then
        if is_a_valid_android_sdk_home_dir "$ANDROID_HOME" ; then
            debug "you have set the ${COLOR_RED}ANDROID_HOME${COLOR_OFF} environment variable and point to ${COLOR_GREEN}$ANDROID_HOME${COLOR_OFF}, which is used as the android sdk home."
            export ANDROID_HOME
        else
            debug "you have set the ${COLOR_RED}ANDROID_HOME${COLOR_OFF} environment variable and point to ${COLOR_GREEN}$ANDROID_HOME${COLOR_OFF}, but it is not a valid android sdk home."
            unset ANDROID_HOME
        fi
    fi

    if [ -z "$ANDROID_HOME" ] ; then
        if [ -f "$MY_HOME_DIR/android-sdk/env" ] ; then
            if is_a_valid_android_sdk_home_dir "$MY_HOME_DIR/android-sdk" ; then
                . "$MY_HOME_DIR/android-sdk/env"
            else
                rm -rf "$MY_HOME_DIR/android-sdk"
            fi
        fi
    fi

    if [ -z "$ANDROID_HOME" ] ; then
        note "Android SDK Not Found on your build machine, I will install it for you."

        # https://developer.android.com/studio#cmdline-tools
        case $NATIVE_OS_KIND in
            linux)
                ANDROID_SDK_URL='https://dl.google.com/android/repository/commandlinetools-linux-7583922_latest.zip'
                ANDROID_SDK_SHA='124f2d5115eee365df6cf3228ffbca6fc3911d16f8025bebd5b1c6e2fcfa7faf'
                ;;
            darwin)
                ANDROID_SDK_URL='https://dl.google.com/android/repository/commandlinetools-mac-7583922_latest.zip'
                ANDROID_SDK_SHA='6929a1957f3e71008adfade0cebd08ebea9b9f506aa77f1849c7bdc3418df7cf'
                ;;
            windows)
                ANDROID_SDK_URL='https://dl.google.com/android/repository/commandlinetools-win-7583922_latest.zip'
                ANDROID_SDK_SHA='f9e6f91743bcb1cc6905648ca751bc33975b0dd11b50d691c2085d025514278c'
                ;;
            *)  die "No Android SDK for $NATIVE_OS_KIND"
        esac

        ANDROID_SDK_FILENAME='android-sdk-commandline-tools.zip'
        ANDROID_SDK_FILEPATH="$MY_HOME_DIR/$ANDROID_SDK_FILENAME"

        fetch "$ANDROID_SDK_URL" --sha256="$ANDROID_SDK_SHA" --output-path="$ANDROID_SDK_FILEPATH"

        run install -d "$MY_HOME_DIR/android-sdk/cmdline-tools"

        run unzip "$ANDROID_SDK_FILEPATH" -d "$MY_HOME_DIR/android-sdk/cmdline-tools"

        run mv "$MY_HOME_DIR/android-sdk/cmdline-tools/cmdline-tools" "$MY_HOME_DIR/android-sdk/cmdline-tools/latest"

        run "yes | $MY_HOME_DIR/android-sdk/cmdline-tools/latest/bin/sdkmanager 'platforms;android-30'"
        run "yes | $MY_HOME_DIR/android-sdk/cmdline-tools/latest/bin/sdkmanager 'build-tools;30.0.3'"
        run "yes | $MY_HOME_DIR/android-sdk/cmdline-tools/latest/bin/sdkmanager 'platform-tools'"

        cat > "$MY_HOME_DIR/android-sdk/env" <<EOF
export ANDROID_HOME="$MY_HOME_DIR/android-sdk"

export PATH="\$ANDROID_HOME/cmdline-tools/latest/bin:\$PATH"
export PATH="\$ANDROID_HOME/platform-tools:\$PATH"
export PATH="\$ANDROID_HOME/build-tools/30.0.3:\$PATH"
EOF
        . "$MY_HOME_DIR/android-sdk/env"
    fi

    cat <<EOF
ANDROID_HOME     = $ANDROID_HOME
PATH             = $PATH
EOF
}

is_a_valid_jdk_home_dir() {
    true
}

install_jdk_if_needed() {
    set -e

    if [ -n "$JAVA_HOME" ] ; then
        if is_a_valid_jdk_home_dir "$JAVA_HOME" ; then
            debug "you have set the ${COLOR_RED}JAVA_HOME${COLOR_OFF} environment variable and point to ${COLOR_GREEN}$JAVA_HOME${COLOR_OFF}, which is used as the jdk home."
            export JAVA_HOME
            bppend_to_PATH "$JAVA_HOME/bin"
            run java -version
            return 0
        else
            debug "you have set the ${COLOR_RED}JAVA_HOME${COLOR_OFF} environment variable and point to ${COLOR_GREEN}$JAVA_HOME${COLOR_OFF}, but it is not a valid jdk home."
            unset JAVA_HOME
        fi
    fi

    if [ -f "$HOME/.uppm/install.d/jdk/installed-metadata" ] && [ -f "$HOME/.uppm/install.d/jdk/env" ] ; then
        if is_a_valid_jdk_home_dir "$HOME/.uppm/install.d/jdk" ; then
            . "$HOME/.uppm/install.d/jdk/env"
            run java -version
            return 0
        fi
    fi

    if command -v java > /dev/null ; then
        run java -version
        return 0
    fi

    note "JDK Not Found on your build machine, I will install it for you."
    __uppm_install_the_given_package jdk

    if [ -f "$HOME/.uppm/install.d/jdk/installed-metadata" ] && [ -f "$HOME/.uppm/install.d/jdk/env" ] ; then
        if is_a_valid_jdk_home_dir "$HOME/.uppm/install.d/jdk" ; then
            . "$HOME/.uppm/install.d/jdk/env"
            run java -version
            return 0
        fi
    fi

    if command -v java > /dev/null ; then
        run java -version
        return 0
    else
        error "no JDK Found"
        return 1
    fi
}

inspect_install_arguments() {
    # https://stackoverflow.com/questions/18476490/what-is-purpose-of-target-arch-variable-in-makefiles
    unset TARGET_ARCH

    # https://developer.android.google.cn/guide/topics/manifest/uses-sdk-element#api-level-table
    unset MIN_SDK_API_LEVEL

    unset USER_SPECIFIED_PACKAGES

    unset DRYRUN

      BEAR_ENABLED=yes
    CCACHE_ENABLED=yes

    LOG_LEVEL_QUIET=0
    LOG_LEVEL_NORMAL=1
    LOG_LEVEL_VERBOSE=2
    LOG_LEVEL_TRACE=3
    LOG_LEVEL_DEBUG=4

    LOG_LEVEL=$LOG_LEVEL_NORMAL

    BUILD_NJOBS=$NATIVE_OS_NCPU

    BUILD_TYPE=release

    LINK_TYPE=shared-prefered

    INSTALL_EXE=yes
    INSTALL_MAN=yes
    INSTALL_DOC=yes
    INSTALL_LIB=yes

    # https://clang.llvm.org/docs/JSONCompilationDatabase.html
    EXPORT_COMPILE_COMMANDS_JSON=no

    KEEP_INSTALLING_DIR=no

    TREE_ARGS='--dirsfirst'

    STRIP_ARGS='--strip-debug'

    while [ -n "$1" ]
    do
        case "$1" in
            --min-sdk-api-level=*)
                MIN_SDK_API_LEVEL=$(getvalue "$1")
                is_integer "$MIN_SDK_API_LEVEL" || die "--min-sdk-api-level=<VALUE>, <VALUE> must be a integer."
                ;;
            --china)
                ;;
            --xtrace|-x)
                LOG_LEVEL=$LOG_LEVEL_TRACE
                ;;
            --debug|-d)
                LOG_LEVEL=$LOG_LEVEL_DEBUG
                ;;
            --verbose|-v)
                LOG_LEVEL=$LOG_LEVEL_VERBOSE
                ;;
            --quiet|-q)
                LOG_LEVEL=$LOG_LEVEL_QUIET
                ;;
            --disable-ccache)
                CCACHE_ENABLED=no
                ;;
            --disable-bear)
                BEAR_ENABLED=no
                ;;
            --dry-run)
                DRYRUN=yes
                ;;
            --keep-installing-dir)
                KEEP_INSTALLING_DIR=yes
                ;;
            --tree-args=*)
                TREE_ARGS=$(getvalue "$1")
                ;;
            --strip-args=*)
                STRIP_ARGS=$(getvalue "$1")
                ;;
            --build-type=*)
                BUILD_TYPE=$(getvalue "$1")
                case $BUILD_TYPE in
                    debug|release) ;;
                    '') die "--build-type=<VALUE>, <VALUE> must not be empty." ;;
                    *)  die "--build-type=<VALUE>, <VALUE> must be one of debug release"
                esac
                ;;
            --export-compile-commands-json)
                EXPORT_COMPILE_COMMANDS_JSON=yes
                ;;
            --install-doc)
                INSTALL_DOC=yes
                ;;
            --install-man)
                INSTALL_MAN=yes
                ;;
            --install-exe)
                INSTALL_EXE=yes
                ;;
            --install-lib=*)
                INSTALL_LIB=$(getvalue "$1")
                case $INSTALL_LIB in
                    static|shared|both|yes|no) ;;
                    '') die "--install-lib=<VALUE>, <VALUE> must not be empty." ;;
                    *)  die "--install-lib=<VALUE>, <VALUE> must be one of static shared both yes no"
                esac
                ;;
            --link-type=*)
                LINK_TYPE=$(getvalue "$1")
                case $LINK_TYPE in
                    static-only|shared-only|static-prefered|shared-prefered) ;;
                    '') die "--link-type=<VALUE>, <VALUE> must not be empty." ;;
                    *)  die "--link-type=<VALUE>, <VALUE> must be one of static-only shared-only static-prefered shared-prefered"
                esac
                ;;
            --jobs=*)
                BUILD_NJOBS=$(getvalue "$1")
                is_integer "$BUILD_NJOBS" || die "--jobs=<VALUE>, <VALUE> must be a integer."
                ;;
            @all)
                USER_SPECIFIED_PACKAGES="$(__list_available_packages)"
                ;;
            [a-z]*)
                if [ -z "$USER_SPECIFIED_PACKAGES" ] ; then
                    USER_SPECIFIED_PACKAGES="$1"
                else
                    USER_SPECIFIED_PACKAGES="$USER_SPECIFIED_PACKAGES $1"
                fi
                ;;
            *)  die "unrecognized argument: $1"
        esac
        shift
    done

    if [ "$LOG_LEVEL" -eq "$LOG_LEVEL_QUIET" ] ; then
        exec 1>/dev/null
        exec 2>&1
    fi

    if [ "$LOG_LEVEL" -ge "$LOG_LEVEL_DEBUG" ] ; then
        export PKG_CONFIG_DEBUG_SPEW=set
    fi

    setup_build_toolchains_env

    SUPPORTED_SDK_API_LEVEL_ALL=$(__list_supported_target_sdk_api_levels)
    SUPPORTED_SDK_API_LEVEL_MIN=$(printf '%s\n' "$SUPPORTED_SDK_API_LEVEL_ALL" | sort | head -n 1)
    SUPPORTED_SDK_API_LEVEL_MAX=$(printf '%s\n' "$SUPPORTED_SDK_API_LEVEL_ALL" | sort | tail -n 1)

    if [ -z "$MIN_SDK_API_LEVEL" ] ; then
        MIN_SDK_API_LEVEL="$SUPPORTED_SDK_API_LEVEL_MIN"
    fi

    if [ "$LOG_LEVEL" -ge "$LOG_LEVEL_DEBUG" ] ; then
        cat <<EOF
SUPPORTED_SDK_API_LEVEL_ALL=$SUPPORTED_SDK_API_LEVEL_ALL
SUPPORTED_SDK_API_LEVEL_MIN=$SUPPORTED_SDK_API_LEVEL_MIN
SUPPORTED_SDK_API_LEVEL_MAX=$SUPPORTED_SDK_API_LEVEL_MAX
MIN_SDK_API_LEVEL=$MIN_SDK_API_LEVEL
EOF
    fi

    unset TARGET_LIST
    TARGET_LIST="$(__list_supported_target_abis)"

    for TOOLNAME in $(list_tools_in_the_toolchain)
    do
        unset TOOLNAME_UPPERCASE
        TOOLNAME_UPPERCASE=$(printf '%s\n' "$TOOLNAME" | tr a-z A-Z)

        unset TOOLPATH
        TOOLPATH="$(eval echo \$${TOOLNAME_UPPERCASE}_FOR_BUILD)"

        if [ -z "$TOOLPATH" ] ; then
            case $TOOLNAME in
                cc)  TOOLPATH="$(command -v cc  || command -v gcc || command -v clang   || true)" ;;
                cxx) TOOLPATH="$(command -v c++ || command -v g++ || command -v clang++ || true)" ;;
                *)   TOOLPATH="$(command -v "$TOOLNAME" || true)"
            esac
        else
            [ -e "$TOOLPATH" ] || die "${TOOLNAME_UPPERCASE}_FOR_BUILD=$TOOLPATH is not exist."
            [ -x "$TOOLPATH" ] || die "${TOOLNAME_UPPERCASE}_FOR_BUILD=$TOOLPATH is not executable."
        fi

        eval export "${TOOLNAME_UPPERCASE}='$TOOLPATH'"
        eval export "${TOOLNAME_UPPERCASE}_FOR_BUILD='$TOOLPATH'"
    done

    unset TOOLNAME_UPPERCASE
    unset TOOLNAME
    unset TOOLPATH

    for FLAG in $(list_flags_used_by_tools_in_the_toolchain)
    do
        eval export "${FLAG}_FOR_BUILD=\"\$$FLAG\""
    done
    unset FLAG
}

init() {
    # MY represents this software's

    MY_VERSION=0.1.39

    MY_HOME_PAGE='https://github.com/leleliu008/ndk-pkg.git'
    MY_OFFICAL_FORMULA_REPO_URL='https://github.com/leleliu008/ndk-pkg-formula-repository.git'

    MY_UPGRAGE_URL="https://raw.githubusercontent.com/leleliu008/ndk-pkg/master/bin/ndk-pkg"
    MY_ZSH_COMPLETION_SCRIPT_URL="https://raw.githubusercontent.com/leleliu008/ndk-pkg/master/zsh-completion/_ndk-pkg"

    MY_HOME_DIR="$HOME/.ndk-pkg"
    MY_FORMULA_REPO_DIR="$MY_HOME_DIR/repos.d"
    MY_INSTALL_DIR="$MY_HOME_DIR/install.d"
    MY_SOURCE_DIR="$MY_HOME_DIR/source.d"
    MY_BINARY_DIR="$MY_HOME_DIR/binary.d"
    MY_BACKUP_DIR="$MY_HOME_DIR/backup.d"
    MY_PATCH__DIR="$MY_HOME_DIR/patch.d"

    MY_INIT_RC="$MY_HOME_DIR/init.rc"

    [ -d "$MY_HOME_DIR" ] || install -d "$MY_HOME_DIR"

    [ -f "$MY_HOME_DIR/repos" ] || {
        printf 'offical=%s\n' "$MY_OFFICAL_FORMULA_REPO_URL"  > "$MY_HOME_DIR/repos"
    }

    if [ -f "$MY_INIT_RC" ] ; then
        .   "$MY_INIT_RC" || die "load $MY_INIT_RC failed."
    else
        cat > "$MY_INIT_RC" <<EOF
# influential environment variables:
#      CC_FOR_BUILD=/usr/bin/cc
#     CXX_FOR_BUILD=/usr/bin/c++
#     CPP_FOR_BUILD=/usr/bin/cpp
#      AS_FOR_BUILD=/usr/bin/as
#      LD_FOR_BUILD=/usr/bin/ld
#      AR_FOR_BUILD=/usr/bin/ar
#      NM_FOR_BUILD=/usr/bin/nm
#    SIZE_FOR_BUILD=/usr/bin/size
#   STRIP_FOR_BUILD=/usr/bin/strip
#  RANLIB_FOR_BUILD=/usr/bin/ranlib
# STRINGS_FOR_BUILD=/usr/bin/strings
# OBJDUMP_FOR_BUILD=/usr/bin/objdump
# OBJCOPY_FOR_BUILD=/usr/bin/objcopy
# READELF_FOR_BUILD=/usr/bin/readelf

# if you want to use your own version of Android NDK
# ANDROID_NDK_HOME=/usr/local/opt/android-ndk
# ANDROID_NDK_ROOT=/usr/local/opt/android-ndk
EOF
    fi

    unset NATIVE_OS_KIND
    unset NATIVE_OS_TYPE
    unset NATIVE_OS_NAME
    unset NATIVE_OS_VERS
    unset NATIVE_OS_ARCH
    unset NATIVE_OS_NCPU
    unset NATIVE_OS_LIBC
    unset NATIVE_OS_SUBS

    NATIVE_OS_KIND=$(os kind)
    NATIVE_OS_TYPE=$(os type)
    NATIVE_OS_NAME=$(os name)
    NATIVE_OS_VERS=$(os vers)
    NATIVE_OS_ARCH=$(os arch)
    NATIVE_OS_NCPU=$(os ncpu)
    NATIVE_OS_LIBC=$(os libc)
    NATIVE_OS_SUBS=$(os subs)
    NATIVE_OS_EUID=$(os euid)

    unset sudo

    if [ "$NATIVE_OS_EUID" -ne 0 ] && [ -z "$NATIVE_OS_SUBS" ] ; then
        sudo=sudo
    fi

    unset PACKAGE_FORMULA_LOADED
    unset AVAILABLE_PACKAGE_MANAGER_LIST

    TIMESTAMP_UNIX="$(date +%s)"

    # https://docs.github.com/en/actions/learn-github-actions/environment-variables#default-environment-variables
    # https://github.com/actions/virtual-environments/blob/main/images/linux/Ubuntu2004-Readme.md#environment-variables-3
    # if [ "$GITHUB_ACTIONS" = true ] ; then
    #     if [ -n "$ANDROID_NDK_LATEST_HOME" ] ; then
    #         export ANDROID_NDK_HOME="$ANDROID_NDK_LATEST_HOME"
    #     fi
    # fi

    __setup_PATH_env

    if [ "$NATIVE_OS_KIND" = darwin ] ; then
        ANDROID_NDK_TOOLCHAIN_HOST_TAG='darwin-x86_64'
    else
        ANDROID_NDK_TOOLCHAIN_HOST_TAG="$NATIVE_OS_KIND-$NATIVE_OS_ARCH"
    fi
}

__get_perl_home() {
    if [ -z "$1" ] ; then
        if command_exists_in_filesystem perl ; then
            __get_perl_home perl
        fi
    else
        for item in $($1 -V:config_args)
        do
            case $item in
                -Dprefix=*) getvalue "$item"; break
            esac
        done
    fi
}

__setup_PATH_env() {
    # pip install --user <PKG>
    bppend_to_PATH "$HOME/.local/bin"

    # cpan install to default local location
    bppend_to_PATH "$HOME/perl5/bin"

    PERL_HOME=$(__get_perl_home)
    if [ -n "$PERL_HOME" ] ; then
        bppend_to_PATH "$PERL_HOME/bin"
    fi

    for dir in /opt "$HOME/.uppm/install.d" "$MY_HOME_DIR/native"
    do
        if [ -d "$dir" ] ; then
            for item in $(find "$dir" -maxdepth 2 -type d -name bin)
            do
                bppend_to_PATH "$item"
            done

            for item in $(find "$dir" -maxdepth 2 -type d -name lib)
            do
                export LD_LIBRARY_DIR="$item:$LD_LIBRARY_DIR"
            done
        fi
    done

    if [ -f "$HOME/.cargo/env" ] ; then
        .   "$HOME/.cargo/env"
    fi

    # https://docs.github.com/en/actions/learn-github-actions/environment-variables#default-environment-variables
    # https://github.com/actions/virtual-environments/blob/main/images/linux/Ubuntu2004-Readme.md
    if [ "$GITHUB_ACTIONS" = true ] ; then
        if [ -n "$GOROOT_1_18_X64" ] && [ -d "$GOROOT_1_18_X64/bin" ] ; then
            bppend_to_PATH "$GOROOT_1_18_X64/bin"
        fi
    fi

    if command -v brew > /dev/null ; then
        unset __HOMEBREW_PKG_PREFIX__
        __HOMEBREW_PKG_PREFIX__="$(brew --prefix gnu-sed)"

        if [ -d "$__HOMEBREW_PKG_PREFIX__/libexec/gnubin" ] ; then
            bppend_to_PATH "$__HOMEBREW_PKG_PREFIX__/libexec/gnubin"
        fi

        unset __HOMEBREW_PKG_PREFIX__
    fi
}

help() {
    if command -v base64 > /dev/null ; then
        LOGO_BASE64_ENCODED='ICAgICAgICAgICBfIF8gICAgICAgICAgICAgICBfICAgICAgICAgCiBfIF9fICAgX198IHwgfCBf
XyAgICAgXyBfXyB8IHwgX19fXyBfIAp8ICdfIFwgLyBfYCB8IHwvIC9fX19ffCAnXyBcfCB8LyAv
IF9gIHwKfCB8IHwgfCAoX3wgfCAgIDxfX19fX3wgfF8pIHwgICA8IChffCB8CnxffCB8X3xcX18s
X3xffFxfXCAgICB8IC5fXy98X3xcX1xfXywgfAogICAgICAgICAgICAgICAgICAgICAgfF98ICAg
ICAgICB8X19fLyAK'

        if command -v lolcat > /dev/null ; then
            printf '%s\n' "$LOGO_BASE64_ENCODED" | base64 -d | lolcat -S 350
        elif command -v awk > /dev/null ; then
            printf '%s\n' "$LOGO_BASE64_ENCODED" | base64 -d | lolcat_awk
        else
            printf '%b\n' "${COLOR_BLUE}$(printf '%s\n' "$LOGO_BASE64_ENCODED" | base64 -d)${COLOR_OFF}"
        fi
    fi

    printf '%b\n' "
${COLOR_GREEN}A package manager for Android NDK to build C/C++/Rust/Go project.${COLOR_OFF}

${COLOR_GREEN}ndk-pkg <ACTION> [ARGUMENT...]${COLOR_OFF}

${COLOR_GREEN}ndk-pkg --help${COLOR_OFF}
${COLOR_GREEN}ndk-pkg -h${COLOR_OFF}
    show help of this command.

${COLOR_GREEN}ndk-pkg --version${COLOR_OFF}
${COLOR_GREEN}ndk-pkg -V${COLOR_OFF}
    show version of this command.

${COLOR_GREEN}ndk-pkg env${COLOR_OFF}
    show current machine os and android-ndk toolchain info.

${COLOR_GREEN}ndk-pkg integrate zsh   [--output-dir=<DIR>] [-x | --china]${COLOR_OFF}
    download a zsh-completion script file to a approprivate location.

${COLOR_GREEN}ndk-pkg integrate cmake [--output-dir=<DIR>] [-x | --china]${COLOR_OFF}
    download ndk-pkg.cmake to a approprivate location.

${COLOR_GREEN}ndk-pkg update${COLOR_OFF}
    update the formula repositories.

${COLOR_GREEN}ndk-pkg cleanup${COLOR_OFF}
    cleanup the unused cache.

${COLOR_GREEN}ndk-pkg ls-target-levels${COLOR_OFF}
    list the supported target sdk api-levels.

${COLOR_GREEN}ndk-pkg ls-target-triples${COLOR_OFF}
    list the supported target triples.

${COLOR_GREEN}ndk-pkg ls-target-archs${COLOR_OFF}
    list the supported target archs.

${COLOR_GREEN}ndk-pkg ls-target-abis${COLOR_OFF}
    list the supported target abis.

${COLOR_GREEN}ndk-pkg ls-available${COLOR_OFF}
    list the available packages.

${COLOR_GREEN}ndk-pkg ls-installed [--min-sdk-api-level=<MIN-SDK-API-LEVEL>]${COLOR_OFF}
    list the installed packages.

${COLOR_GREEN}ndk-pkg ls-outdated  [--min-sdk-api-level=<MIN-SDK-API-LEVEL>]${COLOR_OFF}
    list the outdated  packages.

${COLOR_GREEN}ndk-pkg is-available <PACKAGE-NAME> [eq|ne|ge|gt|le|lt VERSION]${COLOR_OFF}
    is PACKAGE available?

${COLOR_GREEN}ndk-pkg is-installed <PACKAGE-NAME> <MIN-SDK-API-LEVEL>${COLOR_OFF}
    is PACKAGE installed?

${COLOR_GREEN}ndk-pkg is-outdated  <PACKAGE-NAME> <MIN-SDK-API-LEVEL>${COLOR_OFF}
    is PACKAGE outdated?

${COLOR_GREEN}ndk-pkg search <KEYWORD>${COLOR_OFF}
    search available packages.
 
${COLOR_GREEN}ndk-pkg formula create <PACKAGE-NAME>${COLOR_OFF}
    create a new formula.

${COLOR_GREEN}ndk-pkg formula delete <PACKAGE-NAME>${COLOR_OFF}
    delete a exist formula.

${COLOR_GREEN}ndk-pkg formula rename <P1> <P2>${COLOR_OFF}
    rename a exist formula to new name.

${COLOR_GREEN}ndk-pkg formula view <PACKAGE-NAME>${COLOR_OFF}
    view the formula of the given package.

${COLOR_GREEN}ndk-pkg formula edit <PACKAGE-NAME>${COLOR_OFF}
    edit the formula of the given package.

${COLOR_GREEN}ndk-pkg formula list${COLOR_OFF}
    list all formulas.

${COLOR_GREEN}ndk-pkg formula-repo [list]${COLOR_OFF}
    list formula-repos.

${COLOR_GREEN}ndk-pkg formula-repo add <NAME> <URL>${COLOR_OFF}
    add a new formula-repo.

${COLOR_GREEN}ndk-pkg formula-repo del <NAME>${COLOR_OFF}
    delete a exist formula-repo.

${COLOR_GREEN}ndk-pkg tree <PACKAGE-NAME> <MIN-SDK-API-LEVEL> [--dirsfirst | -L N]${COLOR_OFF}
    list files of the given installed package in a tree-like format.

${COLOR_GREEN}ndk-pkg pack <PACKAGE-NAME> <MIN-SDK-API-LEVEL> <7z|zip|aar|tar.gz|tar.xz|tar.bz2>${COLOR_OFF}
    pack the given installed package.

${COLOR_GREEN}ndk-pkg deploy <PACKAGE-NAME> <MIN-SDK-API-LEVEL> mavenLocal  [-d] [-x]${COLOR_OFF}
    pack the given installed package as prefab aar and then deploy prefab aar to maven local repository.

${COLOR_GREEN}ndk-pkg deploy <PACKAGE-NAME> <MIN-SDK-API-LEVEL> mavenRemote [-d] [-x] < CONFIG-FILE${COLOR_OFF}
    pack the given installed package as prefab aar and then deploy prefab aar to maven remote repository.

    CONFIG-FILE contains following content:

    SERVER_ID=
    SERVER_URL=
    SERVER_USERNAME=
    SERVER_PASSWORD=
    GPG_PASSPHRASE=

${COLOR_GREEN}ndk-pkg logs <PACKAGE-NAME> <MIN-SDK-API-LEVEL> <armeabi-v7a|arm64-v8a|x86|x86_64>${COLOR_OFF}
    show logs of the given installed package.

${COLOR_GREEN}ndk-pkg info <PACKAGE-NAME> [KEY|--json|--shell]${COLOR_OFF}
    show information of the given package.

${COLOR_GREEN}ndk-pkg info @all [--json]${COLOR_OFF}
    show information of all the available packages.

${COLOR_GREEN}ndk-pkg fetch <PACKAGE-NAME>${COLOR_OFF}
    download formula resources of the given package to the cache.

${COLOR_GREEN}ndk-pkg fetch @all${COLOR_OFF}
    download formula resources of all available packages to the cache.

${COLOR_GREEN}ndk-pkg depends <PACKAGE-NAME> [--format=<list|json|graph>] [--brief] [-o <OUTPUT-FILE-PATH>]${COLOR_OFF}
    show or save packages that are depended by the given package.

${COLOR_GREEN}ndk-pkg homepage [--open] [PACKAGE-NAME]${COLOR_OFF}
    show or open the homepage of the given package or this project in web browser.

${COLOR_GREEN}ndk-pkg install   <PACKAGE-NAME>... [INSTALL-OPTIONS]${COLOR_OFF}
    install the given packages.

    INSTALL-OPTIONS:
        ${COLOR_BLUE}--min-sdk-api-level=N${COLOR_OFF}
        ${COLOR_BLUE}--jobs=N${COLOR_OFF}
        ${COLOR_BLUE}-q|--quiet${COLOR_OFF}
        ${COLOR_BLUE}-v|--verbose${COLOR_OFF}
        ${COLOR_BLUE}-d|--debug${COLOR_OFF}
        ${COLOR_BLUE}-x|--xtrace${COLOR_OFF}
        ${COLOR_BLUE}--build-type=<debug|release>${COLOR_OFF}
        ${COLOR_BLUE}--link-type=<static-only|shared-only|static-prefered|shared-prefered>${COLOR_OFF}
        ${COLOR_BLUE}--disable-ccache${COLOR_OFF}
        ${COLOR_BLUE}--export-compile-commands-json${COLOR_OFF}
        ${COLOR_BLUE}--tree-args=ARGS${COLOR_OFF}
        ${COLOR_BLUE}--strip-args=ARGS${COLOR_OFF}
        ${COLOR_BLUE}--dry-run${COLOR_OFF}
        ${COLOR_BLUE}--keep-work-dir${COLOR_OFF}

${COLOR_GREEN}ndk-pkg reinstall <PACKAGE-NAME>... [INSTALL-OPTIONS]${COLOR_OFF}
    reinstall the given packages.

${COLOR_GREEN}ndk-pkg upgrade   [PACKAGE-NAME]... [INSTALL-OPTIONS]${COLOR_OFF}
    upgrade the given packages or all outdated packages.

${COLOR_GREEN}ndk-pkg upgrade @self  [-x | --china]${COLOR_OFF}
    upgrade this software.

${COLOR_GREEN}ndk-pkg uninstall <PACKAGE-NAME>... [--min-sdk-api-level=<MIN-SDK-API-LEVEL>]${COLOR_OFF}
    uninstall the given packages.
    "

    if [ -z "$1" ] ; then
        exit
    else
        exit "$1"
    fi
}

main() {
    set -e

    unset RUN_SILENT

    unset XTRACE
    unset COUNTRY

    for arg in $@
    do
        case $arg in
            --xtrace|-x) XTRACE=yes; set -x ;;
            --china)     COUNTRY=china ;;
            *) [ "$XTRACE" = yes ] && [ -n "$COUNTRY" ] && break
        esac
    done

    init

    case $1 in
        ''|--help|-h) 
            help
            ;;
        --version|-V)
            printf '%s\n' "$MY_VERSION"
            ;;
        env)
            printf '%b\n' "${COLOR_GREEN}$_0 $MY_VERSION is a package manager for Android NDK to build C/C++/Rust/Go project.${COLOR_OFF}"
            printf '%s\n'
            run os
            printf '%s\n'
            run "id | tr ' ' '\n'"
            printf '%s\n'
            setup_build_toolchains_env
            ;;

        ls-target-levels)  shift; __list_supported_target_sdk_api_levels ;;
        ls-target-triples) shift; __list_supported_target_triples ;;
        ls-target-archs)   shift; __list_supported_target_archs ;;
        ls-target-abis)    shift; __list_supported_target_abis ;;

        ls-available) shift; __list_available_packages $@ ;;
        ls-installed) shift; __list_installed_packages $@ ;;
        ls-outdated)  shift; __list__outdated_packages $@ ;;

        is-available) shift; is_package_available $@ ;;
        is-installed) shift; is_package_installed $@ ;;
        is-outdated)  shift; is_package__outdated $@ ;;

        formula-repo)
            shift
            case $1 in
                list) shift; __list_formula_repositories ;;
                add)  shift; __add_a_formula_repo $@ ;;
                del)  shift; __del_a_formula_repo $@ ;;
                *) help 1
            esac
            ;;
        formula)
            shift
            case $1 in
                create) shift; __create_formula_of_the_given_package $@ ;;
                delete) shift; __delete_formula_of_the_given_package $@ ;;
                rename) shift; __rename_formula_of_the_given_package $@ ;;
                view)   shift;   __view_formula_of_the_given_package $@ ;;
                edit)   shift;   __edit_formula_of_the_given_package $@ ;;
                list)   shift; __list_formulas ;;
                   *)   help 1
            esac
            ;;
        update)  __update_formula_repositories ;;
        cleanup) __cleanup ;;

        search)  shift; __search_packages "$*" ;;

        install) shift;   __install_the_given_packages $@ ;;
      reinstall) shift; __reinstall_the_given_packages $@ ;;
      uninstall) shift; __uninstall_the_given_packages $@ ;;

        upgrade)
            shift
            case $1 in
                @self)
                    shift
                    __upgrade_self "$MY_UPGRAGE_URL" $@ ;;
                *)  __upgrade_packages $@ ;;
            esac
            ;;
        integrate)
            shift
            case $1 in
                zsh)
                    shift
                    __integrate_zsh_completions "$MY_ZSH_COMPLETION_SCRIPT_URL" $@
                    ;;
                cmake)
                    shift

                    unset XTRACE
                    unset COUNTRY
                    unset OUTPUT_DIR

                    for arg in $@
                    do
                        case $arg in
                            --xtrace|-x)
                                XTRACE=yes
                                set -x
                                ;;
                            --china)
                                COUNTRY=china
                                ;;
                            --output-dir=*)
                                OUTPUT_DIR=$(getvalue "$1")
                                if [ -z "$OUTPUT_DIR" ] ; then
                                    die "ndk-pkg integrate cmake [--output-dir=<DIR>] , <DIR> must not be empty."
                                fi
                                OUTPUT_DIR=$(globing "$OUTPUT_DIR")
                                ;;
                            *)  die "ndk-pkg integrate cmake [--output-dir=<DIR>] [--china] [-x] , unrecognized argument: $arg"
                        esac
                    done

                    [ -z "$OUTPUT_DIR" ] && OUTPUT_DIR=$MY_HOME_DIR

                    fetch 'https://raw.githubusercontent.com/leleliu008/ndk-pkg/master/ndk-pkg.cmake' --output-dir="$OUTPUT_DIR"
                    ;;
                *)  die "ndk-pkg integrate $1: not support."
            esac
            ;;
        homepage) shift;  __show_or_open_homepage_of_the_given_package $@ ;;
        depends)  shift; __show_packages_depended_by_the_given_package $@ ;;
        fetch)    shift;        __fetch_resources_of_the_given_package $@ ;;

        deploy)   shift; __deploy_prefab_aar_for_the_given_installed_package $@ ;;

        logs) shift; __logs_the_given_installed_package $@ ;;
        pack) shift; __pack_the_given_installed_package $@ ;;
        tree) shift; __tree_the_given_installed_package $@ ;;

        info)
            shift
            __show_infomation_of_the_given_package $@
            ;;
        ldd)
            shift
            __ldd $@
            ;;
        list-dynamic-library-names)
            shift
            list_dynamic_library_names_of_the_given_package $@
            ;;
        ndkmanager)
            shift
            ndkmanager $@
            ;;
        gen-github-workflows)
            shift
            __gen_github_workflows $@
            ;;
        test)
            ;;
        uppm)
            shift
            uppm $@
            ;;
        compare-versions)
            shift
            case $1 in
                brew)
                    __compare_versions_with_brew
                    ;;
                maven)
                    __compare_versions_with_maven_central
                    ;;
                '') die "$_0 compare-versions <brew|maven>, brew or maven subcommand is not given." ;;
                *)  die "unrecognized argument: $1"
            esac
            ;;
        *)  die "unrecognized argument: $1"
    esac
}

main $@
