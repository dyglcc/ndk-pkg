#!/bin/sh

# Copyright (c) 2020-2023 åˆ˜å¯Œé¢‘
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# https://developer.android.google.cn/ndk/guides/other_build_systems
# https://clang.llvm.org/docs/CrossCompilation.html

######################################################################################
####################################  convention  ####################################
# 1. The variable/function name starts with underscore "_" means that it is a private variable/function.
######################################################################################

# If IFS is not set, the deault value will be <space><tab><newline>
# https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_05_03
unset IFS

_0=$0

unset CURRENT_SCRIPT_DIR
unset CURRENT_SCRIPT_FILENAME
unset CURRENT_SCRIPT_FILEPATH

CURRENT_SCRIPT_DIR=$(cd "$(dirname "$0")" && pwd) || exit 1
CURRENT_SCRIPT_FILENAME=$(basename "$0")
CURRENT_SCRIPT_FILEPATH="$CURRENT_SCRIPT_DIR/$CURRENT_SCRIPT_FILENAME"


# }}}
##############################################################################
# {{{ utils

COLOR_RED='\033[0;31m'          # Red
COLOR_GREEN='\033[0;32m'        # Green
COLOR_YELLOW='\033[0;33m'       # Yellow
COLOR_BLUE='\033[0;94m'         # Blue
COLOR_PURPLE='\033[0;35m'       # Purple
COLOR_OFF='\033[0m'             # Reset

print() {
    printf '%b' "$*"
}

echo() {
    printf '%b\n' "$*"
}

note() {
    printf '%b\n' "${COLOR_YELLOW}ðŸ””  $*${COLOR_OFF}" >&2
}

warn() {
    printf '%b\n' "${COLOR_YELLOW}ðŸ”¥  $*${COLOR_OFF}" >&2
}

success() {
    printf '%b\n' "${COLOR_GREEN}[âœ”] $*${COLOR_OFF}" >&2
}

error() {
    printf '%b\n' "${COLOR_RED}ðŸ’”  $*${COLOR_OFF}" >&2
}

abort() {
    EXIT_STATUS_CODE="$1"
    shift
    printf '%b\n' "${COLOR_RED}ðŸ’”  $*${COLOR_OFF}" >&2
    exit "$EXIT_STATUS_CODE"
}

step() {
    STEP_NUM=$(expr ${STEP_NUM-0} + 1)
    STEP_MESSAGE="$*"
    printf '\n%b\n' "${COLOR_PURPLE}=>> STEP ${STEP_NUM} : ${STEP_MESSAGE} ${COLOR_OFF}"
}

run() {
    if [ "$RUN_SILENT" != yes ] ; then
        echo "${COLOR_PURPLE}==>${COLOR_OFF} ${COLOR_GREEN}$@${COLOR_OFF}"
    fi

    eval "$@"
}

list_size() {
    printf '%s\n' "$#"
}

is_integer() {
    case "${1#[+-]}" in
        (*[!0123456789]*) return 1 ;;
        ('')              return 1 ;;
        (*)               return 0 ;;
    esac
}

# format_unix_timestamp <TIMESTAMP-UNIX> <TO-FORMAT> [-u]
  format_unix_timestamp() {
   date $3 -jf "%s" "$1" "$2" 2> /dev/null ||
   date $3 -d      "@$1" "$2"
}

bppend_to_PATH() {
    case ":${PATH}:" in
        *:"$1":*) ;;
        *) export PATH="$1:$PATH" ;;
    esac
}

bppend_to_ACLOCAL_PATH() {
    case ":${ACLOCAL_PATH}:" in
        *:"$1":*) ;;
        *) export ACLOCAL_PATH="$1:$ACLOCAL_PATH" ;;
    esac
}

sed_in_place() {
    echo "${COLOR_PURPLE}==>${COLOR_OFF} ${COLOR_GREEN}sed -i $@${COLOR_OFF}"
    sed -i "$@"
}

git() {
    if [ -z "$SSL_CERT_FILE" ] ; then
        command git "$@"
    else
        command git -c http.sslCAInfo="$SSL_CERT_FILE" "$@"
    fi
}

# https://equa.space/sh/lolcat/
lolcat_awk() {
    awk -v angle=45 -v angle_phase=40 -v reverse=0 -v offset=195 -v offset_phase=0 -v width=100 -v width_phase=8 "$@" '
    function put_rgb(color) {
        printf "\033[%s38;2;%d;%d;%dm", reverse ? "7;" : "", int(color[1] * 255), int(color[2] * 255), int(color[3] * 255);
    }

    function hsv_to_rgb(hsv, rgb, c, h2, x) {
        c = hsv[2] * hsv[3];
        h2 = hsv[1] * 6;
        x = c * (1 - ((h2 % 2) - 1 > 0 ? (h2 % 2) - 1 : 1 - (h2 % 2)));
        if (int(h2) % 6 == 0) {
            rgb[1] = c; rgb[2] = x; rgb[3] = 0;
        } else if (int(h2) % 6 == 1) {
            rgb[1] = x; rgb[2] = c; rgb[3] = 0;
        } else if (int(h2) % 6 == 2) {
            rgb[1] = 0; rgb[2] = c; rgb[3] = x;
        } else if (int(h2) % 6 == 3) {
            rgb[1] = 0; rgb[2] = x; rgb[3] = c;
        } else if (int(h2) % 6 == 4) {
            rgb[1] = x; rgb[2] = 0; rgb[3] = c;
        } else if (int(h2) % 6 == 5) {
            rgb[1] = c; rgb[2] = 0; rgb[3] = x;
        }

        rgb[1] += hsv[2] - c;
        rgb[2] += hsv[2] - c;
        rgb[3] += hsv[2] - c;
    }

    BEGIN {
        srand();
        if (offset == "") offset = rand() * 360;
    }

    {
        y = NR - 1;
        for (x = 0; x < length($0); x++) {
            for (i = 0; i < 3; i++) {
                mult_x = cos((angle + i * angle_phase) / 57.2976);
                mult_y = sin((angle + i * angle_phase) / 57.2976);
                hsv[1] = (((x * mult_x + y * mult_y) / (width + width_phase * i)) % 1 + 1 + (offset + offset_phase * i) / 360) % 1;
                hsv[2] = 0.8;
                hsv[3] = 0.9;

                hsv_to_rgb(hsv, trgb);
                rgb[i + 1] = trgb[i + 1];
            }

            put_rgb(rgb);
            printf("%s", substr($0, x + 1, 1));
        }
        print "\033[0m";
    }
    '
}

# }}}
##############################################################################
# {{{ wfetch

# wfetch <URL> [--uri=URL-MIRROR] [--silent] [--sha256=SHA256] <--output-path=PATH>
# wfetch <URL> [--uri=URL-MIRROR] [--silent] [--sha256=SHA256] <--output-dir=DIR> <--output-name=NAME>
# wfetch <URL> [--uri=URL-MIRROR] [--silent] [--sha256=SHA256] <--output-dir=DIR> [--output-name=NAME]
# wfetch <URL> [--uri=URL-MIRROR] [--silent] [--sha256=SHA256] [--output-dir=DIR] <--output-name=NAME>

# influential environment variable:
# NDKPKG_URL_TRANSFORM
wfetch() {
    unset FETCH_URL
    unset FETCH_URI
    unset FETCH_SHA256
    unset FETCH_OUTPUT_DIR
    unset FETCH_OUTPUT_NAME
    unset FETCH_OUTPUT_PATH
    unset FETCH_SILENT

    [ -z "$1" ] && abort 1 "wfetch <URL> [OPTION]... , <URL> must be non-empty."

    if [ -z "$NDKPKG_URL_TRANSFORM" ] ; then
        FETCH_URL="$1"
    else
        FETCH_URL="$("$NDKPKG_URL_TRANSFORM" "$1")" || return 1
    fi

    shift

    while [ -n "$1" ]
    do
        case $1 in
            --silent)
                FETCH_SILENT=yes
                RUN_SILENT=yes
                ;;
            --sha256=*)
                FETCH_SHA256="${1#*=}"
                ;;
            --uri=*)
                FETCH_URI="${1#*=}"
                if [ -z "$FETCH_URI" ] ; then
                    abort 1 "wfetch <URL> --uri=<URL-MIRROR> , <URL-MIRROR> must be non-empty."
                fi
                if [ -n "$NDKPKG_URL_TRANSFORM" ] ; then
                    FETCH_URI="$("$NDKPKG_URL_TRANSFORM" "$FETCH_URI")" || return 1
                fi
                ;;
            --output-dir=*)
                FETCH_OUTPUT_DIR="${1#*=}"
                if [ -z "$FETCH_OUTPUT_DIR" ] ; then
                    abort 1 "wfetch <URL> --output-dir=<DIR> , <DIR> must be non-empty."
                fi
                ;;
            --output-name=*)
                FETCH_OUTPUT_NAME="${1#*=}"
                if [ -z "$FETCH_OUTPUT_NAME" ] ; then
                    abort 1 "wfetch <URL> --output-name=<NAME> , <NAME> must be non-empty."
                fi
                ;;
            --output-path=*)
                FETCH_OUTPUT_PATH="${1#*=}"
                if [ -z "$FETCH_OUTPUT_PATH" ] ; then
                    abort 1 "wfetch <URL> --output-path=<FILEPATH> , <FILEPATH> must be non-empty."
                fi
                ;;
            *)  abort 1 "wfetch <URL> [OPTION]..., unrecognized option: $1

    wfetch command usage:

    wfetch <URL> [--url-mirror=URL2] [--silent] [--sha256=SHA256] <--output-path=PATH>
    wfetch <URL> [--url-mirror=URL2] [--silent] [--sha256=SHA256] <--output-dir=DIR> <--output-name=NAME>
    wfetch <URL> [--url-mirror=URL2] [--silent] [--sha256=SHA256] <--output-dir=DIR> [--output-name=NAME]
    wfetch <URL> [--url-mirror=URL2] [--silent] [--sha256=SHA256] [--output-dir=DIR] <--output-name=NAME>"
        esac
        shift
    done

    if [ -z "$FETCH_URI" ] ; then
        FETCH_URI="$FETCH_URL"
    fi

    if [ -z "$FETCH_OUTPUT_PATH" ] ; then
        if [ -z "$FETCH_OUTPUT_DIR" ] && [ -z "$FETCH_OUTPUT_NAME" ] ; then
            FETCH_OUTPUT_PATH='-'
        else
            if [ -z "$FETCH_OUTPUT_DIR" ] ; then
                FETCH_OUTPUT_DIR="$PWD"
            fi

            if [ -z "$FETCH_OUTPUT_NAME" ] ; then
                FETCH_OUTPUT_NAME=$(basename "$FETCH_URL")
            fi

            FETCH_OUTPUT_PATH="$FETCH_OUTPUT_DIR/$FETCH_OUTPUT_NAME"

            if [ !          -d "$FETCH_OUTPUT_DIR" ] ; then
                run install -d "$FETCH_OUTPUT_DIR" || return 1
            fi
        fi
    elif [ "$FETCH_OUTPUT_PATH" = '-' ] ; then
        unset FETCH_OUTPUT_DIR
        unset FETCH_OUTPUT_NAME
    else
        FETCH_OUTPUT_DIR="$(dirname "$FETCH_OUTPUT_PATH")"
        FETCH_OUTPUT_NAME="$(basename "$FETCH_OUTPUT_PATH")"
        if [ !          -d "$FETCH_OUTPUT_DIR" ] ; then
            run install -d "$FETCH_OUTPUT_DIR" || return 1
        fi
    fi

    case $FETCH_URL in
        *.git)
            if [    -d "$FETCH_OUTPUT_PATH" ] ; then
                run cd "$FETCH_OUTPUT_PATH" || return 1
                if      git rev-parse HEAD > /dev/null 2>&1 ; then
                    run git pull || return 1
                    run git submodule update --recursive || return 1
                else
                    run cd .. || return 1
                    run rm -rf "$FETCH_OUTPUT_NAME" || return 1
                    run git clone --recursive "$FETCH_URL" "$FETCH_OUTPUT_NAME" || return 1
                fi
            else
                if [ !          -d "$FETCH_OUTPUT_DIR" ] ; then
                    run install -d "$FETCH_OUTPUT_DIR" || return 1
                fi
                run cd "$FETCH_OUTPUT_DIR" || return 1
                run git clone --recursive "$FETCH_URL" "$FETCH_OUTPUT_NAME" || return 1
            fi
            ;;
        *)
            if [ "$FETCH_OUTPUT_PATH" != '-' ] && [ -f "$FETCH_OUTPUT_PATH" ] ; then
                if [ -n "$FETCH_SHA256" ] ; then
                    if [ "$(sha256sum "$FETCH_OUTPUT_PATH" | cut -d ' ' -f1)" = "$FETCH_SHA256" ] ; then
                        success "$FETCH_OUTPUT_PATH already have been fetched."
                        return 0
                    fi
                fi
                rm -f "$FETCH_OUTPUT_PATH" || return 1
            fi

            for FETCH_TOOL in curl wget http lynx aria2c axel
            do
                if command -v "$FETCH_TOOL" > /dev/null ; then
                    break
                else
                    unset FETCH_TOOL
                fi
            done

            if [ -z "$FETCH_TOOL" ] ; then
                abort 1 "no fetch tool found, please install one of curl wget http lynx aria2c axel, then try again."
            fi

            case $FETCH_TOOL in
                curl)
                    unset FETCH_TOOL_CURL_EXTRA_OPTIONS

                    if [ "$FETCH_SILENT" = yes ] ; then
                        FETCH_TOOL_CURL_OPTIONS='--no-progress-meter'
                    fi

                    if [ -n "$SSL_CERT_FILE" ] ; then
                        FETCH_TOOL_CURL_OPTIONS="--cacert $SSL_CERT_FILE"
                    fi

                    run "curl $FETCH_TOOL_CURL_OPTIONS --fail --retry 20 --retry-delay 30 --location -o '$FETCH_OUTPUT_PATH' '$FETCH_URL'" ||
                    run "curl $FETCH_TOOL_CURL_OPTIONS --fail --retry 20 --retry-delay 30 --location -o '$FETCH_OUTPUT_PATH' '$FETCH_URI'"
                    ;;
                wget)
                    run "wget --timeout=60 -O '$FETCH_OUTPUT_PATH' '$FETCH_URL'" ||
                    run "wget --timeout=60 -O '$FETCH_OUTPUT_PATH' '$FETCH_URI'"
                    ;;
                http)
                    run "http --timeout=60 -o '$FETCH_OUTPUT_PATH' '$FETCH_URL'" ||
                    run "http --timeout=60 -o '$FETCH_OUTPUT_PATH' '$FETCH_URI'"
                    ;;
                lynx)
                    run "lynx -source '$FETCH_URL' > '$FETCH_OUTPUT_PATH'" ||
                    run "lynx -source '$FETCH_URI' > '$FETCH_OUTPUT_PATH'"
                    ;;
                aria2c)
                    run "aria2c -d '$FETCH_OUTPUT_DIR' -o '$FETCH_OUTPUT_NAME' '$FETCH_URL'" ||
                    run "aria2c -d '$FETCH_OUTPUT_DIR' -o '$FETCH_OUTPUT_NAME' '$FETCH_URI'"
                    ;;
                axel)
                    run "axel -o '$FETCH_OUTPUT_PATH' '$FETCH_URL'" ||
                    run "axel -o '$FETCH_OUTPUT_PATH' '$FETCH_URI'"
                    ;;
                *)  abort 1 "wfetch() unimplementation: $FETCH_TOOL"
                    ;;
            esac

            [ $? -eq 0 ] || return 1

            if [ "$FETCH_OUTPUT_PATH" != '-' ] && [ -n "$FETCH_SHA256" ] ; then
                [ "$(sha256sum "$FETCH_OUTPUT_PATH" | cut -d ' ' -f1)" = "$FETCH_SHA256" ] || {
                    abort 1 "sha256sum mismatch.\n    expect : $FETCH_SHA256\n    actual : $(sha256sum "$FETCH_OUTPUT_PATH" | cut -d ' ' -f1)"
                }
            fi
    esac
}

# }}}
##############################################################################
# {{{ version

version_sort() {
    # https://pubs.opengroup.org/onlinepubs/9699919799/utilities/sort.html
    # https://man.netbsd.org/NetBSD-8.1/i386/sort.1
    #
    # sort: unrecognized option: V
    # BusyBox v1.29.3 (2019-01-24 07:45:07 UTC) multi-call binary.
    # Usage: sort [-nrugMcszbdfiokt] [-o FILE] [-k start[.offset][opts][,end[.offset][opts]] [-t CHAR] [FILE]...
    if  printf '\n' | (sort -V > /dev/null 2>&1) ; then
        printf '%s\n' "$*" | tr ' ' '\n' | sort -V
    else
        printf '%s\n' "$*" | tr ' ' '\n' | sort -t. -n -k1,1 -k2,2 -k3,3 -k4,4
    fi
}

# check if match the condition
#
# condition:
# eq  equal
# ne  not equal
# gt  greater than
# lt  less than
# ge  greater than or equal
# le  less than or equal
#
# examples:
# version_match 1.15.3 eq 1.16.0
# version_match 1.15.3 lt 1.16.0
# version_match 1.15.3 gt 1.16.0
# version_match 1.15.3 le 1.16.0
# version_match 1.15.3 ge 1.16.0
version_match() {
    case $2 in
        eq)  [ "$1"  = "$3" ] ;;
        ne)  [ "$1" != "$3" ] ;;
        le)
            if [ "$1" = "$3" ] ; then
                return 0
            fi
            [ "$1" = "$(version_sort "$1" "$3" | head -n 1)" ]
            ;;
        ge)
            if [ "$1" = "$3" ] ; then
                return 0
            fi
            [ "$1" = "$(version_sort "$1" "$3" | tail -n 1)" ]
            ;;
        lt)
            if [ "$1" = "$3" ] ; then
                return 1
            fi
            [ "$1" = "$(version_sort "$1" "$3" | head -n 1)" ]
            ;;
        gt)
            if [ "$1" = "$3" ] ; then
                return 1
            fi
            [ "$1" = "$(version_sort "$1" "$3" | tail -n 1)" ]
            ;;
        *)  abort 1 "version_compare: $2: not supported operator."
    esac
}

# }}}
##############################################################################
# {{{ __load_formula_repository_config

# __load_formula_repository_config <REPO-NAME> [REPO-PATH]
  __load_formula_repository_config() {
    NDKPKG_FORMULA_REPO_NAME="$1"
    NDKPKG_FORMULA_REPO_PATH="$NDKPKG_HOME/repos.d/$1"
    NDKPKG_FORMULA_REPO_CONFIG_FILEPATH="$NDKPKG_FORMULA_REPO_PATH/.ndk-pkg-formula-repo.yml"

    [ -d "$NDKPKG_FORMULA_REPO_PATH" ] || abort 1 "$1 named formula repository does not exist."
    [ -f "$NDKPKG_FORMULA_REPO_CONFIG_FILEPATH" ] || abort 1 "$1 formula repository is broken."

    NDKPKG_FORMULA_REPO_URL=
    NDKPKG_FORMULA_REPO_BRANCH=
    NDKPKG_FORMULA_REPO_PINNED=
    NDKPKG_FORMULA_REPO_ENABLED=
    NDKPKG_FORMULA_REPO_TIMESTAMP_CREATED=
    NDKPKG_FORMULA_REPO_TIMESTAMP_UPDATED=

    NDKPKG_FORMULA_REPO_URL="$(yq .url "$NDKPKG_FORMULA_REPO_CONFIG_FILEPATH")"

    [ "$NDKPKG_FORMULA_REPO_URL" = null ] && abort 1 "$1 formula repository is broken."

    NDKPKG_FORMULA_REPO_BRANCH="$(yq .branch "$NDKPKG_FORMULA_REPO_CONFIG_FILEPATH")"

    [ "$NDKPKG_FORMULA_REPO_BRANCH" = null ] && abort 1 "$1 formula repository is broken."

    NDKPKG_FORMULA_REPO_PINNED="$(yq .pinned "$NDKPKG_FORMULA_REPO_CONFIG_FILEPATH")"

    case $NDKPKG_FORMULA_REPO_PINNED in
        0|1) ;;
        *)   abort 1 "$1 formula repository is broken."
    esac

    NDKPKG_FORMULA_REPO_ENABLED="$(yq .enabled "$NDKPKG_FORMULA_REPO_CONFIG_FILEPATH")"

    case $NDKPKG_FORMULA_REPO_ENABLED in
        0|1) ;;
        *)   abort 1 "$1 formula repository is broken."
    esac

    NDKPKG_FORMULA_REPO_TIMESTAMP_CREATED="$(yq .timestamp-created "$NDKPKG_FORMULA_REPO_CONFIG_FILEPATH")"

    [ "${#NDKPKG_FORMULA_REPO_TIMESTAMP_CREATED}" -eq 10 ] || abort 1 "$1 formula repository is broken."

    NDKPKG_FORMULA_REPO_TIMESTAMP_UPDATED="$(yq .timestamp-updated "$NDKPKG_FORMULA_REPO_CONFIG_FILEPATH")"

    if [ "$NDKPKG_FORMULA_REPO_TIMESTAMP_UPDATED" = null ] ; then
           NDKPKG_FORMULA_REPO_TIMESTAMP_UPDATED=
    else
        [ "${#NDKPKG_FORMULA_REPO_TIMESTAMP_UPDATED}" -eq 10 ] || abort 1 "$1 formula repository is broken."
    fi
}

# }}}
##############################################################################
# {{{ ndk-pkg formula-repo-add

# __create_a_formula_repository_then_sync_it <REPO-NAME> <REPO-URL> [--branch=VALUE --pin/--unpin --enable/--disable]
  __create_a_formula_repository_then_sync_it() {
    [ -z "$1" ] && abort 1 "please specify a repository name."
    [ -z "$2" ] && abort 1 "please specify a repository url."

    NDKPKG_FORMULA_REPO_NAME="$1"
    NDKPKG_FORMULA_REPO_URL="$2"

    if [ -z "$NDKPKG_URL_TRANSFORM" ] ; then
        GIT_FETCH_URL="$NDKPKG_FORMULA_REPO_URL"
    else
        GIT_FETCH_URL="$("$NDKPKG_URL_TRANSFORM" "$NDKPKG_FORMULA_REPO_URL")"
    fi

    shift 2

    NDKPKG_FORMULA_REPO_BRANCH=
    NDKPKG_FORMULA_REPO_PINNED=
    NDKPKG_FORMULA_REPO_ENABLED=

    while [ -n "$1" ]
    do
        case $1 in
            --branch=*)
                NDKPKG_FORMULA_REPO_BRANCH="${1#*=}"
                ;;
            --pin)
                NDKPKG_FORMULA_REPO_PINNED=1
                ;;
            --unpin)
                NDKPKG_FORMULA_REPO_PINNED=0
                ;;
            --enable)
                NDKPKG_FORMULA_REPO_ENABLED=1
                ;;
            --disable)
                NDKPKG_FORMULA_REPO_ENABLED=0
                ;;
            *)  abort 1 "unrecognized argument: $1"
        esac
        shift
    done

    NDKPKG_FORMULA_REPO_BRANCH="${NDKPKG_FORMULA_REPO_BRANCH:-master}"
    NDKPKG_FORMULA_REPO_PINNED="${NDKPKG_FORMULA_REPO_PINNED:-0}"
    NDKPKG_FORMULA_REPO_ENABLED="${NDKPKG_FORMULA_REPO_ENABLED:-1}"

    NDKPKG_FORMULA_REPO_PATH="$NDKPKG_HOME/repos.d/$NDKPKG_FORMULA_REPO_NAME"

    [ -d "$NDKPKG_FORMULA_REPO_PATH" ] && abort 1 "$NDKPKG_FORMULA_REPO_NAME named formula repository already exists."

    printf '%b\n' "${COLOR_PURPLE}==> Adding formula repository${COLOR_OFF} ${COLOR_GREEN}$NDKPKG_FORMULA_REPO_NAME${COLOR_OFF}"

    run install -d "$NDKPKG_FORMULA_REPO_PATH"

    __create_a_formula_repository_then_sync_it_onexit() {
        if [ ! -f  "$NDKPKG_FORMULA_REPO_PATH/.ndk-pkg-formula-repo.yml" ] ; then
            rm -rf "$NDKPKG_FORMULA_REPO_PATH/"
        fi
    }

    trap __create_a_formula_repository_then_sync_it_onexit EXIT

    run cd "$NDKPKG_FORMULA_REPO_PATH"

    run git -c init.defaultBranch=master init
    run git remote add origin "$GIT_FETCH_URL"
    run git -c protocol.version=2 fetch --progress origin "+refs/heads/$NDKPKG_FORMULA_REPO_BRANCH:refs/remotes/origin/$NDKPKG_FORMULA_REPO_BRANCH"
    run git checkout --progress --force -B "$NDKPKG_FORMULA_REPO_BRANCH" "refs/remotes/origin/$NDKPKG_FORMULA_REPO_BRANCH"

    cat > .ndk-pkg-formula-repo.yml <<EOF
url: $NDKPKG_FORMULA_REPO_URL
branch: $NDKPKG_FORMULA_REPO_BRANCH
pinned: $NDKPKG_FORMULA_REPO_PINNED
enabled: $NDKPKG_FORMULA_REPO_ENABLED
timestamp-created: $TIMESTAMP_UNIX
EOF
}

# }}}
##############################################################################
# {{{ ndk-pkg formula-repo-init

# __create_a_formula_repository <REPO-NAME> <REPO-URL> [--branch=VALUE --pin/--unpin --enable/--disable]
  __create_a_formula_repository() {
    [ -z "$1" ] && abort 1 "please specify a repository name."
    [ -z "$2" ] && abort 1 "please specify a repository url."

    NDKPKG_FORMULA_REPO_NAME="$1"

    if [ -z "$NDKPKG_URL_TRANSFORM" ] ; then
        NDKPKG_FORMULA_REPO_URL="$2"
    else
        NDKPKG_FORMULA_REPO_URL="$("$NDKPKG_URL_TRANSFORM" "$2")"
    fi

    shift 2

    NDKPKG_FORMULA_REPO_BRANCH=
    NDKPKG_FORMULA_REPO_PINNED=
    NDKPKG_FORMULA_REPO_ENABLED=

    while [ -n "$1" ]
    do
        case $1 in
            --branch=*)
                NDKPKG_FORMULA_REPO_BRANCH="${1#*=}"
                ;;
            --pin)
                NDKPKG_FORMULA_REPO_PINNED=1
                ;;
            --unpin)
                NDKPKG_FORMULA_REPO_PINNED=0
                ;;
            --enable)
                NDKPKG_FORMULA_REPO_ENABLED=1
                ;;
            --disable)
                NDKPKG_FORMULA_REPO_ENABLED=0
                ;;
            *)  abort 1 "unrecognized argument: $1"
        esac
        shift
    done

    NDKPKG_FORMULA_REPO_BRANCH="${NDKPKG_FORMULA_REPO_BRANCH:-master}"
    NDKPKG_FORMULA_REPO_PINNED="${NDKPKG_FORMULA_REPO_PINNED:-1}"
    NDKPKG_FORMULA_REPO_ENABLED="${NDKPKG_FORMULA_REPO_ENABLED:-1}"

    NDKPKG_FORMULA_REPO_PATH="$NDKPKG_HOME/repos.d/$NDKPKG_FORMULA_REPO_NAME"

    [ -d "$NDKPKG_FORMULA_REPO_PATH" ] && abort 1 "$NDKPKG_FORMULA_REPO_NAME named formula repository already exists."

    printf '%b\n' "${COLOR_PURPLE}==> Creating formula repository${COLOR_OFF} ${COLOR_GREEN}$NDKPKG_FORMULA_REPO_NAME${COLOR_OFF}"

    run install -d "$NDKPKG_FORMULA_REPO_PATH"

    run cd "$NDKPKG_FORMULA_REPO_PATH"

    run git -c init.defaultBranch=master init
    run git remote add origin "$NDKPKG_FORMULA_REPO_URL"

    cat > .ndk-pkg-formula-repo.yml <<EOF
url: $NDKPKG_FORMULA_REPO_URL
branch: $NDKPKG_FORMULA_REPO_BRANCH
pinned: $NDKPKG_FORMULA_REPO_PINNED
enabled: $NDKPKG_FORMULA_REPO_ENABLED
timestamp-created: $TIMESTAMP_UNIX
EOF
}

# }}}
##############################################################################
# {{{ ndk-pkg formula-repo-del

# __delete_a_formula_repository <REPO-NAME>
  __delete_a_formula_repository() {
    [ -z "$1" ] && abort 1 "please specify a repository name."

    [ "$1" = 'offical-core' ] && abort 1 "'offical-core' formula repository is not allowed to delete."

    if [ -d    "$NDKPKG_HOME/repos.d/$1" ] ; then
        rm -rf "$NDKPKG_HOME/repos.d/$1"
    else
        warn "'$1' named formula repository does not exist."
    fi
}

# }}}
##############################################################################
# {{{ ndk-pkg formula-repo-sync

# __sync_the_given_formula_repository <REPO-NAME>
  __sync_the_given_formula_repository() {
    [ -z "$1" ] && abort 1 "please specify a repository name."

    __load_formula_repository_config "$1"

    [ "$NDKPKG_FORMULA_REPO_PINNED" = 1 ] && abort 1 "'$NDKPKG_FORMULA_REPO_NAME' named formula repository is pinned."

    if [ -z "$NDKPKG_URL_TRANSFORM" ] ; then
        GIT_FETCH_URL="$NDKPKG_FORMULA_REPO_URL"
    else
        GIT_FETCH_URL="$("$NDKPKG_URL_TRANSFORM" "$NDKPKG_FORMULA_REPO_URL")"
    fi

    printf '%b\n' "${COLOR_PURPLE}==> Updating formula repository${COLOR_OFF} ${COLOR_GREEN}$NDKPKG_FORMULA_REPO_NAME${COLOR_OFF}"

    run cd "$NDKPKG_FORMULA_REPO_PATH"
    run git remote set-url origin "$GIT_FETCH_URL"
    run git -c protocol.version=2 fetch --progress origin "+refs/heads/$NDKPKG_FORMULA_REPO_BRANCH:refs/remotes/origin/$NDKPKG_FORMULA_REPO_BRANCH"
    run git checkout --progress --force -B "$NDKPKG_FORMULA_REPO_BRANCH" "refs/remotes/origin/$NDKPKG_FORMULA_REPO_BRANCH"

    cat > .ndk-pkg-formula-repo.yml <<EOF
url: $NDKPKG_FORMULA_REPO_URL
branch: $NDKPKG_FORMULA_REPO_BRANCH
pinned: $NDKPKG_FORMULA_REPO_PINNED
enabled: $NDKPKG_FORMULA_REPO_ENABLED
timestamp-created: $NDKPKG_FORMULA_REPO_TIMESTAMP_CREATED
timestamp-updated: $TIMESTAMP_UNIX
EOF
}

# }}}
##############################################################################
# {{{ ndk-pkg formula-repo-conf

# __conf_the_given_formula_repository <REPO-NAME> [--url=VALUE --branch=VALUE --pin/--unpin --enable/--disable]
  __conf_the_given_formula_repository() {
    [ -z "$1" ] && abort 1 "please specify a repository name."
    [ -z "$2" ] && abort 1 "at least one option should be given. supported options are: --url=VALUE --branch=VALUE --pin/--unpin --enable/--disable"

    __load_formula_repository_config "$1"

    shift

    while [ -n "$1" ]
    do
        case $1 in
            --url=*)
                FORMULA_REPO_URL="${1#*=}"

                if [ -z "$FORMULA_REPO_URL" ] ; then
                    abort 1 "--url=<VALUE> , <VALUE> should be non-empty."
                else
                    NDKPKG_FORMULA_REPO_URL="$FORMULA_REPO_URL"
                fi
                ;;
            --branch=*)
                FORMULA_REPO_BRANCH="${1#*=}"

                if [ -z "$FORMULA_REPO_BRANCH" ] ; then
                    abort 1 "--branch=<VALUE> , <VALUE> should be non-empty."
                else
                    NDKPKG_FORMULA_REPO_BRANCH="$FORMULA_REPO_BRANCH"
                fi
                ;;
            --pin)
                NDKPKG_FORMULA_REPO_PINNED=1
                ;;
            --unpin)
                NDKPKG_FORMULA_REPO_PINNED=0
                ;;
            --enable)
                NDKPKG_FORMULA_REPO_ENABLED=1
                ;;
            --disable)
                NDKPKG_FORMULA_REPO_ENABLED=0
                ;;
            *)  abort 1 "unrecognized argument: $1"
        esac
        shift
    done

    if [ -z "$NDKPKG_FORMULA_REPO_TIMESTAMP_UPDATED" ] ; then
        cat > "$NDKPKG_FORMULA_REPO_PATH/.ndk-pkg-formula-repo.yml" <<EOF
url:  $NDKPKG_FORMULA_REPO_URL
branch: $NDKPKG_FORMULA_REPO_BRANCH
pinned:  $NDKPKG_FORMULA_REPO_PINNED
enabled: $NDKPKG_FORMULA_REPO_ENABLED
timestamp-created: $NDKPKG_FORMULA_REPO_TIMESTAMP_CREATED
EOF
    else
        cat > "$NDKPKG_FORMULA_REPO_PATH/.ndk-pkg-formula-repo.yml" <<EOF
url:  $NDKPKG_FORMULA_REPO_URL
branch: $NDKPKG_FORMULA_REPO_BRANCH
pinned:  $NDKPKG_FORMULA_REPO_PINNED
enabled: $NDKPKG_FORMULA_REPO_ENABLED
timestamp-created: $NDKPKG_FORMULA_REPO_TIMESTAMP_CREATED
timestamp-updated: $NDKPKG_FORMULA_REPO_TIMESTAMP_UPDATED
EOF
fi
}

# }}}
##############################################################################
# {{{ ndk-pkg formula-repo-info

# __info_the_given_formula_repository <REPO-NAME>
  __info_the_given_formula_repository() {
    [ -z "$1" ] && abort 1 "please specify a repository name."

    __load_formula_repository_config "$1"

    case $NDKPKG_FORMULA_REPO_PINNED in
        0)  NDKPKG_FORMULA_REPO_PINNED=no ;;
        1)  NDKPKG_FORMULA_REPO_PINNED=yes ;;
    esac

    case $NDKPKG_FORMULA_REPO_ENABLED in
        0)  NDKPKG_FORMULA_REPO_ENABLED=no ;;
        1)  NDKPKG_FORMULA_REPO_ENABLED=yes ;;
    esac

    cat <<EOF
name: $NDKPKG_FORMULA_REPO_NAME
path: $NDKPKG_FORMULA_REPO_PATH
url:  $NDKPKG_FORMULA_REPO_URL
branch: $NDKPKG_FORMULA_REPO_BRANCH
pinned: $NDKPKG_FORMULA_REPO_PINNED
enabled: $NDKPKG_FORMULA_REPO_ENABLED
timestamp-created: $(format_unix_timestamp "$NDKPKG_FORMULA_REPO_TIMESTAMP_CREATED" '+%Y-%m-%d %H:%M:%S%:z')
EOF

    if [ -n "$NDKPKG_FORMULA_REPO_TIMESTAMP_UPDATED" ] ; then
        printf 'timestamp-updated: %s\n' "$(format_unix_timestamp "$NDKPKG_FORMULA_REPO_TIMESTAMP_UPDATED" '+%Y-%m-%d %H:%M:%S%:z')"
    fi
}

# }}}
##############################################################################
# {{{ ndk-pkg update

__sync_available_formula_repositories() {
    [ -d "$NDKPKG_FORMULA_REPO_ROOT" ] && {
        for item in $(cd "$NDKPKG_FORMULA_REPO_ROOT" && ls)
        do
            if [ -f "$NDKPKG_FORMULA_REPO_ROOT/$item/.ndk-pkg-formula-repo.yml" ] ; then
                __sync_the_given_formula_repository "$item"
            fi
        done
    }

    [ -d "$NDKPKG_FORMULA_REPO_ROOT/offical-core" ] || {
        __create_a_formula_repository_then_sync_it offical-core "$NDKPKG_OFFICAL_FORMULA_REPO_URL"
    }
}

# }}}
##############################################################################
# {{{ ndk-pkg formula-repo-list

__list_available_formula_repositories() {
    [ -d "$NDKPKG_FORMULA_REPO_ROOT" ] || return 0

    I=0

    for item in $(cd "$NDKPKG_FORMULA_REPO_ROOT" && ls)
    do
        if [ -f "$NDKPKG_FORMULA_REPO_ROOT/$item/.ndk-pkg-formula-repo.yml" ] ; then
            I="$(expr "$I" + 1)"

            [ "$I" -gt 1 ] && printf '\n'

            __info_the_given_formula_repository "$item"
        fi
    done
}

# __path_of_formula_of_the_given_package <PACKAGE-NAME>
  __path_of_formula_of_the_given_package() {
    [ -z "$1" ] && abort 1 "__path_of_formula_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is unspecified."

    [ -d "$NDKPKG_FORMULA_REPO_ROOT" ] || return 0

    AVAILABLE_FORMULA_REPOSITORY_NAMES=

    for item in $(cd "$NDKPKG_FORMULA_REPO_ROOT" && ls)
    do
        if [ -f "$NDKPKG_FORMULA_REPO_ROOT/$item/.ndk-pkg-formula-repo.yml" ] ; then
            AVAILABLE_FORMULA_REPOSITORY_NAMES="$AVAILABLE_FORMULA_REPOSITORY_NAMES $item"
        fi
    done

    for FORMULA_REPOSITORY_NAME in $AVAILABLE_FORMULA_REPOSITORY_NAMES
    do
        if [ -e           "$NDKPKG_FORMULA_REPO_ROOT/$FORMULA_REPOSITORY_NAME/formula/$NATIVE_OS_TYPE/$1.yml" ] ; then
            printf '%s\n' "$NDKPKG_FORMULA_REPO_ROOT/$FORMULA_REPOSITORY_NAME/formula/$NATIVE_OS_TYPE/$1.yml"
            return 0
        fi

        if [ -e           "$NDKPKG_FORMULA_REPO_ROOT/$FORMULA_REPOSITORY_NAME/formula/$1.yml" ] ; then
            printf '%s\n' "$NDKPKG_FORMULA_REPO_ROOT/$FORMULA_REPOSITORY_NAME/formula/$1.yml"
            return 0
        fi
    done
}

# }}}
##############################################################################
# {{{ formula parse

filetype_from_url() {
    # remove query params
    URL="${1%%'?'*}"

    case $URL in
        *.tar.gz|*.tgz)
            printf '%s\n' '.tgz'
            ;;
        *.tar.lz|*.tlz)
            printf '%s\n' '.tlz'
            ;;
        *.tar.xz|*.txz)
            printf '%s\n' '.txz'
            ;;
        *.tar.bz2|*.tbz2)
            printf '%s\n' '.tbz2'
            ;;
        *)  printf '%s\n' ".${URL##*.}"
    esac
}

# __load_formula_of_the_given_package <PACKAGE-NAME> [FORMULA-FILEPATH]
  __load_formula_of_the_given_package() {
    [ -z "$1" ] && abort 1 "__load_formula_of_the_given_package <PACKAGE-NAME> [FORMULA-FILEPATH], <PACKAGE-NAME> is unspecified."

    unset PACKAGE_FORMULA_FILEPATH

    unset PACKAGE_FORMULA_LOADED

    unset PACKAGE_NAME
    unset PACKAGE_NAME_UPPERCASE_UNDERSCORE

    unset PACKAGE_SUMMARY
    unset PACKAGE_WEB_URL

    unset PACKAGE_GIT_URL
    unset PACKAGE_GIT_SHA
    unset PACKAGE_GIT_REF
    unset PACKAGE_SHALLOW

    unset PACKAGE_SVN_URL

    unset PACKAGE_SRC_URL
    unset PACKAGE_SRC_URI
    unset PACKAGE_SRC_SHA
    unset PACKAGE_SRC_FILENAME
    unset PACKAGE_SRC_FILETYPE
    unset PACKAGE_SRC_FILEPATH

    unset PACKAGE_FIX_URL
    unset PACKAGE_FIX_URI
    unset PACKAGE_FIX_SHA
    unset PACKAGE_FIX_FILENAME
    unset PACKAGE_FIX_FILETYPE
    unset PACKAGE_FIX_FILEPATH

    unset PACKAGE_RES_URL
    unset PACKAGE_RES_URI
    unset PACKAGE_RES_SHA
    unset PACKAGE_RES_FILENAME
    unset PACKAGE_RES_FILETYPE
    unset PACKAGE_RES_FILEPATH

    unset PACKAGE_VERSION
    unset PACKAGE_VERSION_MAJOR
    unset PACKAGE_VERSION_MINOR
    unset PACKAGE_VERSION_PATCH
    unset PACKAGE_VERSION_TWEAK

    unset PACKAGE_DEVELOPER

    unset PACKAGE_LICENSE

    unset PACKAGE_BSYSTEM

    unset PACKAGE_BUILD_SYSTEM
    unset PACKAGE_BUILD_SYSTEM_GO
    unset PACKAGE_BUILD_SYSTEM_RAKE
    unset PACKAGE_BUILD_SYSTEM_NINJA
    unset PACKAGE_BUILD_SYSTEM_GMAKE
    unset PACKAGE_BUILD_SYSTEM_CMAKE
    unset PACKAGE_BUILD_SYSTEM_XMAKE
    unset PACKAGE_BUILD_SYSTEM_MESON
    unset PACKAGE_BUILD_SYSTEM_CARGO
    unset PACKAGE_BUILD_SYSTEM_AUTOGENSH
    unset PACKAGE_BUILD_SYSTEM_AUTOTOOLS
    unset PACKAGE_BUILD_SYSTEM_CONFIGURE
    unset PACKAGE_BUILD_SYSTEM_NDK_BUILD

    # package support min sdk api level
    unset PACKAGE_API_MIN

    # dir relative to $PACKAGE_WORKING_DIR/src, which contains build script such as autogen.sh, configure, Makefile, CMakeLists.txt, meson.build, Cargo.toml, xmake.lua, etc.
    unset PACKAGE_BSCRIPT

    # if build in build script dir, otherwise build in build dir
    unset PACKAGE_BINBSTD
    unset PACKAGE_BUILD_IN_BSCRIPT_DIR

    # if build in parallel
    unset PACKAGE_BUILD_IN_PARALLEL
    unset PACKAGE_PARALLEL

    # space-separated    perl modules that are depended by this package when installing and/or runtime, which will be installed via cpan
    unset PACKAGE_DEP_PLM

    # space-separated python packages that are depended by this package when installing and/or runtime, which will be installed via pip3
    unset PACKAGE_DEP_PYM

    # space-separated   ndk-pkg packages that are depended by this package when installing and/or runtime, which will be installed via uppm
    unset PACKAGE_DEP_UPP

    # space-separated   ndk-pkg packages that are depended by this package when installing and/or runtime, which will be installed via ndk-pkg
    unset PACKAGE_DEP_PKG

    unset PACKAGE_PPFLAGS
    unset PACKAGE_CCFLAGS
    unset PACKAGE_XXFLAGS
    unset PACKAGE_LDFLAGS

    unset PACKAGE_FORMULA_FILEPATH

    unset -f dopatch
    unset -f dobuild

    #########################################################################################

    if [ -z "$2" ] ; then
        PACKAGE_FORMULA_FILEPATH="$(__path_of_formula_of_the_given_package "$1")"
    else
        PACKAGE_FORMULA_FILEPATH="$2"
    fi

    if [ -z "$PACKAGE_FORMULA_FILEPATH" ] ; then
        abort 1 "package '$1' is not available."
    fi

    #########################################################################################

    for key in summary web-url git-url git-sha git-ref shallow src-url src-uri src-sha fix-url fix-sha res-url res-sha dep-pkg dep-upp dep-pym dep-plm license version bsystem bscript binbstd ccflags xxflags ppflags ldflags parallel api-min
    do
        unset __KEY_UPPERCASE_UNDERSCORE__
        unset __VALUE__

        __KEY_UPPERCASE_UNDERSCORE__="$(printf '%s\n' "$key" | tr '-' '_' | tr a-z A-Z)"
        __VALUE__="$(yq ".$key" "$PACKAGE_FORMULA_FILEPATH")"

        if [ "$__VALUE__" = null ] ; then
               __VALUE__=
        fi

        eval "PACKAGE_$__KEY_UPPERCASE_UNDERSCORE__='$__VALUE__'"
    done

    #########################################################################################

    PACKAGE_DEVELOPER="$(yq '.developer | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"

    PACKAGE_BUILD0_ACTIONS=
    PACKAGE_BUILD0_ACTIONS="$(yq '.build0   | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"

    PACKAGE_DOPATCH_ACTIONS=
    PACKAGE_DOPATCH_ACTIONS="$(yq '.dopatch | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"

    PACKAGE_DOBUILD_ACTIONS=
    PACKAGE_DOBUILD_ACTIONS="$(yq '.install | select(. != null)' "$PACKAGE_FORMULA_FILEPATH")"

    #########################################################################################

    if [ -z "$PACKAGE_BSYSTEM" ] && [ -n "$PACKAGE_DOBUILD_ACTIONS" ] ; then
        for FirstWordOfLineInInstallActions in $(printf '%s\n' "$PACKAGE_DOBUILD_ACTIONS" | sed 's|^[[:space:]]*||' | cut -d ' ' -f1)
        do
            case "$FirstWordOfLineInInstallActions" in
                configure)    PACKAGE_BSYSTEM=configure ; break ;;
                cmakew)       PACKAGE_BSYSTEM=cmake ; break ;;
                xmakew)       PACKAGE_BSYSTEM=xmake ; break ;;
                mesonw)       PACKAGE_BSYSTEM=meson ; break ;;
                gmakew)       PACKAGE_BSYSTEM=gmake ; break ;;
                cargow)       PACKAGE_BSYSTEM=cargo ; break ;;
                go|gow)       PACKAGE_BSYSTEM=go    ; break ;;
            esac
        done
    fi

    #########################################################################################

    PACKAGE_NAME="$1"
    PACKAGE_NAME_UPPERCASE_UNDERSCORE=$(printf '%s\n' "$PACKAGE_NAME" | tr a-z A-Z | tr '@+-.' '_')

    PACKAGE_BUILD_SYSTEM=$PACKAGE_BSYSTEM

    if [ -z "$PACKAGE_SHALLOW" ] ; then
        PACKAGE_SHALLOW=yes
    fi

    if [ -z "$PACKAGE_BINBSTD" ] ; then
        PACKAGE_BINBSTD=no
        PACKAGE_BUILD_IN_BSCRIPT_DIR=no
    else
        PACKAGE_BUILD_IN_BSCRIPT_DIR=$PACKAGE_BINBSTD
    fi

    if [ -z "$PACKAGE_PARALLEL" ] ; then
        PACKAGE_PARALLEL=yes
        PACKAGE_BUILD_IN_PARALLEL=yes
    else
        PACKAGE_BUILD_IN_PARALLEL="$PACKAGE_PARALLEL"
    fi

    [ -z "$PACKAGE_SUMMARY" ] && abort 1 "summary mapping not found in $PACKAGE_FORMULA_FILEPATH"

    if [ -z "$PACKAGE_WEB_URL" ] && [ -z "$PACKAGE_GIT_URL" ] ; then
        abort 1 "neither web-url nor git-url mapping was found in $PACKAGE_FORMULA_FILEPATH"
    fi

    #########################################################################################

    if [ -z "$PACKAGE_SRC_URL" ] ; then
        if [ -z "$PACKAGE_GIT_URL" ] ; then
            abort 1 "neither src-url nor git-url mapping was found in $PACKAGE_FORMULA_FILEPATH"
        else
            PACKAGE_SRC_FILETYPE=.git
            PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP git"
        fi
    else
        case $PACKAGE_SRC_URL in
            dir://*)
                PACKAGE_SRC_FILETYPE=.dir ;;
            *)  PACKAGE_SRC_FILETYPE="$(filetype_from_url "$PACKAGE_SRC_URL")"

                case $PACKAGE_SRC_FILETYPE in
                    .zip)     PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP curl unzip"      ;;
                    .txz)     PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP curl gtar xz"    ;;
                    .tgz)     PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP curl gtar gzip"  ;;
                    .tlz)     PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP curl gtar lzip"  ;;
                    .tbz2)    PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP curl gtar bzip2" ;;
                    *)        PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP curl"            ;;
                esac
        esac
    fi

    #########################################################################################

    case $PACKAGE_SRC_FILETYPE in
        .dir)
            PACKAGE_SRC_FILEPATH=$(printf '%s\n' "$PACKAGE_SRC_URL" | cut -c7-)

            if [ -z "$PACKAGE_VERSION" ] ; then
                PACKAGE_VERSION="$(format_unix_timestamp "$TIMESTAMP_UNIX" '+%Y.%m.%d')"
            fi
            ;;
        .git)
            PACKAGE_SRC_FILENAME="$PACKAGE_NAME.git"
            PACKAGE_SRC_FILEPATH="$NDKPKG_DOWNLOADS_DIR/$PACKAGE_SRC_FILENAME"

            if [ -z "$PACKAGE_VERSION" ] ; then
                PACKAGE_VERSION="$(format_unix_timestamp "$TIMESTAMP_UNIX" '+%Y.%m.%d')"
            fi
            ;;
        *)
            if [ -z "$PACKAGE_SRC_SHA" ] ; then
                abort 1 "src-sha mapping not found in $PACKAGE_FORMULA_FILEPATH"
            fi

            if [ -z "$PACKAGE_VERSION" ] ; then
                PACKAGE_VERSION="$(basename "$PACKAGE_SRC_URL" | tr '_@' - | sed -e 's|\.tar\.[glx]z$||' -e 's|\.tar\.bz2$||' -e 's|\.t[glx]z$||' -e 's|\.zip$||' -e 's|-stable||' -e 's|-source||' -e 's|[-.]src$||' -e 's|\.orig||' | awk -F- '{print $NF}')"
                case $PACKAGE_VERSION in
                    '') abort 1 "version mapping not found in $PACKAGE_FORMULA_FILEPATH" ;;
                    v*) PACKAGE_VERSION=$(printf '%s\n' "$PACKAGE_VERSION" | cut -c2-)
                esac
            fi

            PACKAGE_SRC_FILENAME="$PACKAGE_SRC_SHA$PACKAGE_SRC_FILETYPE"
            PACKAGE_SRC_FILEPATH="$NDKPKG_DOWNLOADS_DIR/$PACKAGE_SRC_FILENAME"
    esac

    #########################################################################################

    [ -n "$PACKAGE_FIX_URL" ] && {
        [ -z "$PACKAGE_FIX_SHA" ] && abort 1 "fix-sha mapping not found in $PACKAGE_FORMULA_FILEPATH"

        PACKAGE_FIX_FILETYPE="$(filetype_from_url "$PACKAGE_FIX_URL")"

        case $PACKAGE_FIX_FILETYPE in
            .diff)  PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch"            ;;
            .patch) PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch"            ;;
            .zip)   PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch unzip"      ;;
            .txz)   PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch gtar xz"    ;;
            .tgz)   PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch gtar gzip"  ;;
            .tlz)   PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch gtar lzip"  ;;
            .tbz2)  PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch gtar bzip2" ;;
        esac

        PACKAGE_FIX_FILENAME="$PACKAGE_FIX_SHA$PACKAGE_FIX_FILETYPE"
        PACKAGE_FIX_FILEPATH="$NDKPKG_DOWNLOADS_DIR/$PACKAGE_FIX_FILENAME"
    }

    #########################################################################################

    [ -n "$PACKAGE_RES_URL" ] && {
        [ -z "$PACKAGE_RES_SHA" ] && abort 1 "res-sha mapping not found in $PACKAGE_FORMULA_FILEPATH"

        PACKAGE_RES_FILETYPE="$(filetype_from_url "$PACKAGE_RES_URL")"

        case $PACKAGE_RES_FILETYPE in
            .diff)  PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch"            ;;
            .patch) PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch"            ;;
            .zip)   PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch unzip"      ;;
            .txz)   PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch gtar xz"    ;;
            .tgz)   PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch gtar gzip"  ;;
            .tlz)   PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch gtar lzip"  ;;
            .tbz2)  PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP patch gtar bzip2" ;;
        esac

        PACKAGE_RES_FILENAME="$PACKAGE_RES_SHA$PACKAGE_RES_FILETYPE"
        PACKAGE_RES_FILEPATH="$NDKPKG_DOWNLOADS_DIR/$PACKAGE_RES_FILENAME"
    }

    #########################################################################################

    [ -n "$PACKAGE_VERSION" ] && {
        PACKAGE_VERSION_MAJOR="$(printf '%s\n' "$PACKAGE_VERSION" | cut -d. -f1)"
        PACKAGE_VERSION_MINOR="$(printf '%s\n' "$PACKAGE_VERSION" | cut -d. -f2)"
        PACKAGE_VERSION_PATCH="$(printf '%s\n' "$PACKAGE_VERSION" | cut -d. -f3)"
        PACKAGE_VERSION_TWEAK="$(printf '%s\n' "$PACKAGE_VERSION" | cut -d. -f4)"
    }

    #########################################################################################

    for item in $PACKAGE_BUILD_SYSTEM
    do
        case $item in
            autogen)     PACKAGE_BUILD_SYSTEM_AUTOGENSH=yes ; PACKAGE_BUILD_SYSTEM_GMAKE=yes ;;
            autotools)   PACKAGE_BUILD_SYSTEM_AUTOTOOLS=yes ; PACKAGE_BUILD_SYSTEM_GMAKE=yes ;;
            configure)   PACKAGE_BUILD_SYSTEM_CONFIGURE=yes ; PACKAGE_BUILD_SYSTEM_GMAKE=yes ;;
            cmake-gmake) PACKAGE_BUILD_SYSTEM_CMAKE=yes     ; PACKAGE_BUILD_SYSTEM_GMAKE=yes ;;
            cmake-ninja) PACKAGE_BUILD_SYSTEM_CMAKE=yes     ; PACKAGE_BUILD_SYSTEM_NINJA=yes ;;
            cmake)       PACKAGE_BUILD_SYSTEM_CMAKE=yes     ; PACKAGE_BUILD_SYSTEM_NINJA=yes ;;
            xmake)       PACKAGE_BUILD_SYSTEM_XMAKE=yes     ;;
            meson)       PACKAGE_BUILD_SYSTEM_MESON=yes     ; PACKAGE_BUILD_SYSTEM_NINJA=yes ;;
            ninja)       PACKAGE_BUILD_SYSTEM_NINJA=yes     ;;
            gmake)       PACKAGE_BUILD_SYSTEM_GMAKE=yes     ;;
            rake)        PACKAGE_BUILD_SYSTEM_RAKE=yes      ;;
            cargo)       PACKAGE_BUILD_SYSTEM_CARGO=yes     ;;
            go)          PACKAGE_BUILD_SYSTEM_GO=yes        ;;
        esac
    done

    #########################################################################################

    for item in $PACKAGE_BUILD_SYSTEM
    do
        case $item in
            autogen)     PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP gmake gm4 perl autoconf automake" ;;
            autotools)   PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP gmake gm4 perl autoconf automake" ;;
            configure)   PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP gmake"        ;;
            cmake-gmake) PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP cmake gmake"  ;;
            cmake-ninja) PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP cmake ninja"  ;;
            cmake)       PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP cmake ninja"  ;;
            xmake)       PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP xmake"  ;;
            meson)       PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP ninja"  ;;
            ninja)       PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP ninja"  ;;
            gmake)       PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP gmake"  ;;
            rake)        PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP ruby"   ;;
            go)          PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP golang" ;;
        esac
    done

    #########################################################################################

    [ -z "$PACKAGE_DOBUILD_ACTIONS" ] && {
        case $PACKAGE_BUILD_SYSTEM in
            autogen)   PACKAGE_DOBUILD_ACTIONS='configure' ;;
            autotools) PACKAGE_DOBUILD_ACTIONS='configure' ;;
            configure) PACKAGE_DOBUILD_ACTIONS='configure' ;;
            cmake*)    PACKAGE_DOBUILD_ACTIONS='cmakew' ;;
            xmake)     PACKAGE_DOBUILD_ACTIONS='xmakew' ;;
            meson)     PACKAGE_DOBUILD_ACTIONS='mesonw' ;;
            ninja)     PACKAGE_DOBUILD_ACTIONS='ninjaw clean && ninjaw && ninjaw install' ;;
            gmake)     PACKAGE_DOBUILD_ACTIONS='gmakew clean && gmakew && gmakew install' ;;
            cargo)     PACKAGE_DOBUILD_ACTIONS='cargow install' ;;
            go)        PACKAGE_DOBUILD_ACTIONS='gow' ;;
            *)         abort 1 "install mapping not found in $PACKAGE_FORMULA_FILEPATH"
        esac
    }

    #########################################################################################


    [ "$PACKAGE_BUILD_SYSTEM_MESON" = yes ] && {
        PACKAGE_DEP_PYM="$PACKAGE_DEP_PYM meson"
    }

    [ -n "$PACKAGE_DEP_PYM" ] && {
        PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP python3"
    }

    [ -n "$PACKAGE_DEP_PLM" ] && {
        PACKAGE_DEP_UPP="$PACKAGE_DEP_UPP perl gmake"
    }

    [ "$PACKAGE_BUILD_IN_PARALLEL" = no ] && {
        BUILD_NJOBS=1
    }

    [ "$PACKAGE_BUILD_SYSTEM_GO" = yes ] && {
        PACKAGE_BINBSTD=yes
        PACKAGE_BUILD_IN_BSCRIPT_DIR=yes
    }

    [ "$PACKAGE_BUILD_SYSTEM_CARGO" = yes ] && {
        PACKAGE_BINBSTD=yes
        PACKAGE_BUILD_IN_BSCRIPT_DIR=yes
    }

    [ "$PACKAGE_BUILD_SYSTEM_XMAKE" = yes ] && {
        PACKAGE_BINBSTD=yes
        PACKAGE_BUILD_IN_BSCRIPT_DIR=yes
    }

    #########################################################################################

    PACKAGE_DEP_UPP="${PACKAGE_DEP_UPP#' '}"

    PACKAGE_FORMULA_LOADED=yes
}

# }}}
##############################################################################
# {{{ ndk-pkg formula

# __show_formula_of_the_given_package <PACKAGE-NAME> [--json] [--yaml] [--path] [<KEY>]
  __show_formula_of_the_given_package() {
    [ -z "$1" ] && abort 1 "__show_formula_of_the_given_package <PACKAGE-NAME> [--json] [--yaml] [--path] [<KEY>], <PACKAGE-NAME> is unspecified."

    PACKAGE_FORMULA_FILEPATH=
    PACKAGE_FORMULA_FILEPATH="$(__path_of_formula_of_the_given_package "$1")"

    [ -z "$PACKAGE_FORMULA_FILEPATH" ] && abort 1 "package '$1' is not available."

    case $2 in
        --yaml|'')
            if [ -t 1 ] ; then
                yq  "$PACKAGE_FORMULA_FILEPATH"
            else
                cat "$PACKAGE_FORMULA_FILEPATH"
            fi
            ;;
        --json)
            yq -o=json "$PACKAGE_FORMULA_FILEPATH"
            ;;
        --path)
            printf '%s\n' "$PACKAGE_FORMULA_FILEPATH"
            ;;
        *)  yq ".$2 | select(. != null)" "$PACKAGE_FORMULA_FILEPATH"
    esac
}

# }}}
##############################################################################
# {{{ ndk-pkg formula-edit

# __edit_formula_of_the_given_package <PACKAGE-NAME> [--editor=<EDITOR>]
  __edit_formula_of_the_given_package() {
    [ -z "$1" ] && abort 1 "__edit_formula_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is unspecified."

    unset  PACKAGE_FORMULA_FILEPATH; PACKAGE_FORMULA_FILEPATH="$(__path_of_formula_of_the_given_package "$1")"

    [ -z "$PACKAGE_FORMULA_FILEPATH" ] && abort 1 "package '$1' is not available."

    shift

    EDITOR=

    while [ -n "$1" ]
    do
        case $1 in
            --editor=*)
                EDITOR="${1#*=}"
                ;;
            *)  abort 1 "unrecognized option: $1"
        esac
        shift
    done

    [ -z "$EDITOR" ] && {
        EDITOR=$(command -v nvim || command -v vim || command -v vi || command -v open) || abort 1 "please sepecify editor via [--editor=<EDITOR> option."
    }

    "$EDITOR" "$PACKAGE_FORMULA_FILEPATH"
}

# }}}
##############################################################################
# {{{ operations of receipt

# __generate_receipt_of_the_given_package <PACKAGE-NAME>
  __generate_receipt_of_the_given_package() {
    [ -z "$1" ] && {
        error "__generate_receipt_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is unspecified."
        return 1
    }

    run cp "$PACKAGE_FORMULA_FILEPATH" "$PACKAGE_RECEIPT_FILEPATH"

    sed_in_place '/^#src-url: dir:/d' "$PACKAGE_RECEIPT_FILEPATH"

    sed_in_place "1i pkgname: $PACKAGE_NAME" "$PACKAGE_RECEIPT_FILEPATH"

    grep -q '^version: ' "$PACKAGE_RECEIPT_FILEPATH" || {
        sed_in_place "2i version: $PACKAGE_VERSION" "$PACKAGE_RECEIPT_FILEPATH"
    }

    grep -q '^web-url: ' "$PACKAGE_RECEIPT_FILEPATH" || {
        sed_in_place "/^git-url:/i web-url: $PACKAGE_GIT_URL" "$PACKAGE_RECEIPT_FILEPATH"
    }

    grep -q '^bsystem: ' "$PACKAGE_RECEIPT_FILEPATH" || {
        sed_in_place "/^install:/i bsystem: $PACKAGE_BSYSTEM" "$PACKAGE_RECEIPT_FILEPATH"
    }

    grep -q '^binbstd: ' "$PACKAGE_RECEIPT_FILEPATH" || {
        sed_in_place "/^bsystem:/a binbstd: $PACKAGE_BINBSTD" "$PACKAGE_RECEIPT_FILEPATH"
    }

    grep -q '^parallel: ' "$PACKAGE_RECEIPT_FILEPATH" || {
        sed_in_place "\$a parallel: $PACKAGE_PARALLEL" "$PACKAGE_RECEIPT_FILEPATH"
    }

    [ -n "$PACKAGE_GIT_SHA" ] && {
        grep -q '^git-sha: ' "$PACKAGE_RECEIPT_FILEPATH" || {
            sed_in_place "/^git-url:/a git-sha: $PACKAGE_GIT_SHA" "$PACKAGE_RECEIPT_FILEPATH"
        }

        grep -q '^git-sha: ' "$PACKAGE_RECEIPT_FILEPATH" || {
            sed_in_place "3i git-sha: $PACKAGE_GIT_SHA" "$PACKAGE_RECEIPT_FILEPATH"
        }
    }

    [ -n "$PACKAGE_DEP_UPP" ] && {
        if grep -q '^dep-upp: ' "$PACKAGE_RECEIPT_FILEPATH" ; then
            sed_in_place "/^dep-upp: /c dep-upp: $PACKAGE_DEP_UPP" "$PACKAGE_RECEIPT_FILEPATH"
        else
            sed_in_place "/^bsystem: /i dep-upp: $PACKAGE_DEP_UPP" "$PACKAGE_RECEIPT_FILEPATH"
        fi
    }

    cat >> "$PACKAGE_RECEIPT_FILEPATH" <<EOF
ndkvers: $ANDROID_NDK_VERSION
build-on:
    os-arch: $NATIVE_OS_ARCH
    os-kind: $NATIVE_OS_KIND
    os-type: $NATIVE_OS_TYPE
    os-code: $NATIVE_OS_CODE
    os-name: $NATIVE_OS_NAME
    os-vers: $NATIVE_OS_VERS
    os-ncpu: $NATIVE_OS_NCPU
    os-euid: $NATIVE_OS_EUID
    os-egid: $NATIVE_OS_EGID
built-for: $TARGET_ANDROID_SPEC
signature: ndk-pkg-$NDKPKG_VERSION
timestamp: $TIMESTAMP_UNIX
EOF
}

# __load_receipt_of_the_given_package <PACKAGE-NAME|PACKAGE-SPEC>
  __load_receipt_of_the_given_package() {
    PACKAGE_SPEC=
    PACKAGE_SPEC="$(inspect_package_spec "$1")"

    is_package_installed "$PACKAGE_SPEC"

    [ $? -eq 0 ] || return $?

    PACKAGE_INSTALLED_DIR="$(readlink -f "$NDKPKG_PACKAGE_INSTALLED_ROOT/$PACKAGE_SPEC")"

    PACKAGE_RECEIPT_FILEPATH="$PACKAGE_INSTALLED_DIR/.ndk-pkg/RECEIPT.yml"

    unset PACKAGE_RECEIPT_PKGNAME
    unset PACKAGE_RECEIPT_SUMMARY
    unset PACKAGE_RECEIPT_VERSION
    unset PACKAGE_RECEIPT_LICENSE

    unset PACKAGE_RECEIPT_WEB_URL

    unset PACKAGE_RECEIPT_GIT_URL
    unset PACKAGE_RECEIPT_GIT_SHA
    unset PACKAGE_RECEIPT_GIT_REF

    unset PACKAGE_RECEIPT_SVN_URL

    unset PACKAGE_RECEIPT_SRC_URL
    unset PACKAGE_RECEIPT_SRC_URI
    unset PACKAGE_RECEIPT_SRC_SHA

    unset PACKAGE_RECEIPT_FIX_URL
    unset PACKAGE_RECEIPT_FIX_SHA

    unset PACKAGE_RECEIPT_RES_URL
    unset PACKAGE_RECEIPT_RES_SHA

    unset PACKAGE_RECEIPT_DEP_PKG
    unset PACKAGE_RECEIPT_DEP_UPP
    unset PACKAGE_RECEIPT_DEP_PYM
    unset PACKAGE_RECEIPT_DEP_PLM

    unset PACKAGE_RECEIPT_API_MIN

    unset PACKAGE_RECEIPT_BSYSTEM
    unset PACKAGE_RECEIPT_BSCRIPT
    unset PACKAGE_RECEIPT_DOPATCH
    unset PACKAGE_RECEIPT_INSTALL
    unset PACKAGE_RECEIPT_SYMLINK

    unset PACKAGE_RECEIPT_NDKVERS

    unset PACKAGE_RECEIPT_PARALLEL

    unset PACKAGE_RECEIPT_DEVELOPER

    unset PACKAGE_RECEIPT_SIGNATURE
    unset PACKAGE_RECEIPT_TIMESTAMP

    unset PACKAGE_RECEIPT_BUILT_FOR
    unset PACKAGE_RECEIPT_BUILT_FOR_ANDROID
    unset PACKAGE_RECEIPT_BUILT_FOR_ANDROID_API
    unset PACKAGE_RECEIPT_BUILT_FOR_ANDROID_ABI

    for key in pkgname summary web-url git-url git-sha git-ref shallow src-url src-uri src-sha fix-url fix-sha res-url res-sha dep-pkg dep-upp dep-pym dep-plm api-min license version bsystem bscript binbstd ccflags xxflags ppflags ldflags parallel developer signature timestamp built-for ndkvers
    do
        unset __KEY_UPPERCASE_UNDERSCORE__
        unset __VALUE__

        __KEY_UPPERCASE_UNDERSCORE__="$(printf '%s\n' "$key" | tr '-' '_' | tr a-z A-Z)"
        __VALUE__="$(yq ".$key" "$PACKAGE_RECEIPT_FILEPATH")"

        if [ "$__VALUE__" = null ] ; then
               __VALUE__=
        fi

        eval "PACKAGE_RECEIPT_$__KEY_UPPERCASE_UNDERSCORE__='$__VALUE__'"
    done

    if [ "${PACKAGE_SPEC%%:*}" != "$PACKAGE_RECEIPT_PKGNAME" ] ; then
        error "$PACKAGE_RECEIPT_FILEPATH is broken. value of PACKAGE_RECEIPT_PKGNAME does not identical with your request: ${PACKAGE_SPEC%%:*}"
        return 1
    fi

    if [ "${PACKAGE_SPEC#*:}" != "$PACKAGE_RECEIPT_BUILT_FOR" ] ; then
        error "$PACKAGE_RECEIPT_FILEPATH is broken. value of PACKAGE_RECEIPT_BUILT_FOR does not identical with your request: ${PACKAGE_SPEC#*:}"
        return 1
    fi

    PACKAGE_RECEIPT_BUILT_FOR_ANDROID_ABI="${PACKAGE_RECEIPT_BUILT_FOR#*:}"
    PACKAGE_RECEIPT_BUILT_FOR_ANDROID_API="${PACKAGE_RECEIPT_BUILT_FOR%:*}"
    PACKAGE_RECEIPT_BUILT_FOR_ANDROID_API="${PACKAGE_RECEIPT_BUILT_FOR_ANDROID_API#android-}"

    case $PACKAGE_RECEIPT_BUILT_FOR_ANDROID_API in
        [1-9][0-9])
            ;;
        *)  abort 1 "$PACKAGE_RECEIPT_FILEPATH is broken. value of PACKAGE_RECEIPT_BUILT_FOR_ANDROID_API must be an integer."
    esac

    case $PACKAGE_RECEIPT_BUILT_FOR_ANDROID_ABI in
        arm64-v8a|armeabi-v7a|x86_64|x86)
            ;;
        *)  abort 1 "$PACKAGE_RECEIPT_FILEPATH is broken. value of PACKAGE_RECEIPT_BUILT_FOR_ANDROID_ABI must be any one of arm64-v8a|armeabi-v7a|x86_64|x86"
    esac

    if [ -z "$PACKAGE_RECEIPT_VERSION" ] ; then
        error "$PACKAGE_RECEIPT_FILEPATH is broken. value of PACKAGE_RECEIPT_VERSION must be non-empty."
        return 1
    fi

    if [ -z "$PACKAGE_RECEIPT_SUMMARY" ] ; then
        error "$PACKAGE_RECEIPT_FILEPATH is broken. value of PACKAGE_RECEIPT_SUMMARY must be non-empty."
        return 1
    fi

    if [ -z "$PACKAGE_RECEIPT_WEB_URL" ] ; then
        error "$PACKAGE_RECEIPT_FILEPATH is broken. value of PACKAGE_RECEIPT_WEB_URL must be non-empty."
        return 1
    fi

    if [ -z "$PACKAGE_RECEIPT_SIGNATURE" ] ; then
        error "$PACKAGE_RECEIPT_FILEPATH is broken. value of PACKAGE_RECEIPT_SIGNATURE must be non-empty."
        return 1
    fi

    if [ -z "$PACKAGE_RECEIPT_TIMESTAMP" ] ; then
        error "$PACKAGE_RECEIPT_FILEPATH is broken. value of PACKAGE_RECEIPT_TIMESTAMP must be non-empty."
        return 1
    fi

    if [ "${#PACKAGE_RECEIPT_TIMESTAMP}" -ne 10 ] ; then
        error "$PACKAGE_RECEIPT_FILEPATH is broken. length of \$PACKAGE_RECEIPT_TIMESTAMP must be 10."
        return 1
    fi
}

# }}}
##############################################################################
# {{{ ndk-pkg receipt

# __show_receipt_of_the_given_package <PACKAGE-SPEC> [--json] [--yaml] [--path] [<KEY>]
  __show_receipt_of_the_given_package() {
    __load_receipt_of_the_given_package "$1"

    case $2 in
        --yaml|'')
            if [ -t 1 ] ; then
                yq  "$PACKAGE_RECEIPT_FILEPATH"
            else
                cat "$PACKAGE_RECEIPT_FILEPATH"
            fi
            ;;
        --json)
            yq -o=json "$PACKAGE_RECEIPT_FILEPATH"
            ;;
        --path)
            printf '%s\n' "$PACKAGE_RECEIPT_FILEPATH"
            ;;
        *)  yq ".$2 | select(. != null)" "$PACKAGE_RECEIPT_FILEPATH"
    esac
}

# }}}
##############################################################################
# {{{ operations of manifest

# __generate_manifest_of_the_given_package <PACKAGE-NAME>
  __generate_manifest_of_the_given_package() {
    # fuck, some package's filename has space
    export IFS='
'

    exec 7> "$PACKAGE_MANIFEST_FILEPATH"

    for dirname in $(find -mindepth 1 -maxdepth 1 -type d -not -name .ndk-pkg -printf '%P\n')
    do
        for item in $(find "$dirname" -printf '%y:%p\n')
        do
            X=$(printf '%s\n' "$item" | cut -c1)
            Y=${item#$X:}

            case $X in
                l)  if [ -d "$Y" ] ; then
                        printf 'D|0000000000000000000000000000000000000000000000000000000000000000|%s/\n' "$Y" >&7
                    else
                        printf 'l|%s|%s\n' "$(sha256sum "$Y" | cut -d ' ' -f1)"                           "$Y" >&7
                    fi
                    ;;
                d)  printf 'd|0000000000000000000000000000000000000000000000000000000000000000|%s/\n' "$Y" >&7 ;;
                *)  printf '%s|%s|%s\n' "$X" "$(sha256sum "$Y" | cut -d ' ' -f1)"                     "$Y" >&7 ;;
            esac
        done
    done

    exec 7>&-

    unset IFS
}

# }}}
##############################################################################
# {{{ ndk-pkg is-available

# check if the given package is available
# if the version condition is given, check if the condition is matched
#
# condition operator:
# eq  equal
# ne  not equal
# gt  greater than
# lt  less than
# ge  greater than or equal
# le  less than or equal
#
# examples:
# is_package_available automake eq 1.16.0
# is_package_available automake lt 1.16.0
# is_package_available automake gt 1.16.0
# is_package_available automake le 1.16.0
# is_package_available automake ge 1.16.0
# is_package_available automake
is_package_available() {
    case $# in
        0)  abort 1 "package name is unspecified." ;;
        1)  [ -n "$(__path_of_formula_of_the_given_package "$1")" ] ;;
        3)  __load_formula_of_the_given_package "$1"
            shift
            version_match "$PACKAGE_VERSION" "$@"
            ;;
        *)  abort 1 "is available command only accept 1 or 3 argument."
    esac
}

# }}}
##############################################################################
# {{{ ndk-pkg is-installed

# is_package_installed <PACKAGE-SPEC>
  is_package_installed() {
    (
        PACKAGE_INSTALL_DIR="$NDKPKG_PACKAGE_INSTALLED_ROOT/$1"

        [ -L "$PACKAGE_INSTALL_DIR" ] || exit 11
        [ -d "$PACKAGE_INSTALL_DIR" ] || exit 12
        [ -f "$PACKAGE_INSTALL_DIR/.ndk-pkg/MANIFEST.txt" ] || exit 14
        [ -f "$PACKAGE_INSTALL_DIR/.ndk-pkg/RECEIPT.yml" ] || exit 15
    )
}

# }}}
##############################################################################
# {{{ ndk-pkg is-outdated

# is_package__outdated <PACKAGE-SPEC>
  is_package__outdated() {
    __load_receipt_of_the_given_package "$1"
    __load_formula_of_the_given_package "${1%%:*}"
    version_match "$PACKAGE_VERSION" gt "$PACKAGE_RECEIPT_VERSION"
}

# }}}
##############################################################################
# {{{ ndk-pkg ls-available

__list_available_packages() {
    [ -d "$NDKPKG_FORMULA_REPO_ROOT" ] || return 0

    {
        AVAILABLE_FORMULA_REPOSITORY_NAMES=

        for item in $(cd "$NDKPKG_FORMULA_REPO_ROOT" && ls)
        do
            if [ -f "$NDKPKG_FORMULA_REPO_ROOT/$item/.ndk-pkg-formula-repo.yml" ] ; then
                AVAILABLE_FORMULA_REPOSITORY_NAMES="$AVAILABLE_FORMULA_REPOSITORY_NAMES $item"
            fi
        done

        for FORMULA_REPOSITORY_NAME in $AVAILABLE_FORMULA_REPOSITORY_NAMES
        do
            FORMULA_SEARCH_DIR="$NDKPKG_FORMULA_REPO_ROOT/$FORMULA_REPOSITORY_NAME/formula/$NATIVE_OS_TYPE"

            if [ -d  "$FORMULA_SEARCH_DIR" ] ; then
                find "$FORMULA_SEARCH_DIR" -maxdepth 1 -type f -name '*.yml' -exec basename {} .yml \; || return 1
            fi

            FORMULA_SEARCH_DIR="$NDKPKG_FORMULA_REPO_ROOT/$FORMULA_REPOSITORY_NAME/formula"

            if [ -d  "$FORMULA_SEARCH_DIR" ] ; then
                find "$FORMULA_SEARCH_DIR" -maxdepth 1 -type f -name '*.yml' -exec basename {} .yml \; || return 1
            fi
        done
    } | sort | uniq
}

# }}}
##############################################################################
# {{{ ndk-pkg ls-installed

__list_installed_packages() {
    if [ -d "$NDKPKG_PACKAGE_INSTALLED_ROOT" ] ; then
         cd "$NDKPKG_PACKAGE_INSTALLED_ROOT" || return 1
        find . -maxdepth 1 -mindepth 1 -type l -regex '\./[^:]*:android-[1-9][0-9]:\(armeabi-v7a\|arm64-v8a\|x86\|x86_64\)' -printf '%P\n'
    else
        return 0
    fi
}

# }}}
##############################################################################
# {{{ ndk-pkg ls-outdated

__list__outdated_packages() {
    for PACKAGE_SPEC in $(__list_installed_packages)
    do
        if is_package__outdated "$PACKAGE_SPEC" ; then
            printf '%s\n' "$PACKAGE_SPEC"
        fi
    done
}

# }}}
##############################################################################
# {{{ ndk-pkg search

__search_packages() {
    [ -z "$1" ] && abort 1 "please specify a regular express partten."

    __list_available_packages | grep "$1"
}

# }}}
##############################################################################
# {{{ ndk-pkg info

# __show_information_of_all_available_packages [--json] [--yaml] [--shell]
  __show_information_of_all_available_packages() {
    case $1 in
        '')     __show_information_as_yaml__of_all_available_packages ;;
        --yaml) __show_information_as_yaml__of_all_available_packages ;;
        --json) __show_information_as_json__of_all_available_packages ;;
        --shell)__show_information_as_shell_of_all_available_packages ;;
        *)    abort 1 "__show_information_of_all_available_packages [--json] [--yaml] [--shell], unrecognized option: $1"
    esac
}

__show_information_as_json__of_all_available_packages() {
    printf '%s\n' '['

    FIRST=yes

    for PACKAGE in $(__list_available_packages)
    do
        if [ "$FIRST" = yes ] ; then
            FIRST=no
        else
            printf '%s\n' ','
        fi
        __show_information_as_json__of_the_given_package "$PACKAGE"
    done

    printf '%s\n' ']'
}

__show_information_as_yaml__of_all_available_packages() {
    FIRST=yes

    for PACKAGE in $(__list_available_packages)
    do
        if [ "$FIRST" = yes ] ; then
            FIRST=no
        else
            printf '%s\n' '---'
        fi
        __show_information_as_yaml__of_the_given_package "$PACKAGE"
    done
}

__show_information_as_shell_of_all_available_packages() {
    FIRST=yes

    for PACKAGE in $(__list_available_packages)
    do
        if [ "$FIRST" = yes ] ; then
            FIRST=no
        else
            printf '%s\n' '#---'
        fi
        __show_information_as_shell_of_the_given_package "$PACKAGE"
    done
}

# __show_information_as_json__of_the_given_package <PACKAGE-NAME>
  __show_information_as_json__of_the_given_package() {
    __load_formula_of_the_given_package "$1"

    if [ -z "$PACKAGE_WEB_URL" ] ; then
        PACKAGE_WEB_URL="$PACKAGE_GIT_URL"
    fi

    jq  --null-input \
        --arg pkgname "$PACKAGE_NAME" \
        --arg version "$PACKAGE_VERSION" \
        --arg summary "$PACKAGE_SUMMARY" \
        --arg license "$PACKAGE_LICENSE" \
        --arg web_url "$PACKAGE_WEB_URL" \
        --arg git_url "$PACKAGE_GIT_URL" \
        --arg git_sha "$PACKAGE_GIT_SHA" \
        --arg git_ref "$PACKAGE_GIT_REF" \
        --arg src_url "$PACKAGE_SRC_URL" \
        --arg src_uri "$PACKAGE_SRC_URI" \
        --arg src_sha "$PACKAGE_SRC_SHA" \
        --arg fix_url "$PACKAGE_FIX_URL" \
        --arg fix_uri "$PACKAGE_FIX_URI" \
        --arg fix_sha "$PACKAGE_FIX_SHA" \
        --arg res_url "$PACKAGE_RES_URL" \
        --arg res_uri "$PACKAGE_RES_URI" \
        --arg res_sha "$PACKAGE_RES_SHA" \
        --arg dep_pkg "$PACKAGE_DEP_PKG" \
        --arg dep_upp "$PACKAGE_DEP_UPP" \
        --arg dep_pym "$PACKAGE_DEP_PYM" \
        --arg dep_plm "$PACKAGE_DEP_PLM" \
        --arg dopatch "$PACKAGE_DOPATCH_ACTIONS" \
        --arg install "$PACKAGE_DOBUILD_ACTIONS" \
        --arg bsystem "$PACKAGE_BSYSTEM" \
        --arg binbstd "$PACKAGE_BINBSTD" \
        --arg ccflags "$PACKAGE_CCFLAGS" \
        --arg xxflags "$PACKAGE_XXFLAGS" \
        --arg ppflags "$PACKAGE_PPFLAGS" \
        --arg ldflags "$PACKAGE_LDFLAGS" \
        --arg api_min "$PACKAGE_API_MIN" \
        --arg parallel $PACKAGE_BUILD_IN_PARALLEL \
'{
    "pkgname":$pkgname,
    "version":$version,
    "license":$license,
    "summary":$summary,
    "web-url":$web_url,
    "git-url":$git_url,
    "git-sha":$git_sha,
    "git-ref":$git_ref,
    "src-url":$src_url,
    "src-uri":$src_uri,
    "src-sha":$src_sha,
    "fix-url":$fix_url,
    "fix-uri":$fix_uri,
    "fix-sha":$fix_sha,
    "res-url":$res_url,
    "res-uri":$res_uri,
    "res-sha":$res_sha,
    "dep-pkg":$dep_pkg,
    "dep-upp":$dep_upp,
    "dep-pym":$dep_pym,
    "dep-plm":$dep_plm,
    "api-min":$api_min,
    "bsystem":$bsystem,
    "binbstd":$binbstd,
    "ccflags":$ccflags,
    "xxflags":$xxflags,
    "ppflags":$ppflags,
    "ldflags":$ldflags,
    "parallel":$parallel,
    "dopatch":$dopatch,
    "install":$install
}' | jq 'with_entries(select(.value != ""))'
}

# __show_information_as_yaml__of_the_given_package <PACKAGE-NAME>
  __show_information_as_yaml__of_the_given_package() {
    __load_formula_of_the_given_package "$1"

    if [ -z "$PACKAGE_WEB_URL" ] ; then
        PACKAGE_WEB_URL="$PACKAGE_GIT_URL"
    fi

    {
    cat <<EOF
pkgname: $PACKAGE_NAME
version: $PACKAGE_VERSION
license: $PACKAGE_LICENSE
summary: $PACKAGE_SUMMARY
web-url: $PACKAGE_WEB_URL
git-url: $PACKAGE_GIT_URL
git-sha: $PACKAGE_GIT_SHA
git-ref: $PACKAGE_GIT_REF
src-url: $PACKAGE_SRC_URL
src-uri: $PACKAGE_SRC_URI
src-sha: $PACKAGE_SRC_SHA
fix-url: $PACKAGE_FIX_URL
fix-uri: $PACKAGE_FIX_URI
fix-sha: $PACKAGE_FIX_SHA
res-url: $PACKAGE_RES_URL
res-uri: $PACKAGE_RES_URI
res-sha: $PACKAGE_RES_SHA
dep-pkg: $PACKAGE_DEP_PKG
dep-upp: $PACKAGE_DEP_UPP
dep-pym: $PACKAGE_DEP_PYM
dep-plm: $PACKAGE_DEP_PLM
api-min: $PACKAGE_API_MIN
bsystem: $PACKAGE_BSYSTEM
binbstd: $PACKAGE_BINBSTD
ppflags: $PACKAGE_PPFLAGS
ccflags: $PACKAGE_CCFLAGS
xxflags: $PACKAGE_XXFLAGS
ldflags: $PACKAGE_LDFLAGS
parallel: $PACKAGE_BUILD_IN_PARALLEL
EOF
    } | yq eval '. | with_entries(select(.value != null))'

    if is_package_installed "$1" ; then
        yq eval --null-input '.installed = "yes"'
    else
        yq eval --null-input '.installed = "no"'
    fi
}

# __show_information_as_shell_of_the_given_package <PACKAGE-NAME>
  __show_information_as_shell_of_the_given_package() {
    __load_formula_of_the_given_package "$1"

    while read KEY
    do
        printf "%s='%s'\n" "${PACKAGE_NAME_UPPERCASE_UNDERSCORE}_${KEY}" "$(eval echo \$$KEY)"
    done <<EOF
PACKAGE_NAME
PACKAGE_SUMMARY
PACKAGE_WEB_URL
PACKAGE_GIT_URL
PACKAGE_GIT_SHA
PACKAGE_GIT_REF
PACKAGE_SVN_URL
PACKAGE_SRC_URL
PACKAGE_SRC_URI
PACKAGE_SRC_SHA
PACKAGE_SRC_FILETYPE
PACKAGE_SRC_FILENAME
PACKAGE_SRC_FILEPATH
PACKAGE_FIX_URL
PACKAGE_FIX_URI
PACKAGE_FIX_SHA
PACKAGE_FIX_FILETYPE
PACKAGE_FIX_FILENAME
PACKAGE_FIX_FILEPATH
PACKAGE_RES_URL
PACKAGE_RES_URI
PACKAGE_RES_SHA
PACKAGE_RES_FILETYPE
PACKAGE_RES_FILENAME
PACKAGE_RES_FILEPATH
PACKAGE_VERSION
PACKAGE_VERSION_MAJOR
PACKAGE_VERSION_MINOR
PACKAGE_VERSION_PATCH
PACKAGE_VERSION_TWEAK
PACKAGE_DEVELOPER
PACKAGE_LICENSE
PACKAGE_BSCRIPT
PACKAGE_BSYSTEM
PACKAGE_BINBSTD
PACKAGE_BUILD_SYSTEM
PACKAGE_BUILD_SYSTEM_GO
PACKAGE_BUILD_SYSTEM_RAKE
PACKAGE_BUILD_SYSTEM_NINJA
PACKAGE_BUILD_SYSTEM_GMAKE
PACKAGE_BUILD_SYSTEM_CMAKE
PACKAGE_BUILD_SYSTEM_XMAKE
PACKAGE_BUILD_SYSTEM_MESON
PACKAGE_BUILD_SYSTEM_CARGO
PACKAGE_BUILD_SYSTEM_AUTOGENSH
PACKAGE_BUILD_SYSTEM_AUTOTOOLS
PACKAGE_BUILD_SYSTEM_CONFIGURE
PACKAGE_BUILD_IN_BSCRIPT_DIR
PACKAGE_BUILD_IN_PARALLEL
PACKAGE_DEP_PKG
PACKAGE_DEP_UPP
PACKAGE_DEP_PYM
PACKAGE_DEP_PLM
PACKAGE_API_MIN
PACKAGE_CCFLAGS
PACKAGE_XXFLAGS
PACKAGE_PPFLAGS
PACKAGE_LDFLAGS
PACKAGE_FORMULA_FILEPATH
EOF
}

# __show_information_of_the_given_package <PACKAGE-NAME> [--yaml] [--json] [<KEY>]
#
# __show_information_of_the_given_package curl
#
# __show_information_of_the_given_package curl version
# __show_information_of_the_given_package curl web-url
  __show_information_of_the_given_package() {
    [ -z "$1" ] && abort 1 "__show_information_of_the_given_package <PACKAGE-NAME> [--yaml] [--json] [<KEY>], <PACKAGE-NAME> is unspecified."

    case $1 in
        @all) shift ; __show_information_of_all_available_packages "$@" ; return 0
    esac

    case $2 in
        --yaml|'')
            __show_information_as_yaml__of_the_given_package "$1"
            ;;
        --json)
            __show_information_as_json__of_the_given_package "$1"
            ;;
        installed-dir)
            peel_installed_root_dir_for_the_given_package "$1"
            ;;
        installed-files)
            PACKAGE_INSTALL_DIR="$(peel_installed_root_dir_for_the_given_package "$1")"
            cut -d '|' -f3 "$PACKAGE_INSTALL_DIR/.ndk-pkg/MANIFEST.txt"
            ;;
        installed-timestamp-unix)
            __load_receipt_of_the_given_package "$1"
            printf '%s\n' "$PACKAGE_RECEIPT_TIMESTAMP"
            ;;
        installed-timestamp-rfc-3339)
            __load_receipt_of_the_given_package "$1"
            format_unix_timestamp "$PACKAGE_RECEIPT_TIMESTAMP" '+%Y-%m-%d %H:%M:%S%:z'
            ;;
        installed-timestamp-iso-8601)
            __load_receipt_of_the_given_package "$1"
            format_unix_timestamp "$PACKAGE_RECEIPT_TIMESTAMP" '+%Y-%m-%dT%H:%M:%S%:z'
            ;;
        installed-timestamp-rfc-3339-utc)
            __load_receipt_of_the_given_package "$1"
            format_unix_timestamp "$PACKAGE_RECEIPT_TIMESTAMP" '+%Y-%m-%d %H:%M:%S%:z' -u
            ;;
        installed-timestamp-iso-8601-utc)
            __load_receipt_of_the_given_package "$1"
            format_unix_timestamp "$PACKAGE_RECEIPT_TIMESTAMP" '+%Y-%m-%dT%H:%M:%SZ' -u
            ;;
        installed-version)
            __load_receipt_of_the_given_package "$1"
            printf '%s\n' "$PACKAGE_RECEIPT_VERSION"
            ;;
        dopatch)
            __load_formula_of_the_given_package "$1"
            printf '%s\n' "$PACKAGE_DOPATCH_ACTIONS"
            ;;
        install)
            __load_formula_of_the_given_package "$1"
            printf '%s\n' "$PACKAGE_DOBUILD_ACTIONS"
            ;;
        developer)
            __load_formula_of_the_given_package "$1"
            printf '%s\n' "$PACKAGE_DEVELOPER"
            ;;
        *)  __load_formula_of_the_given_package "$1"
            __PACKAGE_GET__KEY__="$(printf '%s\n' "$2" | tr '+-.' '_' | tr a-z A-Z)"
            eval echo \$PACKAGE_$__PACKAGE_GET__KEY__
    esac
}

# }}}
##############################################################################
# {{{ ndk-pkg fetch

# fetch source code if needed
__fetch_sources_of_the_given_package() {
    case $PACKAGE_SRC_FILETYPE in
        .dir) note "$PACKAGE_SRC_URL is local path, no need to fetch." ;;
        .git)
            unset GIT_FETCH_URL

            if [ -z "$NDKPKG_URL_TRANSFORM" ] ; then
                GIT_FETCH_URL="$PACKAGE_GIT_URL"
            else
                GIT_FETCH_URL="$("$NDKPKG_URL_TRANSFORM" "$PACKAGE_GIT_URL")" || return 1
            fi

            if [ -z "$PACKAGE_GIT_SHA" ] ; then
                if [ -z "$PACKAGE_GIT_REF" ] ; then
                    GIT_BRANCH_NAME=master
                    GIT_REF_SPEC="+HEAD:refs/remotes/origin/master"
                else
                    GIT_BRANCH_NAME="$(basename "$PACKAGE_GIT_REF")"
                    GIT_REF_SPEC="+$PACKAGE_GIT_REF:refs/remotes/origin/$GIT_BRANCH_NAME"
                fi
            else
                GIT_BRANCH_NAME=master
                GIT_REF_SPEC="+$PACKAGE_GIT_SHA:refs/remotes/origin/master"
            fi

            if [ "$PACKAGE_SHALLOW" = yes ] ; then
                GIT_FETCH_EXTRA_OPTIONS='--depth=1'
            else
                if [ -f "$PACKAGE_SRC_FILEPATH/.git/shallow" ] ; then
                    GIT_FETCH_EXTRA_OPTIONS='--unshallow'
                else
                    GIT_FETCH_EXTRA_OPTIONS=
                fi
            fi

            if [ -d "$PACKAGE_SRC_FILEPATH" ] ; then
                if git -C "$PACKAGE_SRC_FILEPATH" rev-parse HEAD > /dev/null 2>&1 ; then
                    if [ -n "$PACKAGE_GIT_SHA" ] && [ "$PACKAGE_GIT_SHA" = "$(git -C "$PACKAGE_SRC_FILEPATH" rev-parse HEAD)" ] ; then
                        success "$PACKAGE_SRC_FILEPATH already have been fetched."
                        return 0
                    fi
                else
                    run rm -rf     "$PACKAGE_SRC_FILEPATH" || return 1
                    run install -d "$PACKAGE_SRC_FILEPATH" || return 1
                    run git -C     "$PACKAGE_SRC_FILEPATH" -c init.defaultBranch=master init || return 1
                    run git -C     "$PACKAGE_SRC_FILEPATH" remote add origin "$GIT_FETCH_URL" || return 1
                fi
            else
                run install -d "$PACKAGE_SRC_FILEPATH" || return 1
                run git -C     "$PACKAGE_SRC_FILEPATH" -c init.defaultBranch=master init || return 1
                run git -C     "$PACKAGE_SRC_FILEPATH" remote add origin "$GIT_FETCH_URL" || return 1
            fi

            run git -C "$PACKAGE_SRC_FILEPATH" -c protocol.version=2 fetch --progress $GIT_FETCH_EXTRA_OPTIONS origin "$GIT_REF_SPEC" || return 1
            run git -C "$PACKAGE_SRC_FILEPATH" checkout --progress --force -B "$GIT_BRANCH_NAME" "refs/remotes/origin/$GIT_BRANCH_NAME" || return 1
            run git -C "$PACKAGE_SRC_FILEPATH" submodule update --init || return 1
            ;;
        *)  if [ -z    "$PACKAGE_SRC_URI" ] ; then
                wfetch "$PACKAGE_SRC_URL" --sha256="$PACKAGE_SRC_SHA" --output-path="$PACKAGE_SRC_FILEPATH"
            else
                wfetch "$PACKAGE_SRC_URL" --sha256="$PACKAGE_SRC_SHA" --output-path="$PACKAGE_SRC_FILEPATH" --uri="$PACKAGE_SRC_URI"
            fi
    esac
}

__fetch_patches_of_the_given_package() {
    if [ -n    "$PACKAGE_FIX_URL" ] ; then
        wfetch "$PACKAGE_FIX_URL" --sha256="$PACKAGE_FIX_SHA" --output-path="$PACKAGE_FIX_FILEPATH"
    fi
    if [ -n    "$PACKAGE_RES_URL" ] ; then
        wfetch "$PACKAGE_RES_URL" --sha256="$PACKAGE_RES_SHA" --output-path="$PACKAGE_RES_FILEPATH"
    fi
}

__fetch_resources_of_the_given_package() {
    [ -z "$1" ] && abort 1 "__fetch_resources_of_the_given_package <PACKAGE-NAME>, <PACKAGE-NAME> is unspecified."

    case $1 in
        @all)
            shift
            unset STEP_NUM
            for PKG in $(__list_available_packages)
            do
                step "$PKG"
                 __load_formula_of_the_given_package "$PKG"
                __fetch_sources_of_the_given_package "$PKG" "$@"
                __fetch_patches_of_the_given_package "$PKG" "$@"
            done
            ;;
        *)
             __load_formula_of_the_given_package "$1"
            __fetch_sources_of_the_given_package "$@"
            __fetch_patches_of_the_given_package "$@"
    esac
}

# }}}
##############################################################################
# {{{ ndk-pkg tree

# __tree_the_given_installed_package <PACKAGE-SPEC>
  __tree_the_given_installed_package() {
    PACKAGE_INSTALL_DIR="$(peel_installed_root_dir_for_the_given_package "$1")"

    shift

    run tree "$@" "$PACKAGE_INSTALL_DIR"
}

# }}}
##############################################################################
# {{{ ndk-pkg logs

# __logs_the_given_installed_package <PACKAGE-SPEC>
  __logs_the_given_installed_package() {
    PACKAGE_INSTALL_DIR="$(peel_installed_root_dir_for_the_given_package "$1")"

    FILEPATHS=
    FILEPATHS="$(find "$PACKAGE_INSTALL_DIR/.ndk-pkg" -type f)"

    for filepath in $FILEPATHS
    do
        [ -d "$filepath" ] && continue

        case $filepath in
            *.png)  ;;
            *.yml)  run yq . "$filepath" ;;
            *.json) run jq . "$filepath" ;;
            *)  if command -v bat > /dev/null ; then
                    bat  "$filepath"
                else
                    less "$filepath"
                fi
        esac
    done
}

# }}}
##############################################################################
# {{{ ndk-pkg pack

# examples:
# __pack_the_given_installed_package <PACKAGE-NAME|PACKAGE-SPEC> [-t <zip|tar.gz|tar.xz|tar.lz|tar.bz2>] [-o <OUTPUT-PATH>] [--keep-working-dir]
  __pack_the_given_installed_package() {
    __load_receipt_of_the_given_package "$1"

    shift

    unset OUTPUT_DIR
    unset OUTPUT_FILETYPE
    unset OUTPUT_FILEPATH

    unset KEEP_WORKING_DIR

    while [ -n "$1" ]
    do
        case $1 in
            --keep-working-dir)
                KEEP_WORKING_DIR=yes
                ;;
            -t) shift

                if [ -z "$1" ] ; then
                    abort 1 "$_0 pack <PACKAGE-NAME> [-t <OUTPUT-TYPE>] [-o <OUTPUT-PATH>], -t option is given but <OUTPUT-TYPE> is unspecified."
                else
                    OUTPUT_FILETYPE="$1"
                fi

                case $OUTPUT_FILETYPE in
                    zip|tar.gz|tar.xz|tar.lz|tar.bz2) ;;
                    *) abort 1 "$_0 pack <PACKAGE-NAME> [-t <OUTPUT-TYPE>], unsupported <OUTPU-TYPE>: $OUTPUT_FILETYPE, <OUTPU-TYPE> should be one of zip|tar.gz|tar.xz|tar.lz|tar.bz2"
                esac
                ;;
            -o) shift
                if [ -z "$1" ] ; then
                    abort 1 "$_0 pack <PACKAGE-NAME> [-t <OUTPU-TYPE>] [-o <OUTPUT-PATH>], -o option is given but <OUTPUT-PATH> is unspecified."
                else
                    OUTPUT_FILEPATH="$1"
                fi
                ;;
            *)  abort 1 "$_0 pack <PACKAGE-NAME> [-t <OUTPUT-TYPE>] [-o <OUTPUT-PATH>] [--keep-working-dir], unrecognized option: $1"
        esac
        shift
    done

    ###########################################################################################

    OUTPUT_FILENAME_NEED_CONTAIN_MIN_SDK_API_LEVEL=no

    BASE64_ENCODED_RELATIVE_FILEPATH_LIST=
    BASE64_ENCODED_RELATIVE_FILEPATH_LIST="$(cd "$PACKAGE_INSTALLED_DIR" && find -not -name . -type f -exec base64-encode '{}' \;)"

    for BASE64_ENCODED_RELATIVE_FILEPATH in $BASE64_ENCODED_RELATIVE_FILEPATH_LIST
    do
        BASE64_DECODED_RELATIVE_FILEPATH=
        BASE64_DECODED_RELATIVE_FILEPATH="$(base64-decode "$BASE64_ENCODED_RELATIVE_FILEPATH")"

        FILEPATH="$PACKAGE_INSTALLED_DIR/${BASE64_DECODED_RELATIVE_FILEPATH#./}"

        FILEMAGIC=
        FILEMAGIC="$(head -c 4 "$FILEPATH" | base16-encode)"

        # http://www.sco.com/developers/gabi/latest/ch4.eheader.html
        if [ "$FILEMAGIC" = '7F454C46' ] ; then
            # may report: patchelf: cannot find section '.interp'. The input file is most likely statically linked
            PT_INTERP=
            PT_INTERP="$(patchelf --print-interpreter "$FILEPATH" 2>/dev/null || true)"

            if [ -n "$PT_INTERP" ] ; then
                OUTPUT_FILENAME_NEED_CONTAIN_MIN_SDK_API_LEVEL=yes
                break
            fi

            DT_SONAME=
            DT_SONAME="$(patchelf --print-soname "$FILEPATH")"

            if [ -n "$DT_SONAME" ] ; then
                OUTPUT_FILENAME_NEED_CONTAIN_MIN_SDK_API_LEVEL=yes
                break
            fi
        elif basename "$FILEPATH" | grep -q '^lib.*\.a$' ; then
            OUTPUT_FILENAME_NEED_CONTAIN_MIN_SDK_API_LEVEL=yes
            break
        elif basename "$FILEPATH" | grep -q '^lib.*\.so' ; then
            OUTPUT_FILENAME_NEED_CONTAIN_MIN_SDK_API_LEVEL=yes
            break
        fi
    done

    ###########################################################################################

    case $PACKAGE_RECEIPT_BUILT_FOR_ANDROID_ABI in
        armeabi-v7a) TARGET_ANDROID_ARCH='armv7a'  ;;
        arm64-v8a)   TARGET_ANDROID_ARCH='aarch64' ;;
        x86)         TARGET_ANDROID_ARCH='i686'    ;;
        x86_64)      TARGET_ANDROID_ARCH='x86_64'  ;;
    esac

    if [ "$OUTPUT_FILENAME_NEED_CONTAIN_MIN_SDK_API_LEVEL" = yes ] ; then
        PACKED_DIR_NAME="$PACKAGE_RECEIPT_PKGNAME-$PACKAGE_RECEIPT_VERSION-android$PACKAGE_RECEIPT_BUILT_FOR_ANDROID_API-$TARGET_ANDROID_ARCH"
    else
        PACKED_DIR_NAME="$PACKAGE_RECEIPT_PKGNAME-$PACKAGE_RECEIPT_VERSION-android-$TARGET_ANDROID_ARCH"
    fi

    ###########################################################################################

    if [ -z "$OUTPUT_FILEPATH" ] ; then
        if [ -z "$OUTPUT_FILETYPE" ] ; then
            OUTPUT_FILETYPE='tar.xz'
        fi

        OUTPUT_DIR="$NDKPKG_HOME/packed"
        OUTPUT_FILENAME="$PACKED_DIR_NAME.$OUTPUT_FILETYPE"
    else
        if [ -d "$OUTPUT_FILEPATH" ] ; then
            if [ -z "$OUTPUT_FILETYPE" ] ; then
                OUTPUT_FILETYPE='tar.xz'
            fi

            OUTPUT_DIR="$(realpath -s "$OUTPUT_FILEPATH")"
            OUTPUT_FILENAME="$PACKED_DIR_NAME.$OUTPUT_FILETYPE"
        else
            case $OUTPUT_FILEPATH in
                */)
                    if [ -z "$OUTPUT_FILETYPE" ] ; then
                        OUTPUT_FILETYPE='tar.xz'
                    fi

                    OUTPUT_DIR="$(realpath -s "$OUTPUT_FILEPATH")"
                    OUTPUT_FILENAME="$PACKED_DIR_NAME.$OUTPUT_FILETYPE"
                    ;;
                *)
                    OUTPUT_FILEPATH="$(realpath -s "$OUTPUT_FILEPATH")"

                    if [ -z "$OUTPUT_FILETYPE" ] ; then
                        case $OUTPUT_FILEPATH in
                            *.tar.gz|*.tgz)
                                OUTPUT_FILETYPE=tar.gz
                                ;;
                            *.tar.xz|*.txz)
                                OUTPUT_FILETYPE=tar.xz
                                ;;
                            *.tar.lz|*.tlz)
                                OUTPUT_FILETYPE=tar.lz
                                ;;
                            *.tar.bz2|*.tbz2)
                                OUTPUT_FILETYPE=tar.bz2
                                ;;
                            *.zip)
                                OUTPUT_FILETYPE=zip
                                ;;
                            *.7z)
                                OUTPUT_FILETYPE=7z
                                ;;
                            *)  abort 1 "when -t <OUTPUT-TYPE> option is not given, -o <OUTPUT-PATH> option specified filename must ends with one of .tar.gz|.tar.xz|.tar.lz|.tar.bz2|.tgz|.txz|.tlz|.tbz2|.zip|.7z"
                        esac
                    fi

                    OUTPUT_DIR="$(dirname "$OUTPUT_FILEPATH")"
                    OUTPUT_FILENAME="$(basename "$OUTPUT_FILEPATH")"
            esac
        fi
    fi

    ###########################################################################################

    WORKING_DIR="$NDKPKG_HOME/run/$$"

    step "create the working directory and change to it"
    run rm -rf     "$WORKING_DIR"
    run install -d "$WORKING_DIR"
    run cd         "$WORKING_DIR"

    step "make link refer to installed package root directory"
    run ln -s "$PACKAGE_INSTALLED_DIR" "$PACKED_DIR_NAME"

    step "packing"
    case $OUTPUT_FILETYPE in
        zip) run zip -9 -r             "$OUTPUT_FILENAME" "$PACKED_DIR_NAME" ;;
        7z)  run 7za a -t7z -r         "$OUTPUT_FILENAME" "$PACKED_DIR_NAME/*" "$PACKED_DIR_NAME/.ndk-pkg" ;;
        tar.xz)  run tar cv --xz    -f "$OUTPUT_FILENAME" "$PACKED_DIR_NAME/*" "$PACKED_DIR_NAME/.ndk-pkg" ;;
        tar.gz)  run tar cv --gzip  -f "$OUTPUT_FILENAME" "$PACKED_DIR_NAME/*" "$PACKED_DIR_NAME/.ndk-pkg" ;;
        tar.lz)  run tar cv --lzip  -f "$OUTPUT_FILENAME" "$PACKED_DIR_NAME/*" "$PACKED_DIR_NAME/.ndk-pkg" ;;
        tar.bz2) run tar cv --bzip2 -f "$OUTPUT_FILENAME" "$PACKED_DIR_NAME/*" "$PACKED_DIR_NAME/.ndk-pkg" ;;
    esac

    step "check integrity of packed file"
    case $OUTPUT_FILETYPE in
        7z)    run 7za t -t7z "$OUTPUT_FILENAME" ;;
        zip)   run unzip -t   "$OUTPUT_FILENAME" ;;
        tar.*) run tar   -tf  "$OUTPUT_FILENAME" ;;
    esac

    step "show size of packed file"
    run "du -sh $OUTPUT_FILENAME | cut -f1"

    if [ ! -d "$OUTPUT_DIR" ] ; then
        step "create output directory"
        run install -d "$OUTPUT_DIR"
    fi

    step "copy packed file to output directory"
    run cp "$OUTPUT_FILENAME" "$OUTPUT_DIR/"

    if [ "$KEEP_WORKING_DIR" = yes ] ; then
        printf '\n'
        note "the working directory '$WORKING_DIR' is not deleted as --keep-working-dir option is given."
    else
        step "delete the working directory"
        run rm -rf "$WORKING_DIR"
    fi
}

# __create_google_prefab_for_the_given_installed_package <PACKAGE-SPEC>
  __create_google_prefab_for_the_given_installed_package() {
    __load_receipt_of_the_given_package "$1"

    PACKAGE_NAME="$PACKAGE_RECEIPT_PKGNAME"

    TARGET_ANDROID_API="$PACKAGE_RECEIPT_BUILT_FOR_ANDROID_API"
    TARGET_ANDROID_ABI="$PACKAGE_RECEIPT_BUILT_FOR_ANDROID_ABI"

    PACKAGE_INCLUDE_DIR="$PACKAGE_INSTALLED_DIR/include"
    PACKAGE_LIBRARY_DIR="$PACKAGE_INSTALLED_DIR/lib-for-apk"

    #########################################################################################

    [ -d "$PACKAGE_INCLUDE_DIR" ] || abort 10 "unable to be exported as google prefab, because there is no C/C++ header files in package $PACKAGE_SPEC"

    run install -d prefab/modules/headers
    run cp -r "$PACKAGE_INCLUDE_DIR" prefab/modules/headers/

    #########################################################################################

    unset PACKAGE_STATIC_LIBRARY_FILENAMES
    unset PACKAGE_SHARED_LIBRARY_FILENAMES

    if [ -d "$PACKAGE_LIBRARY_DIR" ] ; then
        PACKAGE_STATIC_LIBRARY_FILENAMES="$(find "$PACKAGE_LIBRARY_DIR" -maxdepth 1 -mindepth 1 -type f -name 'lib*.a'  -printf '%P\n')"
        PACKAGE_SHARED_LIBRARY_FILENAMES="$(find "$PACKAGE_LIBRARY_DIR" -maxdepth 1 -mindepth 1 -type f -name 'lib*.so' -printf '%P\n')"
    fi

    PACKAGE_LIBRARY_FILENAMES="$PACKAGE_STATIC_LIBRARY_FILENAMES $PACKAGE_SHARED_LIBRARY_FILENAMES"

    for LIBRARY_FILENAME in $PACKAGE_LIBRARY_FILENAMES
    do
        case $LIBRARY_FILENAME in
            *.a)  LIBRARY_FILENAME_PREFIX="${LIBRARY_FILENAME%.a}"  ; IS_STATIC_LIBRARY=true  ;;
            *.so) LIBRARY_FILENAME_PREFIX="${LIBRARY_FILENAME%.so}" ; IS_STATIC_LIBRARY=false ;;
        esac

        MODULE_DIR="prefab/modules/$LIBRARY_FILENAME"

        run install -d "$MODULE_DIR"

        cat > "$MODULE_DIR/module.json" <<EOF
{
  "export_libraries": [],
  "android": {
    "library_name": "$LIBRARY_FILENAME_PREFIX",
    "export_libraries": []
  }
}
EOF

        run cp -r "$PACKAGE_INCLUDE_DIR" "$MODULE_DIR/"

        ABI_DIR="$MODULE_DIR/libs/android.$TARGET_ANDROID_ABI"

        run install -d "$ABI_DIR"

        LIBRARY_FILEPATH="$PACKAGE_LIBRARY_DIR/$LIBRARY_FILENAME"

        run cp "$LIBRARY_FILEPATH" "$ABI_DIR"

        STL=none

        # https://github.com/google/prefab/blob/master/api/src/main/kotlin/com/google/prefab/api/Android.kt#L202
        if [ "$IS_STATIC_LIBRARY" = true ] ; then
            if   "$ANDROID_NDK_NM" "$LIBRARY_FILEPATH" | grep -q 'T __cxa_' ; then
                abort 1 "libc++_static.a has been merged into $LIBRARY_FILEPATH, this may case problems. For more details, please refer to https://developer.android.com/ndk/guides/cpp-support"
            elif "$ANDROID_NDK_NM" "$LIBRARY_FILEPATH" | grep -q 'U __cxa_' ; then
                STL=c++_shared
            fi
        else
            if "$ANDROID_NDK_READELF" -d "$LIBRARY_FILEPATH" | grep -q 'libc++_shared\.so' ; then
                STL=c++_shared
            elif "$ANDROID_NDK_NM" -D "$LIBRARY_FILEPATH" | grep -q 'T __cxa_' ; then
                # https://softwareengineering.stackexchange.com/questions/262195/whats-wrong-with-statically-linking-the-stl-into-multiple-shared-libraries
                # https://developer.android.com/ndk/guides/cpp-support
                abort 1 "libc++_static.a has been linked into $LIBRARY_FILEPATH, this may case problems. For more details, please refer to https://developer.android.com/ndk/guides/cpp-support"
            fi
        fi

        printf "{\"ndk\": %s, \"api\": %s, \"abi\": \"%s\", \"stl\": \"%s\", \"static\": %s}" "${PACKAGE_RECEIPT_NDKVERS%%.*}" "$TARGET_ANDROID_API" "$TARGET_ANDROID_ABI" "$STL" "$IS_STATIC_LIBRARY" > "$ABI_DIR/abi.json"
    done

    #########################################################################################

    # https://google.github.io/prefab/#package-metadata
    #
    # For compatibility with CMake, versions must be specified as major[.minor[.patch[.tweak]]] with all components being numeric.

    unset VERSION

    if [ -z "$PACKAGE_RECEIPT_VERSION" ] ; then
        VERSION="$(format_unix_timestamp "$PACKAGE_RECEIPT_TIMESTAMP" '+%Y.%m.%d')"
    else
        unset SED_E

        I=0

        for CHAR in a b c d e f g h i j k l m n o p q r s t u v w x y z
        do
            I=$(expr "$I" + 1)
            SED_E="$SED_E -e s|$CHAR|.$I|g"
        done

        # r3060
        # 1.4.rc5
        # 2022-03-28
        # 2.4+20151223
        # 1.1.1n
        # 9e
        # 2.8.9rel.1
        # 0.14.1-beta
        # 0.99.beta20
        # 3.0-11
        # 1.4g
        # 0.15.2e
        VERSION="$(printf '%s\n' "$PACKAGE_RECEIPT_VERSION" | tr +- . | sed -e 's|beta|2|' -e 's|rel||' -e 's|rc|.|' -e 's|^r||' $SED_E)"

        printf '%s\n' "$VERSION" | {
            grep -q '[0-9]*' ||
            grep -q '[0-9]*\.[0-9]*' ||
            grep -q '[0-9]*\.[0-9]*\.[0-9]*' ||
            grep -q '[0-9]*\.[0-9]*\.[0-9]*\.[0-9]*'
        } || abort 1 "version[$VERSION] not expected."
    fi

    unset DEPENDENCIES

    for DEPENDENT_PACKAGE_NAME in $PACKAGE_RECEIPT_DEP_PKG
    do
        if [ -z "$DEPENDENCIES" ] ; then
            DEPENDENCIES="\"$DEPENDENT_PACKAGE_NAME\""
        else
            DEPENDENCIES="$DEPENDENCIES, \"$DEPENDENT_PACKAGE_NAME\""
        fi
    done

    cat > prefab/prefab.json <<EOF
{
  "schema_version": 2,
  "name": "$PACKAGE_NAME",
  "version": "$VERSION",
  "dependencies": [ ]
}
EOF
}

# __export_google_prefab_aar_for_the_given_installed_packages <PACKAGE-NAME>/android-<ANDROID-API>/<ANDROID-ABIS> [--ndk-home=<ANDROID-NDK-HOME>] [-o <OUTPUT-PATH>]
  __export_google_prefab_aar_for_the_given_installed_packages() {
    unset PACKAGE_NAME

    unset TARGET_ANDROID_API
    unset TARGET_ANDROID_ABIS

    case $1 in
        *:android-[1-9][0-9]:*)
            PACKAGE_NAME="${1%%:*}"

            if [ -z "$PACKAGE_NAME" ] ; then
                abort 1 "invalid argument: $1\n    package name is unspecifed."
            elif printf '%s\n' "$PACKAGE_NAME" | grep -q -E '^[A-Za-z0-9+-_.@]{1,50}$' ; then
                :
            else
                abort 1 "invalid argument: $1\n    package name must match the regular expression pattern: ^[A-Za-z0-9+-_.@]{1,50}$"
            fi

            TARGET_ANDROID_API="$( printf '%s\n' "$1" | cut -d: -f2 | cut -d- -f2)"
            TARGET_ANDROID_ABIS="$(printf '%s\n' "$1" | cut -d: -f3 | tr ',' ' ')"

            if [ -z "$TARGET_ANDROID_ABIS" ] ; then
                abort 1 "invalid argument: $1\n    android abis are unspecified."
            fi

            for TARGET_ANDROID_ABI in $TARGET_ANDROID_ABIS
            do
                case $TARGET_ANDROID_ABI in
                    armeabi-v7a|arm64-v8a|x86|x86_64) ;;
                    *)  abort 1 "invalid argument: $1\n    unrecognized android abi: $TARGET_ANDROID_ABI"
                esac
            done
            ;;
        *)  abort 1 "invalid argument: $1"
    esac

    shift

    unset USER_SPECIFIED_ANDROID_NDK_HOME

    unset OUTPUT_FILEPATH

    while [ -n "$1" ]
    do
        case $1 in
            --ndk-home=*)
                USER_SPECIFIED_ANDROID_NDK_HOME="${1#*=}"
                ;;
            -o) shift
                if [ -z "$1" ] ; then
                    abort 1 "-o option is specified but <OUTPUT-PATH> is unspecified."
                else
                    OUTPUT_FILEPATH="$(realpath -s "$1")"
                fi
        esac
        shift
    done

    #########################################################################################

    step "find or install android ndk"

    NDKINFO=

    if [ -z "$USER_SPECIFIED_ANDROID_NDK_HOME" ] ; then
        NDKINFO="$(ndkinfo || true)"
    else
        NDKINFO="$(ndkinfo "$USER_SPECIFIED_ANDROID_NDK_HOME")"
    fi

    if [ -z "$NDKINFO" ] ; then
        # https://github.com/microsoft/WSL/issues/8681
        # https://github.com/microsoft/WSL/issues/4071

        if [ "$NATIVE_OS_KIND" = linux ] && grep -q -i Microsoft /proc/version ; then
            UPPM_PACKAGE_NAME_NDK='android-ndk-r23c'
        else
            UPPM_PACKAGE_NAME_NDK='android-ndk-r25c'
        fi

        "$UPPM" is-installed "$UPPM_PACKAGE_NAME_NDK" || {
            warn "Android NDK not found, it will be installed via uppm."
            "$UPPM" install  "$UPPM_PACKAGE_NAME_NDK"
        }

        ANDROID_NDK_HOME="$("$UPPM" info "$UPPM_PACKAGE_NAME_NDK" installed-dir)"

        NDKINFO="$(ndkinfo "$ANDROID_NDK_HOME")"
    fi

    echo "$NDKINFO"
    eval "$NDKINFO"

    export ANDROID_NDK_HOME
    export ANDROID_NDK_ROOT

    #########################################################################################

    WORKING_DIR="$NDKPKG_HOME/run/$$"

    step "create the working directory and change to it"
    run rm -rf     "$WORKING_DIR"
    run install -d "$WORKING_DIR"
    run cd         "$WORKING_DIR"

    #########################################################################################

    for TARGET_ANDROID_ABI in $TARGET_ANDROID_ABIS
    do
        PACKAGE_SPEC="$PACKAGE_NAME:android-$TARGET_ANDROID_API:$TARGET_ANDROID_ABI"
        step "create prefab hierarchial structure for $PACKAGE_SPEC"
        __create_google_prefab_for_the_given_installed_package "$PACKAGE_SPEC"
    done

    #########################################################################################

    PREFAB_MODULES="$(find prefab/modules -maxdepth 1 -mindepth 1 -type d -printf '%P ')"

    PREFAB_MODULES="${PREFAB_MODULES% }"

    #########################################################################################

    # https://developer.android.com/studio/projects/android-library#aar-contents
    step "create META-INF"
    run install -d META-INF
    cat > META-INF/README.ndk-pkg <<EOF
packed by ndk-pkg-$NDKPKG_VERSION in $(format_unix_timestamp "$TIMESTAMP_UNIX" '+%Y-%m-%d %H:%M:%S') UTC

For more details, please refer to https://github.com/leleliu008/ndk-pkg
EOF
    run cp -r "$PACKAGE_INSTALLED_DIR/.ndk-pkg"/* META-INF/

    #########################################################################################

    unset JAVA_PACKAGE_NAME

    # java package name characters [a-z0-9_.]
    JAVA_PACKAGE_NAME="$(printf '%s\n' "$PACKAGE_NAME" | tr '+-.' '_' | tr A-Z a-z)"

    step "create AndroidManifest.xml"
    tee AndroidManifest.xml <<EOF
<?xml version="1.0" encoding="utf-8"?>
<manifest
    xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.fpliu.ndk.pkg.prefab.android$TARGET_ANDROID_API.$JAVA_PACKAGE_NAME">

    <uses-sdk android:minSdkVersion="$TARGET_ANDROID_API" />

</manifest>
EOF

    #########################################################################################

    AAR_FILENAME="$PACKAGE_NAME-$PACKAGE_RECEIPT_VERSION.aar"

    step "packing the prefab aar file"
    run zip -9 -r "$AAR_FILENAME" .

    step "check integrity of the prefab aar file"
    run unzip -t  "$AAR_FILENAME"

    step "show size of the prefab aar file"
    run du -sh    "$AAR_FILENAME"

    step "show working directory in tree-like format"
    run tree --dirsfirst .

    ###########################################################################################

    if [ "$NDKPKG_ACTION" = 'deploy' ] ; then
        return 0
    fi

    if [ -z "$OUTPUT_FILEPATH" ] ; then
        printf '%b\n' "
${COLOR_GREEN}Note:${COLOR_OFF}
    ${COLOR_RED}NOT proceed due to -o <OUTPUT-PATH> option is unspecified.${COLOR_OFF}

    ${COLOR_RED}If you want to continue, please manually execute following commands:${COLOR_OFF}

    cd $WORKING_DIR
    cp $AAR_FILENAME /somewhere
    cd -
    rm -rf $WORKING_DIR
        "
        return 0
    fi

    ###########################################################################################

    if [ -d "$OUTPUT_FILEPATH" ] ; then
        OUTPUT_DIR="$OUTPUT_FILEPATH"
        OUTPUT_FILEPATH="$OUTPUT_FILEPATH/$AAR_FILENAME"
    else
        case $OUTPUT_FILEPATH in
            */)
                OUTPUT_DIR="$OUTPUT_FILEPATH"
                OUTPUT_FILEPATH="$OUTPUT_FILEPATH/$AAR_FILENAME"
                ;;
            *)
                OUTPUT_DIR="${OUTPUT_FILEPATH%/*}"
                OUTPUT_FILENAME="${OUTPUT_FILEPATH##*/}"
        esac
    fi

    if [ ! -d "$OUTPUT_DIR" ] ; then
        step "create the output directory"
        run install -d "$OUTPUT_DIR"
    fi

    step "copy prefab aar file to destination"
    run cp "$AAR_FILENAME" "$OUTPUT_FILEPATH"

    step "delete the working directory"
    run rm -rf "$WORKING_DIR"
}

# __deploy_google_prefab_aar_for_the_given_installed_packages <PACKAGE-NAME>/android-<ANDROID-API>/<ANDROID-ABIS> [--ndk-home=<ANDROID-NDK-HOME>] [--groupId] [--keep-working-dir] [--dry-run] [--debug] [--remote < REMOTE-CONFIG-FILE]
  __deploy_google_prefab_aar_for_the_given_installed_packages() {
    __export_google_prefab_aar_for_the_given_installed_packages "$@"

    #########################################################################################

    shift

    unset USER_SPECIFIED_ANDROID_NDK_HOME

    unset DEPLOYED_TO_SONATYPE_OSSRH
    unset DEPLOYED_TO_SPECIFIED_LOCAL_PATH

    unset KEEP_WORKING_DIR

    unset MVN_OPTIONS

    unset DRYRUN

    unset GROUPID

    while [ -n "$1" ]
    do
        case $1 in
            --ndk-home=*)
                USER_SPECIFIED_ANDROID_NDK_HOME="${1#*=}"
                ;;
            --debug)
                MVN_OPTIONS=-X
                ;;
            --remote)
                DEPLOYED_TO_SONATYPE_OSSRH=yes
                ;;
            --local=*)
                DEPLOYED_TO_SPECIFIED_LOCAL_PATH="${1#*=}"
                ;;
            --dry-run)
                DRYRUN=yes
                ;;
            --keep-working-dir)
                KEEP_WORKING_DIR=yes
                ;;
            --groupId=*)
                GROUPID="${1#*=}"
                ;;
            *)  abort 1 "unrecognized argument: $1"
        esac

        shift
    done

    #########################################################################################

    [ -z "$GROUPID" ] && GROUPID="com.fpliu.ndk.pkg.prefab.android.$TARGET_ANDROID_API"

    #########################################################################################

    if [ -z "$DEPLOYED_TO_SONATYPE_OSSRH" ] && [ -z "$DEPLOYED_TO_SPECIFIED_LOCAL_PATH" ] ; then
        if [ "$DRYRUN" = yes ] ; then
            printf '%b\n' "
${COLOR_GREEN}Note:${COLOR_OFF}
    ${COLOR_RED}NOT proceed due to --dry-run option is specified.${COLOR_OFF}

    ${COLOR_RED}If you want to continue, please manually execute following commands:${COLOR_OFF}

    cd $WORKING_DIR
    mvn $MVN_OPTIONS install:install-file -Dfile=$AAR_FILENAME -DgroupId=$GROUPID -DartifactId=$PACKAGE_NAME -Dversion=$PACKAGE_RECEIPT_VERSION -Dpackaging=aar -DgeneratePom=true
    cd -
    rm -rf $WORKING_DIR
            "
            return 0
        fi

        if command -v mvn > /dev/null ; then
            MVN_COMMAND=mvn
        else
            step "install maven"
            run uppm install maven

            unset  JAVA_HOME
            unset MAVEN_HOME

            export JAVA_HOME="$(uppm info jdk17 installed-dir)"
            export PATH="$JAVA_HOME/bin:$PATH"
            export CLASSPATH=".:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar"

            MAVEN_HOME="$(uppm info maven installed-dir)"

            MVN_COMMAND="$MAVEN_HOME/bin/mvn"
        fi

        # https://maven.apache.org/plugins/maven-install-plugin/install-file-mojo.html
        step "deploying the prefab aar to Maven Local Repository"
        run "$MVN_COMMAND" $MVN_OPTIONS install:install-file "-Dfile=$AAR_FILENAME" "-DgroupId=$GROUPID" "-DartifactId=$PACKAGE_NAME" "-Dversion=$PACKAGE_RECEIPT_VERSION" -Dpackaging=aar -DgeneratePom=true

        if [ "$KEEP_WORKING_DIR" = yes ] ; then
            printf '\n'
            note "the working directory '$WORKING_DIR' is not deleted as --keep-working-dir option is given."
        else
            step "delete the working directory"
            run rm -rf "$WORKING_DIR"
        fi

        printf '%b\n' "
${COLOR_YELLOW}
======================================================
Use this artifact alongside with Android Gradle Plugin
======================================================${COLOR_OFF}

${COLOR_GREEN}step1. enable prefab feature for Android Gradle Plugin${COLOR_OFF}

android {
    buildFeatures {
        prefab true
    }
}

${COLOR_GREEN}step2. enable mavenLocal repository for Gradle${COLOR_OFF}

repositories {
    mavenLocal()
}

${COLOR_GREEN}step3. configure dependencies${COLOR_OFF}

${COLOR_PURPLE}For Gradle Groovy DSL:${COLOR_OFF}

dependencies {
    implementation '$GROUPID:$PACKAGE_NAME:$PACKAGE_RECEIPT_VERSION@aar'
}

${COLOR_PURPLE}For Gradle Kotlin DSL:${COLOR_OFF}

dependencies {
    implementation(\"$GROUPID:$PACKAGE_NAME:$PACKAGE_RECEIPT_VERSION@aar\")
}

${COLOR_GREEN}step4. find package and link libraries in your Android project's CMakeLists.txt${COLOR_OFF}

${COLOR_PURPLE}This prefab package has $(list_size $PREFAB_MODULES) modules : $PREFAB_MODULES${COLOR_OFF}

find_package($PACKAGE_NAME REQUIRED CONFIG)
target_link_libraries(app $PACKAGE_NAME::${PREFAB_MODULES%% *})

${COLOR_GREEN}step5. configure C++ standard and STL (optional)${COLOR_OFF}

android {
    defaultConfig {
        externalNativeBuild {
            cmake {
                arguments '-DANDROID_STL=c++_shared'
                cppFlags  '-std=c++17'
            }
        }
    }
}

${COLOR_RED}Caveat: If you link a shared library that depends on libc++_shared.so, then your Android app should use libc++_shared.so too.${COLOR_OFF}
"
        return 0
    fi

    if [ -n "$DEPLOYED_TO_SONATYPE_OSSRH" ] && [ -n "$DEPLOYED_TO_SPECIFIED_LOCAL_PATH" ] ; then
        abort 1 '--remote and --local=<DIR> can not used as the same time.'
    fi

    #########################################################################################

    # https://central.sonatype.org/publish/release/
    # https://central.sonatype.org/publish/requirements/
    # https://central.sonatype.org/publish/publish-manual/

    if [ -n "$DEPLOYED_TO_SONATYPE_OSSRH" ] ; then
        if [ -z "$PACKAGE_RECEIPT_LICENSE" ] ; then
            abort 1 "can not be deployed to Sonatype OSSRH due to PACKAGE_RECEIPT_LICENSE is empty."
        fi

        if [ -z "$PACKAGE_RECEIPT_GIT_URL" ] && [ -z "$PACKAGE_RECEIPT_SVN_URL" ] ; then
            abort 1 "can not be deployed to Sonatype OSSRH due to PACKAGE_RECEIPT_GIT_URL and PACKAGE_RECEIPT_SVN_URL is empty."
        fi
    fi

    step "generating pom.xml"
    cat > pom.xml <<EOF
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>$GROUPID</groupId>
    <artifactId>$PACKAGE_NAME</artifactId>
    <version>$PACKAGE_RECEIPT_VERSION</version>
    <packaging>aar</packaging>

    <name>$PACKAGE_NAME</name>
    <description>$PACKAGE_RECEIPT_SUMMARY</description>
    <url>$PACKAGE_RECEIPT_WEB_URL</url>
EOF

    PACKAGE_RECEIPT_SCM_URL=

    if [ -n "$PACKAGE_RECEIPT_GIT_URL" ] ; then
        PACKAGE_RECEIPT_SCM_TYPE=git
        PACKAGE_RECEIPT_SCM_URL="$PACKAGE_RECEIPT_GIT_URL"
    fi

    if [ -n "$PACKAGE_RECEIPT_SVN_URL" ] ; then
        PACKAGE_RECEIPT_SCM_TYPE=svn
        PACKAGE_RECEIPT_SCM_URL="$PACKAGE_RECEIPT_SVN_URL"
    fi

    if [ -n "$PACKAGE_RECEIPT_SCM_URL" ] ; then
        cat >> pom.xml <<EOF

    <scm>
        <connection>scm:$PACKAGE_RECEIPT_SCM_TYPE:$PACKAGE_RECEIPT_SCM_URL</connection>
        <developerConnection>scm:$PACKAGE_RECEIPT_SCM_TYPE:$PACKAGE_RECEIPT_SCM_URL</developerConnection>
        <url>$PACKAGE_RECEIPT_SCM_URL</url>
    </scm>
EOF
    fi

    if [ -z "$PACKAGE_RECEIPT_DEVELOPER" ] ; then
        PACKAGE_RECEIPT_DEVELOPER="$PACKAGE_NAME developers <unknown>"
    fi

    printf '\n    <developers>\n' >> pom.xml

    export IFS='
'

    for DEVELOPER in $PACKAGE_RECEIPT_DEVELOPER
    do
        DEVELOPER_NAME=
        DEVELOPER_EMAIL=

        DEVELOPER_NAME="${DEVELOPER% <*>}"

        if [ "$DEVELOPER" != "$DEVELOPER_NAME" ] ; then
            DEVELOPER_EMAIL="$(printf '%s\n' "$DEVELOPER" | sed -e 's|.* <\(.*\)>|\1|')"
        fi

        cat >> pom.xml <<EOF
        <developer>
            <name>$DEVELOPER_NAME</name>
            <email>$DEVELOPER_EMAIL</email>
        </developer>
EOF
    done

    unset IFS

    printf '    </developers>\n' >> pom.xml

    if [ -n "$PACKAGE_RECEIPT_LICENSE" ] ; then
        printf '\n    <licenses>\n' >> pom.xml

        for LICENSE_NAME in $PACKAGE_RECEIPT_LICENSE
        do
            cat >> pom.xml <<EOF
        <license>
            <name>$LICENSE_NAME</name>
            <url>https://raw.githubusercontent.com/spdx/license-list-data/master/text/$LICENSE_NAME.txt</url>
        </license>
EOF
        done

        printf '    </licenses>\n' >> pom.xml
    fi

    printf '</project>\n' >> pom.xml

    cat pom.xml

    #########################################################################################

    POM_FILE="${AAR_FILENAME%.aar}.pom"

    step "rename pom.xml to $POM_FILE"
    run mv pom.xml "$POM_FILE"

    #########################################################################################

    if [ -n "$DEPLOYED_TO_SPECIFIED_LOCAL_PATH" ] ; then
        cd -
        DEPLOYED_TO_SPECIFIED_LOCAL_PATH="$(realpath -s "$DEPLOYED_TO_SPECIFIED_LOCAL_PATH")"
        cd -

        if [ "$DRYRUN" = yes ] ; then
            printf '%b\n' "
${COLOR_GREEN}Note:${COLOR_OFF}
    ${COLOR_RED}NOT proceed due to --dry-run option is specified.${COLOR_OFF}

    ${COLOR_RED}If you want to continue, please manually execute following commands:${COLOR_OFF}

    cd $WORKING_DIR
    mvn $MVN_OPTIONS install:install-file -Dfile=$AAR_FILENAME -DgroupId=$GROUPID -DartifactId=$PACKAGE_NAME -Dversion=$PACKAGE_RECEIPT_VERSION -Dpackaging=aar -DgeneratePom=false -DpomFile=$POM_FILE -DlocalRepositoryPath=$DEPLOYED_TO_SPECIFIED_LOCAL_PATH
    cd -
    rm -rf $WORKING_DIR
            "
            return 0
        fi

        if command -v mvn > /dev/null ; then
            MVN_COMMAND=mvn
        else
            step "install maven"
            run uppm install maven

            unset  JAVA_HOME
            unset MAVEN_HOME

            export JAVA_HOME="$(uppm info jdk17 installed-dir)"
            export PATH="$JAVA_HOME/bin:$PATH"
            export CLASSPATH=".:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar"

            MAVEN_HOME="$(uppm info maven installed-dir)"

            MVN_COMMAND="$MAVEN_HOME/bin/mvn"
        fi

        # https://maven.apache.org/plugins/maven-install-plugin/install-file-mojo.html
        step "deploying the prefab aar to Maven Local Repository"
        run "$MVN_COMMAND" $MVN_OPTIONS install:install-file "-Dfile=$AAR_FILENAME" "-DgroupId=$GROUPID" "-DartifactId=$PACKAGE_NAME" "-Dversion=$PACKAGE_RECEIPT_VERSION" -Dpackaging=aar -DgeneratePom=false "-DpomFile=$POM_FILE" "-DlocalRepositoryPath=$DEPLOYED_TO_SPECIFIED_LOCAL_PATH"

        if [ "$KEEP_WORKING_DIR" = yes ] ; then
            printf '\n'
            note "the working directory '$WORKING_DIR' is not deleted as --keep-working-dir option is given."
        else
            step "delete the working directory"
            run rm -rf "$WORKING_DIR"
        fi

        return 0
    fi

    #########################################################################################

    if [ "$DRYRUN" = yes ] ; then
        printf '%b\n' "
${COLOR_GREEN}Note:${COLOR_OFF}
    ${COLOR_RED}NOT proceed due to --dry-run option is specified.${COLOR_OFF}

    ${COLOR_RED}If you want to continue, please manually execute following commands:${COLOR_OFF}

    cd $WORKING_DIR
    run mvn --settings settings.xml $MVN_OPTIONS gpg:sign-and-deploy-file -Dfile=$AAR_FILENAME -DgeneratePom=false -DpomFile=$POM_FILE -Daether.checksums.algorithms=MD5,SHA-1,SHA-256,SHA-512 -DrepositoryId=$SERVER_ID -Durl=$SERVER_URL
    cd -
    rm -rf $WORKING_DIR
        "
        return 0
    fi

    #########################################################################################

    unset SERVER_ID
    unset SERVER_URL
    unset SERVER_USERNAME
    unset SERVER_PASSWORD
    unset GPG_PASSPHRASE

    step "read config from stdin"
    while read -r LINE
    do
        case $LINE in
            SERVER_ID=*)        SERVER_ID="${LINE#*=}" ;;
            SERVER_URL=*)       SERVER_URL="${LINE#*=}" ;;
            SERVER_USERNAME=*)  SERVER_USERNAME="${LINE#*=}" ;;
            SERVER_PASSWORD=*)  SERVER_PASSWORD="${LINE#*=}" ;;
            GPG_PASSPHRASE=*)   GPG_PASSPHRASE="${LINE#*=}" ;;
        esac
    done

    [ -z "$SERVER_ID" ]       && abort 1 "SERVER_ID must not be enpty."
    [ -z "$SERVER_URL" ]      && abort 1 "SERVER_URL must not be enpty."
    [ -z "$SERVER_USERNAME" ] && abort 1 "SERVER_USERNAME must not be enpty."
    [ -z "$SERVER_PASSWORD" ] && abort 1 "SERVER_PASSWORD must not be enpty."
    [ -z "$GPG_PASSPHRASE"  ] && abort 1 "GPG_PASSPHRASE must not be enpty."

    #########################################################################################

    on_exit_deploy() {
        rm -f settings.xml
    }

    trap on_exit_deploy EXIT

    # https://maven.apache.org/plugins/maven-gpg-plugin/usage.html
    step "generating settings.xml"
    cat > settings.xml <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd">
  <servers>
    <server>
      <id>$SERVER_ID</id>
      <username>$SERVER_USERNAME</username>
      <password>$SERVER_PASSWORD</password>
    </server>

    <server>
      <id>gpg.passphrase</id>
      <passphrase>$GPG_PASSPHRASE</passphrase>
    </server>
  </servers>
</settings>
EOF

    #########################################################################################

    if command -v mvn > /dev/null ; then
        MVN_COMMAND=mvn
    else
        step "install maven"
        run uppm install maven

        unset  JAVA_HOME
        unset MAVEN_HOME

        export JAVA_HOME="$(uppm info jdk17 installed-dir)"
        export PATH="$JAVA_HOME/bin:$PATH"
        export CLASSPATH=".:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar"

        MAVEN_HOME="$(uppm info maven installed-dir)"

        MVN_COMMAND="$MAVEN_HOME/bin/mvn"
    fi

    #########################################################################################

    # There are two maven plugins maven-deploy-plugin and maven-gpg-plugin can be used
    # maven-gpg-plugin is prefered as it is automatically signed with gpg.
    # 
    # https://maven.apache.org/plugins/maven-gpg-plugin/sign-and-deploy-file-mojo.html
    # https://maven.apache.org/plugins/maven-deploy-plugin/deploy-file-mojo.html
    # https://maven.apache.org/resolver/configuration.html

    step "deploying"
    run "$MVN_COMMAND" \
        --settings settings.xml \
        $MVN_OPTIONS \
        gpg:sign-and-deploy-file \
        -Dfile=$AAR_FILENAME \
        -DgeneratePom=false \
        -DpomFile=$POM_FILE \
        -Daether.checksums.algorithms=MD5,SHA-1,SHA-256,SHA-512 \
        -DrepositoryId=$SERVER_ID \
        -Durl=$SERVER_URL

    #########################################################################################

    if [ "$KEEP_WORKING_DIR" = yes ] ; then
        printf '\n'
        note "the working dir '$WORKING_DIR' is not deleted as --keep-working-dir option is given."
    else
        step "delete the working directory"
        run rm -rf "$WORKING_DIR"
    fi
}

# }}}
##############################################################################
# {{{ ndk-pkg cleanup

__cleanup() {
    success "Done."
}

# }}}
##############################################################################
# {{{ ndk-pkg upgrade-self

# __upgrade_self <URL>
  __upgrade_self() {
    [ -z "$1" ] && abort 1 "__upgrade_self <URL> , <URL> must be non-empty."

    unset CURRENT_SCRIPT_REALPATH

    # if file exists and is a symbolic link
    if [ -L "$CURRENT_SCRIPT_FILEPATH" ] ; then
        # https://unix.stackexchange.com/questions/136494/whats-the-difference-between-realpath-and-readlink-f#:~:text=GNU%20coreutils%20introduced%20a%20realpath,in%20common%20with%20GNU%20readlink%20.
        if command -v realpath > /dev/null ; then
            CURRENT_SCRIPT_REALPATH=$(realpath "$CURRENT_SCRIPT_FILEPATH")
        elif command -v readlink > /dev/null && readlink -f xx > /dev/null 2>&1 ; then
            CURRENT_SCRIPT_REALPATH=$(readlink -f "$CURRENT_SCRIPT_FILEPATH")
        else
            CURRENT_SCRIPT_REALPATH=$(realpath "$CURRENT_SCRIPT_FILEPATH")
        fi
    else
        CURRENT_SCRIPT_REALPATH="$CURRENT_SCRIPT_FILEPATH"
    fi

    WORKING_DIR="$NDKPKG_HOME/run/$$"

    run rm -rf     "$WORKING_DIR"
    run install -d "$WORKING_DIR"
    run cd         "$WORKING_DIR"

    wfetch "$1" --output-path="$WORKING_DIR/self"

    __upgrade_self_exit() {
        if [ -w "$CURRENT_SCRIPT_REALPATH" ] ; then
            run      install -m 755 self "$CURRENT_SCRIPT_REALPATH"
        else
            run sudo install -m 755 self "$CURRENT_SCRIPT_REALPATH"
        fi

        run rm -rf "$WORKING_DIR"
    }

    trap __upgrade_self_exit EXIT
}

# }}}
##############################################################################
# {{{ ndk-pkg integrate zsh

# __integrate_zsh_completions <URL> [--output-dir=<DIR>]
  __integrate_zsh_completions() {
    [ -z "$1" ] && abort 1 "__integrate_zsh_completions <URL> [--output-dir=<DIR>] , <URL> must be non-empty."

    ZSH_COMPLETIONS_SCRIPT_URL="$1"

    shift

    unset OUTPUT_DIR

    for arg in "$@"
    do
        case $arg in
            --output-dir=*)
                OUTPUT_DIR="${1#*=}"

                case $OUTPUT_DIR in
                    '')   abort 1 "__integrate_zsh_completions <URL> [--output-dir=<DIR>] , <DIR> must be a non-empty string." ;;
                    \~)   OUTPUT_DIR="$HOME" ;;
                    \~/)  OUTPUT_DIR="$HOME" ;;
                    \~/.) OUTPUT_DIR="$HOME" ;;
                    \~/*) OUTPUT_DIR="$HOME/$(printf '%s\n' "$1" | cut -c3-)" ;;
                esac

                ;;
            *)  abort 1 "__integrate_zsh_completions <URL> [--output-dir=<DIR>] , unrecognized argument: $arg"
        esac
    done

    ZSH_COMPLETIONS_SCRIPT_FILENAME="_$CURRENT_SCRIPT_FILENAME"

    if [ -n "$OUTPUT_DIR" ] ; then
        ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH="$OUTPUT_DIR/$ZSH_COMPLETIONS_SCRIPT_FILENAME"
    elif [ "$(uname)" = Linux ] && command -v termux-info > /dev/null && [ "$HOME" = '/data/data/com.termux/files/home' ] ; then
        ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH="/data/data/com.termux/files/usr/share/zsh/site-functions/$ZSH_COMPLETIONS_SCRIPT_FILENAME"
    else
        ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH="/usr/local/share/zsh/site-functions/$ZSH_COMPLETIONS_SCRIPT_FILENAME"
    fi

    # if file exists and is a symbolic link
    if [ -L "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH" ] ; then
        # https://unix.stackexchange.com/questions/136494/whats-the-difference-between-realpath-and-readlink-f#:~:text=GNU%20coreutils%20introduced%20a%20realpath,in%20common%20with%20GNU%20readlink%20.
        if command -v realpath > /dev/null ; then
            ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH=$(realpath "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH")
        elif command -v readlink > /dev/null && readlink -f xx > /dev/null 2>&1 ; then
            ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH=$(readlink -f "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH")
        else
            ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH=$(realpath "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH")
        fi
    fi

    WORKING_DIR="$NDKPKG_HOME/run/$$"

    run rm -rf     "$WORKING_DIR"
    run install -d "$WORKING_DIR"
    run cd         "$WORKING_DIR"

    wfetch "$ZSH_COMPLETIONS_SCRIPT_URL" --output-path="$WORKING_DIR/$ZSH_COMPLETIONS_SCRIPT_FILENAME"

    if [ -f "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH" ] ; then
        if [ -w "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH" ] ; then
            run      install -m 644 "$ZSH_COMPLETIONS_SCRIPT_FILENAME" "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH"
        else
            run sudo install -m 644 "$ZSH_COMPLETIONS_SCRIPT_FILENAME" "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH"
        fi
    else
        ZSH_COMPLETIONS_SCRIPT_OUT_DIR="$(dirname "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH")"
        if [ ! -d "$ZSH_COMPLETIONS_SCRIPT_OUT_DIR" ] ; then
            run install -d "$ZSH_COMPLETIONS_SCRIPT_OUT_DIR" || run sudo install -d "$ZSH_COMPLETIONS_SCRIPT_OUT_DIR"
        fi
        if [ -w "$ZSH_COMPLETIONS_SCRIPT_OUT_DIR" ] ; then
            run      install -m 644 "$ZSH_COMPLETIONS_SCRIPT_FILENAME" "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH"
        else
            run sudo install -m 644 "$ZSH_COMPLETIONS_SCRIPT_FILENAME" "$ZSH_COMPLETIONS_SCRIPT_OUT_FILEPATH"
        fi
    fi

    run rm -rf "$WORKING_DIR"

    printf '\n'
    note "${COLOR_YELLOW}you need to run command${COLOR_RED} ${COLOR_GREEN}autoload -U compinit && compinit${COLOR_OFF} ${COLOR_YELLOW}in zsh to make it work.${COLOR_OFF}"
}

# }}}
##############################################################################
# {{{ ndk-pkg gen-url-transform-sample

__gen_url_transform_sample() {
    install -d "$NDKPKG_HOME"

    FILEPATH="$NDKPKG_HOME/url-transform.sample"

    cat > "$FILEPATH" <<EOF
#!/bin/sh

# https://ghproxy.com/
case \$1 in
    *githubusercontent.com/*)
        printf 'https://ghproxy.com/%s\n' "\$1"
        ;;
    https://github.com/*)
        printf 'https://ghproxy.com/%s\n' "\$1"
        ;;
    '') printf '%s\n' "\$0 <URL>, <URL> is unspecified." >&2 ;;
    *)  printf '%s\n' "\$1"
esac
EOF

    chmod +x "$FILEPATH"

    success "url-transform sample has been written into $NDKPKG_HOME/url-transform.sample"
    note "You can rename url-transform.sample to url-transform then edit it to meet your needs. To apply this, you should run 'export NDKPKG_URL_TRANSFORM=$NDKPKG_HOME/url-transform' in your terminal."
}

# }}}
##############################################################################
# {{{ ndk-pkg depends

# __show_packages_depended_by_the_given_package <PACKAGE-NAME> [-t <dot|box|svg|png>] [-o <OUTPUT-PATH>]
__show_packages_depended_by_the_given_package() {
    [ -z "$1" ] && abort 1 "_0 depends <PACKAGE-NAME> [-t <OUTPUT-TYPE>] [-o <OUTPUT-PATH>], <PACKAGE-NAME> is unspecified."

    PACKAGE_NAME="$1"

    shift

    ###########################################################################################

    unset OUTPUT_FILETYPE
    unset OUTPUT_FILEPATH

    while [ -n "$1" ]
    do
        case $1 in
            -t) shift
                case $1 in
                    dot|box|svg|png)
                        OUTPUT_FILETYPE="$1" ;;
                    '') abort 1 "$_0 depends <PACKAGE-NAME> [-t <OUTPUT-TYPE>] [-o <OUTPUT-PATH>], -t option is given but <OUTPUT-TYPE> is unspecified." ;;
                    *)  abort 1 "$_0 depends <PACKAGE-NAME> [-t <OUTPUT-TYPE>], unsupported <OUTPUT-TYPE>: $1, <OUTPUT-TYPE> should be one of dot|box|svg|png"
                esac
                ;;
            -o) shift
                if [ -z "$1" ] ; then
                    abort 1 "$_0 depends <PACKAGE-NAME> [-t <OUTPUT-TYPE>] [-o <OUTPUT-PATH>], -o option is given but <OUTPUT-PATH> is unspecified."
                else
                    OUTPUT_FILEPATH="$1"
                fi
                ;;
            *)  abort 1 "$_0 depends <PACKAGE-NAME> [-t <OUTPUT-TYPE>] [-o <OUTPUT-PATH>] [--keep-working-dir], unrecognized option: $1"
        esac
        shift
    done

    ###########################################################################################

    if [ -z "$OUTPUT_FILEPATH" ] ; then
        if [ -z "$OUTPUT_FILETYPE" ] ; then
            OUTPUT_FILETYPE='box'
        fi
    else
        if [ -d "$OUTPUT_FILEPATH" ] ; then
            if [ -z "$OUTPUT_FILETYPE" ] ; then
                OUTPUT_FILETYPE='box'
            fi

            unset OUTPUT_DIR
            OUTPUT_DIR="$(realpath -s "$OUTPUT_FILEPATH")"


            OUTPUT_FILEPATH="$OUTPUT_DIR/$PACKAGE_NAME-dependencies.$OUTPUT_FILETYPE"
        else
            case $OUTPUT_FILEPATH in
                */)
                    if [ -z "$OUTPUT_FILETYPE" ] ; then
                        OUTPUT_FILETYPE='box'
                    fi

                    unset OUTPUT_DIR
                    OUTPUT_DIR="$(realpath -s "$OUTPUT_FILEPATH")"

                    OUTPUT_FILEPATH="$OUTPUT_DIR/$PACKAGE_NAME-dependencies.$OUTPUT_FILETYPE"

                    [ -d "$OUTPUT_DIR" ] || install -d "$OUTPUT_DIR"
                    ;;
                *)
                    OUTPUT_FILEPATH="$(realpath -s "$OUTPUT_FILEPATH")"

                    unset OUTPUT_DIR
                    OUTPUT_DIR="$(dirname "$OUTPUT_FILEPATH")"

                    [ -d "$OUTPUT_DIR" ] || install -d "$OUTPUT_DIR"

                    if [ -z "$OUTPUT_FILETYPE" ] ; then
                        case $OUTPUT_FILEPATH in
                            *.box)
                                OUTPUT_FILETYPE='box'
                                ;;
                            *.dot)
                                OUTPUT_FILETYPE='dot'
                                ;;
                            *.svg)
                                OUTPUT_FILETYPE='svg'
                                ;;
                            *.png)
                                OUTPUT_FILETYPE='png'
                                ;;
                            *)  OUTPUT_FILETYPE='box'
                        esac
                    fi
            esac
        fi
    fi

    ###########################################################################################

    unset DOT_CONTENT

    unset DIRECTED_PATH_LIST

    PACKAGE_NAME_STACK="$PACKAGE_NAME"

    while [ -n "$PACKAGE_NAME_STACK" ]
    do
        case $PACKAGE_NAME_STACK in
            *\;*) PACKAGE_NAME="${PACKAGE_NAME_STACK##*;}" ; PACKAGE_NAME_STACK="${PACKAGE_NAME_STACK%;*}" ;;
            *)    PACKAGE_NAME="${PACKAGE_NAME_STACK}"     ; PACKAGE_NAME_STACK=
        esac

        ################################################################

        __load_formula_of_the_given_package "$PACKAGE_NAME"

        ################################################################

        [ -z "$PACKAGE_DEP_PKG" ] && continue

        ################################################################

        unset X; X="$(printf '"%s" ' $PACKAGE_DEP_PKG)"
        unset Y; Y="$(printf '    "%s" -> { %s}\n' "$PACKAGE_NAME" "$X")"

        if [ -z "$DOT_CONTENT" ] ; then
            DOT_CONTENT="$Y"
        else
            DOT_CONTENT="$(printf '%s\n%s\n' "$DOT_CONTENT" "$Y")"
        fi

        ################################################################

        DIRECTED_PATH_LIST_PART1=
        DIRECTED_PATH_LIST_PART2=

        for DIRECTED_PATH in $DIRECTED_PATH_LIST
        do
            case $DIRECTED_PATH in
                *\>"$PACKAGE_NAME")
                    DIRECTED_PATH_LIST_PART1="$DIRECTED_PATH_LIST_PART1 $DIRECTED_PATH" ;;
                *)  DIRECTED_PATH_LIST_PART2="$DIRECTED_PATH_LIST_PART2 $DIRECTED_PATH" ;;
            esac
        done

        ################################################################

        # it will be recalculated
        DIRECTED_PATH_LIST=

        ################################################################

        for DEPENDENT_PACKAGE_NAME in $PACKAGE_DEP_PKG
        do
            if [ "$DEPENDENT_PACKAGE_NAME" = "$PACKAGE_NAME" ] ; then
                abort 1 "package [$PACKAGE_NAME] depends itself."
            fi

            ############################################################

            if [ -z "$DIRECTED_PATH_LIST_PART1" ] ; then
                DIRECTED_PATH_LIST="$DIRECTED_PATH_LIST $PACKAGE_NAME>$DEPENDENT_PACKAGE_NAME"
            else
                for DIRECTED_PATH in $DIRECTED_PATH_LIST_PART1
                do
                    export IFS='>'

                    # check if have duplicate nodes in every directed path
                    for node in $DIRECTED_PATH
                    do
                        if [ "$node" = "$DEPENDENT_PACKAGE_NAME" ] ; then
                            abort 1 "depends has circle: $DIRECTED_PATH>$DEPENDENT_PACKAGE_NAME"
                        fi
                    done

                    unset IFS

                    DIRECTED_PATH_LIST="$DIRECTED_PATH_LIST $DIRECTED_PATH>$DEPENDENT_PACKAGE_NAME"
                done
            fi

            ############################################################

            if [ -z "$PACKAGE_NAME_STACK" ] ; then
                PACKAGE_NAME_STACK="$DEPENDENT_PACKAGE_NAME"
            else
                PACKAGE_NAME_STACK="$PACKAGE_NAME_STACK;$DEPENDENT_PACKAGE_NAME"
            fi
        done

        DIRECTED_PATH_LIST="$DIRECTED_PATH_LIST $DIRECTED_PATH_LIST_PART2"
    done

    ###########################################################################################

    [ -z "$DOT_CONTENT" ] && return 0

    DOT_CONTENT="digraph G {
$DOT_CONTENT
}"

    ###########################################################################################

    case $OUTPUT_FILETYPE in
        dot)
            if [ -z "$OUTPUT_FILEPATH" ] ; then
                printf '%s\n' "$DOT_CONTENT"
            else
                printf '%s\n' "$DOT_CONTENT" > "$OUTPUT_FILEPATH"
            fi
            ;;
        box)
            if [ -z "$OUTPUT_FILEPATH" ] ; then
                CURL_OPTS=
            else
                CURL_OPTS="-o $OUTPUT_FILEPATH"
            fi

            # https://github.com/ggerganov/dot-to-ascii
            curl $CURL_OPTS \
                -s \
                -G \
                --data-urlencode "boxart=1" \
                --data-urlencode "src=$DOT_CONTENT" \
                "https://dot-to-ascii.ggerganov.com/dot-to-ascii.php"
            ;;
        svg)
            command -v dot > /dev/null || "$CURRENT_SCRIPT_FILEPATH" install graphviz || return 1

            if command -v fc-match > /dev/null ; then
                # Error: fontconfig: Couldn't find font.
                if [ -z "$(fc-match)" ] ; then
                    wfetch 'https://github.com/ryanoasis/nerd-fonts/blob/master/patched-fonts/Meslo/M/Regular/complete/Meslo%20LG%20M%20Regular%20Nerd%20Font%20Complete%20Mono%20Windows%20Compatible.ttf?raw=true' --output-dir="$HOME/.fonts" --output-name='Meslo LG M DZ Regular Nerd Font Complete Mono.ttf' || return 1
                fi
            fi

            TMP_DIR="$NDKPKG_HOME/run/$$"

            rm -rf     "$TMP_DIR"
            install -d "$TMP_DIR"

            DOT_CONTENT_FILEPATH="$TMP_DIR/dependencies.dot"

            printf '%s\n' "$DOT_CONTENT" > "$DOT_CONTENT_FILEPATH"

            if [ -z "$OUTPUT_FILEPATH" ] ; then
                DOT_OPTS="-Tsvg"
            else
                DOT_OPTS="-Tsvg -o $OUTPUT_FILEPATH"
            fi

            run dot "$DOT_OPTS" "$DOT_CONTENT_FILEPATH"
            ;;
        png)
            command -v dot > /dev/null || "$CURRENT_SCRIPT_FILEPATH" install graphviz || return 1

            if command -v fc-match > /dev/null ; then
                # Error: fontconfig: Couldn't find font.
                if [ -z "$(fc-match)" ] ; then
                    wfetch 'https://github.com/ryanoasis/nerd-fonts/blob/master/patched-fonts/Meslo/M/Regular/complete/Meslo%20LG%20M%20Regular%20Nerd%20Font%20Complete%20Mono%20Windows%20Compatible.ttf?raw=true' --output-dir="$HOME/.fonts" --output-name='Meslo LG M DZ Regular Nerd Font Complete Mono.ttf' || return 1
                fi
            fi

            TMP_DIR="$NDKPKG_HOME/run/$$"

            rm -rf     "$TMP_DIR"
            install -d "$TMP_DIR"

            DOT_CONTENT_FILEPATH="$TMP_DIR/dependencies.dot"

            printf '%s\n' "$DOT_CONTENT" > "$DOT_CONTENT_FILEPATH"

            if [ -z "$OUTPUT_FILEPATH" ] ; then
                DOT_OPTS="-Tpng"
            else
                DOT_OPTS="-Tpng -o $OUTPUT_FILEPATH"
            fi

            run dot "$DOT_OPTS" "$DOT_CONTENT_FILEPATH"
            ;;
    esac
}

# }}}
##############################################################################
# {{{ ndk-pkg uninstall

__uninstall_the_given_packages() {
    [ -z "$1" ] && abort 1 "neither package-name nor package-spec is specified."

    unset PACKAGE_SPECS

    for item in "$@"
    do
        PACKAGE_SPECS="$PACKAGE_SPECS $(inspect_package_spec "$item")"
    done

    for PACKAGE_SPEC in $PACKAGE_SPECS
    do
        PACKAGE_INSTALLED_LINK_DIR="$NDKPKG_PACKAGE_INSTALLED_ROOT/$PACKAGE_SPEC"

        [ -e "$PACKAGE_INSTALLED_LINK_DIR" ] || abort 10 "package '$PACKAGE_SPEC' is not installed."
        [ -L "$PACKAGE_INSTALLED_LINK_DIR" ] || abort 11 "$PACKAGE_INSTALLED_LINK_DIR was expected a symlink, but it was not."
        [ -d "$PACKAGE_INSTALLED_LINK_DIR" ] || abort 12 "$PACKAGE_INSTALLED_LINK_DIR was expected a symlink refer to a directory, but it was not."

        PACKAGE_INSTALLED_REAL_DIR="$(readlink -f "$PACKAGE_INSTALLED_LINK_DIR")"

        [ -d "$PACKAGE_INSTALLED_REAL_DIR" ] || abort 13 "directory $PACKAGE_INSTALLED_REAL_DIR was expected exists, but it was not."

        PACKAGE_MANIFEST_FILEPATH="$PACKAGE_INSTALLED_REAL_DIR/.ndk-pkg/MANIFEST.txt"

        [ -f "$PACKAGE_MANIFEST_FILEPATH" ] || abort 13 "$PACKAGE_MANIFEST_FILEPATH file was expected exist, but it was not."

        PACKAGE_RECEIPT_FILEPATH="$PACKAGE_INSTALLED_REAL_DIR/.ndk-pkg/RECEIPT.yml"

        [ -f "$PACKAGE_RECEIPT_FILEPATH" ] || abort 14 "$PACKAGE_RECEIPT_FILEPATH file was expected exist, but it was not."

        run rm -ff "$PACKAGE_INSTALLED_LINK_DIR"
        run rm -rf "$PACKAGE_INSTALLED_REAL_DIR"
    done
}

# }}}
##############################################################################
# {{{ ndk-pkg reinstall

__reinstall_the_given_packages() {
    inspect_install_arguments "$@"

    [ -z "$USER_SPECIFIED_PACKAGE_SPEC_LIST" ] && abort 1 "no package is specified to be reinstalled."

    #########################################################################################

    SESSION_DIR="$NDKPKG_HOME/run/$$"

    rm -rf     "$SESSION_DIR"
    install -d "$SESSION_DIR"

    #########################################################################################

    # 1. check if has circle
    # 2. backup formulas
    # 3. cache variables

    for USER_SPECIFIED_PACKAGE_SPEC in $USER_SPECIFIED_PACKAGE_SPEC_LIST
    do
        PACKAGE_NAME_STACK="${USER_SPECIFIED_PACKAGE_SPEC%%:*}"

        while [ -n "$PACKAGE_NAME_STACK" ]
        do
            case $PACKAGE_NAME_STACK in
                *\;*) PACKAGE_NAME="${PACKAGE_NAME_STACK##*;}" ; PACKAGE_NAME_STACK="${PACKAGE_NAME_STACK%;*}" ;;
                *)    PACKAGE_NAME="${PACKAGE_NAME_STACK}"     ; PACKAGE_NAME_STACK=
            esac

            if [ -f "$SESSION_DIR/$PACKAGE_NAME.yml" ] ; then
                continue
            fi

            __load_formula_of_the_given_package "$PACKAGE_NAME"

            cp "$PACKAGE_FORMULA_FILEPATH" "$SESSION_DIR/$PACKAGE_NAME.yml"

            eval "PACKAGE_DEP_PKG_${PACKAGE_NAME_UPPERCASE_UNDERSCORE}='$PACKAGE_DEP_PKG'"

            for DEPENDENT_PACKAGE_NAME in $PACKAGE_DEP_PKG
            do
                if [ "$DEPENDENT_PACKAGE_NAME" = "$PACKAGE_NAME" ] ; then
                    abort 1 "package '$PACKAGE_NAME' depends itself."
                fi

                if [ -z "$PACKAGE_NAME_STACK" ] ; then
                    PACKAGE_NAME_STACK="$DEPENDENT_PACKAGE_NAME"
                else
                    PACKAGE_NAME_STACK="$PACKAGE_NAME_STACK;$DEPENDENT_PACKAGE_NAME"
                fi
            done
        done
    done

    #########################################################################################

    for USER_SPECIFIED_PACKAGE_SPEC in $USER_SPECIFIED_PACKAGE_SPEC_LIST
    do
        TARGET_ANDROID_SPEC="${USER_SPECIFIED_PACKAGE_SPEC#*:}"

        TARGET_ANDROID_API=
        TARGET_ANDROID_ABI=

        TARGET_ANDROID_API="$(printf '%s\n' "$TARGET_ANDROID_SPEC" | cut -d: -f1 | cut -d- -f2)"
        TARGET_ANDROID_ABI="$(printf '%s\n' "$TARGET_ANDROID_SPEC" | cut -d: -f2)"

        ##################################################################

        TO_BE_INSTALLED_PACKAGE_NAMES=

        PACKAGE_NAME_STACK="${USER_SPECIFIED_PACKAGE_SPEC%%:*}"

        while [ -n "$PACKAGE_NAME_STACK" ]
        do
            case $PACKAGE_NAME_STACK in
                *\;*) PACKAGE_NAME="${PACKAGE_NAME_STACK##*;}" ; PACKAGE_NAME_STACK="${PACKAGE_NAME_STACK%;*}" ;;
                *)    PACKAGE_NAME="${PACKAGE_NAME_STACK}"     ; PACKAGE_NAME_STACK=
            esac

            ##################################################################

            TO_BE_INSTALLED_PACKAGE_NAMES2="$PACKAGE_NAME"

            for item in $TO_BE_INSTALLED_PACKAGE_NAMES
            do
                [ "$item" = "$PACKAGE_NAME" ] && continue
                TO_BE_INSTALLED_PACKAGE_NAMES2="$TO_BE_INSTALLED_PACKAGE_NAMES2 $item"
            done

            TO_BE_INSTALLED_PACKAGE_NAMES="$TO_BE_INSTALLED_PACKAGE_NAMES2"

            ##################################################################

            PACKAGE_NAME_UPPERCASE_UNDERSCORE="$(printf '%s\n' "$PACKAGE_NAME" | tr a-z A-Z | tr '@+-.' '_')"

            for item in $(eval echo \$PACKAGE_DEP_PKG_"${PACKAGE_NAME_UPPERCASE_UNDERSCORE}")
            do
                if [ -z "$PACKAGE_NAME_STACK" ] ; then
                    PACKAGE_NAME_STACK="$item"
                else
                    PACKAGE_NAME_STACK="$PACKAGE_NAME_STACK;$item"
                fi
            done
        done

        ##################################################################

        for PACKAGE_NAME in $TO_BE_INSTALLED_PACKAGE_NAMES
        do
            PACKAGE_SPEC="$PACKAGE_NAME:$TARGET_ANDROID_SPEC"

            if is_package_installed "$PACKAGE_SPEC" ; then
                PACKAGE_INSTALLED_LINK_DIR="$NDKPKG_PACKAGE_INSTALLED_ROOT/$PACKAGE_SPEC"
                PACKAGE_INSTALLED_REAL_DIR="$(readlink -f "$PACKAGE_INSTALLED_LINK_DIR")"

                mv "$PACKAGE_INSTALLED_LINK_DIR" "$SESSION_DIR/"

                (__install_the_given_package "$PACKAGE_SPEC")

                rm -rf "$PACKAGE_INSTALLED_REAL_DIR"
            else
                (__install_the_given_package "$PACKAGE_SPEC")
            fi
        done
    done
}

# }}}
##############################################################################
# {{{ ndk-pkg upgrade

__upgrade_packages() {
    inspect_install_arguments "$@"

    if [ -z "$USER_SPECIFIED_PACKAGE_SPEC_LIST" ] ; then
        USER_SPECIFIED_PACKAGE_SPEC_LIST=$(__list__outdated_packages)
    fi

    #########################################################################################

    SESSION_DIR="$NDKPKG_HOME/run/$$"

    rm -rf     "$SESSION_DIR"
    install -d "$SESSION_DIR"

    #########################################################################################

    # 1. check if has circle
    # 2. backup formulas
    # 3. cache variables

    for USER_SPECIFIED_PACKAGE_SPEC in $USER_SPECIFIED_PACKAGE_SPEC_LIST
    do
        PACKAGE_NAME_STACK="${USER_SPECIFIED_PACKAGE_SPEC%%:*}"

        while [ -n "$PACKAGE_NAME_STACK" ]
        do
            case $PACKAGE_NAME_STACK in
                *\;*) PACKAGE_NAME="${PACKAGE_NAME_STACK##*;}" ; PACKAGE_NAME_STACK="${PACKAGE_NAME_STACK%;*}" ;;
                *)    PACKAGE_NAME="${PACKAGE_NAME_STACK}"     ; PACKAGE_NAME_STACK=
            esac

            if [ -f "$SESSION_DIR/$PACKAGE_NAME.yml" ] ; then
                continue
            fi

            __load_formula_of_the_given_package "$PACKAGE_NAME"

            cp "$PACKAGE_FORMULA_FILEPATH" "$SESSION_DIR/$PACKAGE_NAME.yml"

            eval "PACKAGE_DEP_PKG_${PACKAGE_NAME_UPPERCASE_UNDERSCORE}='$PACKAGE_DEP_PKG'"

            for DEPENDENT_PACKAGE_NAME in $PACKAGE_DEP_PKG
            do
                if [ "$DEPENDENT_PACKAGE_NAME" = "$PACKAGE_NAME" ] ; then
                    abort 1 "package '$PACKAGE_NAME' depends itself."
                fi

                if [ -z "$PACKAGE_NAME_STACK" ] ; then
                    PACKAGE_NAME_STACK="$DEPENDENT_PACKAGE_NAME"
                else
                    PACKAGE_NAME_STACK="$PACKAGE_NAME_STACK;$DEPENDENT_PACKAGE_NAME"
                fi
            done
        done
    done

    #########################################################################################

    for USER_SPECIFIED_PACKAGE_SPEC in $USER_SPECIFIED_PACKAGE_SPEC_LIST
    do
        TARGET_ANDROID_SPEC="${USER_SPECIFIED_PACKAGE_SPEC#*:}"

        TARGET_ANDROID_API=
        TARGET_ANDROID_ABI=

        TARGET_ANDROID_API="$(printf '%s\n' "$TARGET_ANDROID_SPEC" | cut -d: -f1 | cut -d- -f2)"
        TARGET_ANDROID_ABI="$(printf '%s\n' "$TARGET_ANDROID_SPEC" | cut -d: -f2)"

        ##################################################################

        TO_BE_INSTALLED_PACKAGE_NAMES=

        PACKAGE_NAME_STACK="${USER_SPECIFIED_PACKAGE_SPEC%%:*}"

        while [ -n "$PACKAGE_NAME_STACK" ]
        do
            case $PACKAGE_NAME_STACK in
                *\;*) PACKAGE_NAME="${PACKAGE_NAME_STACK##*;}" ; PACKAGE_NAME_STACK="${PACKAGE_NAME_STACK%;*}" ;;
                *)    PACKAGE_NAME="${PACKAGE_NAME_STACK}"     ; PACKAGE_NAME_STACK=
            esac

            ##################################################################

            TO_BE_INSTALLED_PACKAGE_NAMES2="$PACKAGE_NAME"

            for item in $TO_BE_INSTALLED_PACKAGE_NAMES
            do
                [ "$item" = "$PACKAGE_NAME" ] && continue
                TO_BE_INSTALLED_PACKAGE_NAMES2="$TO_BE_INSTALLED_PACKAGE_NAMES2 $item"
            done

            TO_BE_INSTALLED_PACKAGE_NAMES="$TO_BE_INSTALLED_PACKAGE_NAMES2"

            ##################################################################

            PACKAGE_NAME_UPPERCASE_UNDERSCORE="$(printf '%s\n' "$PACKAGE_NAME" | tr a-z A-Z | tr '@+-.' '_')"

            for item in $(eval echo \$PACKAGE_DEP_PKG_"${PACKAGE_NAME_UPPERCASE_UNDERSCORE}")
            do
                if [ -z "$PACKAGE_NAME_STACK" ] ; then
                    PACKAGE_NAME_STACK="$item"
                else
                    PACKAGE_NAME_STACK="$PACKAGE_NAME_STACK;$item"
                fi
            done
        done

        ##################################################################

        for PACKAGE_NAME in $TO_BE_INSTALLED_PACKAGE_NAMES
        do
            PACKAGE_SPEC="$PACKAGE_NAME:$TARGET_ANDROID_SPEC"

            if is_package__outdated "$PACKAGE_SPEC" ; then
                PACKAGE_INSTALLED_LINK_DIR="$NDKPKG_PACKAGE_INSTALLED_ROOT/$PACKAGE_SPEC"
                PACKAGE_INSTALLED_REAL_DIR="$(readlink -f "$PACKAGE_INSTALLED_LINK_DIR")"

                mv "$PACKAGE_INSTALLED_LINK_DIR" "$SESSION_DIR/"

                (__install_the_given_package "$PACKAGE_SPEC")

                rm -rf "$PACKAGE_INSTALLED_REAL_DIR"
            else
                note "package '$PACKAGE_SPEC' is up-to-date."
            fi
        done
    done
}

# peel_installed_root_dir_for_the_given_package <PACKAGE-NAME|PACKAGE-SPEC>
  peel_installed_root_dir_for_the_given_package() {
    PACKAGE_SPEC=
    PACKAGE_SPEC="$(inspect_package_spec "$1")"

    if is_package_installed "$PACKAGE_SPEC" ; then
        PACKAGE_INSTALLED_LINK_DIR="$NDKPKG_PACKAGE_INSTALLED_ROOT/$PACKAGE_SPEC"
        PACKAGE_INSTALLED_REAL_DIR="$(readlink -f "$PACKAGE_INSTALLED_LINK_DIR")"
        printf '%s\n' "$PACKAGE_INSTALLED_REAL_DIR"
    else
        abort 1 "package '$PACKAGE_SPEC' is not installed."
    fi
}

# }}}
##############################################################################
# {{{ ndk-pkg install

# inspect_package_spec <PACKAGE-NAME|PACKAGE-SPEC>
  inspect_package_spec() {
    case $1 in
        '') abort 1 "neither package-name nor package-spec is specified."
            ;;
        *:android-[1-9][0-9]:*:*)
            abort 1 "invalid package spec: $1"
            ;;
        *:android-[1-9][0-9]:*)
            PACKAGE_NAME="${1%%:*}"

            if [ -z "$PACKAGE_NAME" ] ; then
                abort 1 "invalid package spec: $1\n    package name is unspecifed."
            elif printf '%s\n' "$PACKAGE_NAME" | grep -q -E '^[A-Za-z0-9+-_.@]{1,50}$' ; then
                :
            else
                abort 1 "invalid package spec: $1\n    package name must match the regular expression pattern: ^[A-Za-z0-9+-_.@]{1,50}$"
            fi

            TARGET_ANDROID_API="$(printf '%s\n' "$1" | cut -d: -f2 | cut -d- -f2)"
            TARGET_ANDROID_ABI="$(printf '%s\n' "$1" | cut -d: -f3)"

            case $TARGET_ANDROID_ABI in
                armeabi-v7a|arm64-v8a|x86|x86_64) ;;
                *)  abort 1 "invalid package spec: $1\n    unrecognized android abi: $TARGET_ANDROID_ABI"
            esac

            PACKAGE_SPEC="$1"
            ;;
        *:*)abort 1 "invalid package spec: $1"
            ;;
        *)  if printf '%s\n' "$1" | grep -q -E '^[A-Za-z0-9+-_.@]{1,50}$' ; then
                case $NDKPKG_DEFAULT_TARGET_ANDROID_SPEC in
                    '') NDKPKG_DEFAULT_TARGET_ANDROID_SPEC='android-21:arm64-v8a'
                        ;;
                    android-[1-9][0-9]:armeabi-v7a)
                        ;;
                    android-[1-9][0-9]:arm64-v8a)
                        ;;
                    android-[1-9][0-9]:x86)
                        ;;
                    android-[1-9][0-9]:x86_64)
                        ;;
                    *) abort 1 "you have set NDKPKG_DEFAULT_TARGET_ANDROID_SPEC=$NDKPKG_DEFAULT_TARGET_ANDROID_SPEC , but it is an invalid android spec."
                esac

                PACKAGE_SPEC="$1:$NDKPKG_DEFAULT_TARGET_ANDROID_SPEC"
            else
                abort 1 "invalid package name: $1"
            fi
    esac

    printf '%s\n' "$PACKAGE_SPEC"
}

inspect_install_arguments() {
    # https://stackoverflow.com/questions/18476490/what-is-purpose-of-target-arch-variable-in-makefiles
    unset TARGET_ARCH

    unset USER_SPECIFIED_PACKAGE_LIST

    unset USER_SPECIFIED_ANDROID_NDK_HOME

    DRYRUN=no

    CCACHE_ENABLED=no

    LOG_LEVEL_QUIET=0
    LOG_LEVEL_NORMAL=1
    LOG_LEVEL_VERBOSE=2
    LOG_LEVEL_VERY_VERBOSE=3

    LOG_LEVEL=$LOG_LEVEL_NORMAL

    BUILD_NJOBS=$NATIVE_OS_NCPU

    BUILD_TYPE=release

    LINK_TYPE=static-prefered

    KEEP_WORKING_DIR=no

    EXPORT_COMPILE_COMMANDS_JSON=no

    while [ -n "$1" ]
    do
        case $1 in
            -vv)
                LOG_LEVEL="$LOG_LEVEL_VERY_VERBOSE"
                ;;
            -v)
                LOG_LEVEL="$LOG_LEVEL_VERBOSE"
                ;;
            -q)
                LOG_LEVEL="$LOG_LEVEL_QUIET"
                ;;
            --disable-ccache)
                CCACHE_ENABLED=no
                ;;
            --dry-run)
                DRYRUN=yes
                ;;
            --keep-working-dir)
                KEEP_WORKING_DIR=yes
                ;;
            --export-compile-commands-json)
                EXPORT_COMPILE_COMMANDS_JSON=yes
                ;;
            --build-type=*)
                BUILD_TYPE="${1#*=}"
                case $BUILD_TYPE in
                    debug|release) ;;
                    '') abort 1 "--build-type=<VALUE>, VALUE must be non-empty." ;;
                    *)  abort 1 "--build-type=<VALUE>, VALUE must be one of debug|release"
                esac
                ;;
            --link-type=*)
                LINK_TYPE="${1#*=}"
                case $LINK_TYPE in
                    static-only|shared-only|static-prefered|shared-prefered) ;;
                    '') abort 1 "--link-type=<VALUE>, VALUE must be non-empty." ;;
                    *)  abort 1 "--link-type=<VALUE>, VALUE must be one of static-only|shared-only|static-prefered|shared-prefered"
                esac
                ;;
            --jobs=*)
                BUILD_NJOBS="${1#*=}"
                is_integer "$BUILD_NJOBS" || abort 1 "--jobs=INTEGER argument's value must be an integer."
                ;;
            --ndk-home=*)
                USER_SPECIFIED_ANDROID_NDK_HOME="${1#*=}"
                ;;
            -*) abort 1 "unrecognized option: $1"
                ;;
            *)  USER_SPECIFIED_PACKAGE_LIST="$USER_SPECIFIED_PACKAGE_LIST $1"
        esac
        shift
    done

    #########################################################################################

    unset USER_SPECIFIED_PACKAGE_SPEC_LIST

    for PACKAGE in $USER_SPECIFIED_PACKAGE_LIST
    do
        case $PACKAGE in
            *:android-[1-9][0-9]:*:*)
                abort 1 "invalid package spec: $PACKAGE"
                ;;
            *:android-[1-9][0-9]:*)
                PACKAGE_NAME="${PACKAGE%%:*}"

                if [ -z "$PACKAGE_NAME" ] ; then
                    abort 1 "invalid package spec: $PACKAGE\n    package name is unspecifed."
                elif printf '%s\n' "$PACKAGE_NAME" | grep -q -E '^[A-Za-z0-9+-_.@]{1,50}$' ; then
                    :
                else
                    abort 1 "invalid package spec: $1\n    package name must match the regular expression pattern: ^[A-Za-z0-9+-_.@]{1,50}$"
                fi

                TARGET_ANDROID_API="$( printf '%s\n' "$PACKAGE" | cut -d: -f2 | cut -d- -f2)"
                TARGET_ANDROID_ABIS="$(printf '%s\n' "$PACKAGE" | cut -d: -f3 | tr ',' ' ')"

                for TARGET_ANDROID_ABI in $TARGET_ANDROID_ABIS
                do
                    case $TARGET_ANDROID_ABI in
                        armeabi-v7a|arm64-v8a|x86|x86_64)
                            USER_SPECIFIED_PACKAGE_SPEC_LIST="$USER_SPECIFIED_PACKAGE_SPEC_LIST $PACKAGE_SPEC $PACKAGE_NAME:android-$TARGET_ANDROID_API:$TARGET_ANDROID_ABI"
                            ;;
                        *)  abort 1 "invalid package spec: $PACKAGE\n    unrecognized android abi: $TARGET_ANDROID_ABI"
                    esac
                done
                ;;
            *:*)
                abort 1 "invalid package spec: $PACKAGE"
                ;;
            *)  if printf '%s\n' "$PACKAGE" | grep -q -E '^[A-Za-z0-9+-_.@]{1,50}$' ; then
                    case $NDKPKG_DEFAULT_TARGET_ANDROID_SPEC in
                        '') NDKPKG_DEFAULT_TARGET_ANDROID_SPEC='android-21:arm64-v8a'
                            ;;
                        android-[1-9][0-9]:armeabi-v7a)
                            ;;
                        android-[1-9][0-9]:arm64-v8a)
                            ;;
                        android-[1-9][0-9]:x86)
                            ;;
                        android-[1-9][0-9]:x86_64)
                            ;;
                        *) abort 1 "you have set NDKPKG_DEFAULT_TARGET_ANDROID_SPEC=$NDKPKG_DEFAULT_TARGET_ANDROID_SPEC , but it is an invalid android spec."
                    esac

                    USER_SPECIFIED_PACKAGE_SPEC_LIST="$USER_SPECIFIED_PACKAGE_SPEC_LIST $PACKAGE:$NDKPKG_DEFAULT_TARGET_ANDROID_SPEC"
                else
                    abort 1 "invalid package name: $PACKAGE"
                fi
        esac
    done

    USER_SPECIFIED_PACKAGE_SPEC_LIST=${USER_SPECIFIED_PACKAGE_SPEC_LIST#' '}

    #########################################################################################

    NDKINFO=

    if [ -z "$USER_SPECIFIED_ANDROID_NDK_HOME" ] ; then
        NDKINFO="$(ndkinfo || true)"
    else
        NDKINFO="$(ndkinfo "$USER_SPECIFIED_ANDROID_NDK_HOME")"
    fi

    if [ -z "$NDKINFO" ] ; then
        # https://github.com/microsoft/WSL/issues/8681
        # https://github.com/microsoft/WSL/issues/4071

        if [ "$NATIVE_OS_KIND" = linux ] && grep -q -i Microsoft /proc/version ; then
            UPPM_PACKAGE_NAME_NDK='android-ndk-r23c'
        else
            UPPM_PACKAGE_NAME_NDK='android-ndk-r25c'
        fi

        "$UPPM" is-installed "$UPPM_PACKAGE_NAME_NDK" || {
            warn "Android NDK not found, it will be installed via uppm."
            "$UPPM" install  "$UPPM_PACKAGE_NAME_NDK"
        }

        ANDROID_NDK_HOME="$("$UPPM" info "$UPPM_PACKAGE_NAME_NDK" installed-dir)"

        NDKINFO="$(ndkinfo "$ANDROID_NDK_HOME")"
    fi

    eval "$NDKINFO"

    export ANDROID_NDK_HOME
    export ANDROID_NDK_ROOT

    #########################################################################################

    if [ "$LOG_LEVEL" -eq "$LOG_LEVEL_QUIET" ] ; then
        exec 1>/dev/null
        exec 2>&1
    fi
}

__install_the_given_packages() {
    inspect_install_arguments "$@"

    [ -z "$USER_SPECIFIED_PACKAGE_SPEC_LIST" ] && abort 1 "$_0 install <PACKAGE-SPEC|PACKAGE-NAME>..., <|PACKAGE-SPEC|PACKAGE-NAME> is unspecified."

    #########################################################################################

    SESSION_DIR="$NDKPKG_HOME/run/$$"

    rm -rf     "$SESSION_DIR"
    install -d "$SESSION_DIR"

    #########################################################################################

    # 1. check if has circle
    # 2. backup formulas
    # 3. cache variables

    for USER_SPECIFIED_PACKAGE_SPEC in $USER_SPECIFIED_PACKAGE_SPEC_LIST
    do
        PACKAGE_NAME_STACK="${USER_SPECIFIED_PACKAGE_SPEC%%:*}"

        while [ -n "$PACKAGE_NAME_STACK" ]
        do
            case $PACKAGE_NAME_STACK in
                *\;*) PACKAGE_NAME="${PACKAGE_NAME_STACK##*;}" ; PACKAGE_NAME_STACK="${PACKAGE_NAME_STACK%;*}" ;;
                *)    PACKAGE_NAME="${PACKAGE_NAME_STACK}"     ; PACKAGE_NAME_STACK=
            esac

            if [ -f "$SESSION_DIR/$PACKAGE_NAME.yml" ] ; then
                continue
            fi

            __load_formula_of_the_given_package "$PACKAGE_NAME"

            cp "$PACKAGE_FORMULA_FILEPATH" "$SESSION_DIR/$PACKAGE_NAME.yml"

            eval "PACKAGE_DEP_PKG_${PACKAGE_NAME_UPPERCASE_UNDERSCORE}='$PACKAGE_DEP_PKG'"

            for DEPENDENT_PACKAGE_NAME in $PACKAGE_DEP_PKG
            do
                if [ "$DEPENDENT_PACKAGE_NAME" = "$PACKAGE_NAME" ] ; then
                    abort 1 "package '$PACKAGE_NAME' depends itself."
                fi

                if [ -z "$PACKAGE_NAME_STACK" ] ; then
                    PACKAGE_NAME_STACK="$DEPENDENT_PACKAGE_NAME"
                else
                    PACKAGE_NAME_STACK="$PACKAGE_NAME_STACK;$DEPENDENT_PACKAGE_NAME"
                fi
            done
        done
    done

    #########################################################################################

    for USER_SPECIFIED_PACKAGE_SPEC in $USER_SPECIFIED_PACKAGE_SPEC_LIST
    do
        TARGET_ANDROID_SPEC="${USER_SPECIFIED_PACKAGE_SPEC#*:}"

        TARGET_ANDROID_API=
        TARGET_ANDROID_ABI=

        TARGET_ANDROID_API="$(printf '%s\n' "$TARGET_ANDROID_SPEC" | cut -d: -f1 | cut -d- -f2)"
        TARGET_ANDROID_ABI="$(printf '%s\n' "$TARGET_ANDROID_SPEC" | cut -d: -f2)"

        ##################################################################

        TO_BE_INSTALLED_PACKAGE_NAMES=

        PACKAGE_NAME_STACK="${USER_SPECIFIED_PACKAGE_SPEC%%:*}"

        while [ -n "$PACKAGE_NAME_STACK" ]
        do
            case $PACKAGE_NAME_STACK in
                *\;*) PACKAGE_NAME="${PACKAGE_NAME_STACK##*;}" ; PACKAGE_NAME_STACK="${PACKAGE_NAME_STACK%;*}" ;;
                *)    PACKAGE_NAME="${PACKAGE_NAME_STACK}"     ; PACKAGE_NAME_STACK=
            esac

            ##################################################################

            TO_BE_INSTALLED_PACKAGE_NAMES2="$PACKAGE_NAME"

            for item in $TO_BE_INSTALLED_PACKAGE_NAMES
            do
                [ "$item" = "$PACKAGE_NAME" ] && continue
                TO_BE_INSTALLED_PACKAGE_NAMES2="$TO_BE_INSTALLED_PACKAGE_NAMES2 $item"
            done

            TO_BE_INSTALLED_PACKAGE_NAMES="$TO_BE_INSTALLED_PACKAGE_NAMES2"

            ##################################################################

            PACKAGE_NAME_UPPERCASE_UNDERSCORE="$(printf '%s\n' "$PACKAGE_NAME" | tr a-z A-Z | tr '@+-.' '_')"

            for item in $(eval echo \$PACKAGE_DEP_PKG_"${PACKAGE_NAME_UPPERCASE_UNDERSCORE}")
            do
                if [ -z "$PACKAGE_NAME_STACK" ] ; then
                    PACKAGE_NAME_STACK="$item"
                else
                    PACKAGE_NAME_STACK="$PACKAGE_NAME_STACK;$item"
                fi
            done
        done

        ##################################################################

        for PACKAGE_NAME in $TO_BE_INSTALLED_PACKAGE_NAMES
        do
            PACKAGE_SPEC="$PACKAGE_NAME:$TARGET_ANDROID_SPEC"

            if is_package_installed "$PACKAGE_SPEC" ; then
                if [ "$LOG_LEVEL" -gt 0 ] ; then
                    printf "$COLOR_GREEN%-10s$COLOR_OFF already have been installed.\n" "$PACKAGE_SPEC"
                fi
            else
                (__install_the_given_package "$PACKAGE_SPEC")
            fi
        done
    done
}

# __install_native_package_to_core_dir <PACKAGE-NAME>
  __install_native_package_to_core_dir() {
    case $1 in
        '') abort 1 "__install_native_package_to_core_dir_via_cmake <PACKAGE-NAME> , <PACKAGE-NAME> is unspecified."
            ;;
        expat)
            SRC_URL='https://github.com/libexpat/libexpat/releases/download/R_2_5_0/expat-2.5.0.tar.xz'
            SRC_SHA='ef2420f0232c087801abf705e89ae65f6257df6b7931d37846a193ef2e8cdcbe'

            BUILD_SYSTEM_NAME='cmake'
            BUILD_CONFIG_ARGS='-DEXPAT_BUILD_DOCS=OFF -DEXPAT_BUILD_TESTS=OFF -DEXPAT_BUILD_FUZZERS=OFF -DEXPAT_BUILD_EXAMPLES=OFF -DEXPAT_BUILD_TOOLS=OFF'
            ;;
        zlib)
            SRC_URL='https://zlib.net/zlib-1.2.13.tar.gz'
            SRC_SHA='b3a24de97a8fdbc835b9833169501030b8977031bcb54b3b3ac13740f846ab30'

            BUILD_SYSTEM_NAME='cmake'
            BUILD_CONFIG_ARGS=
            ;;
        libbz2)
            SRC_URL='https://github.com/leleliu008/bzip2/archive/refs/tags/1.0.8.tar.gz'
            SRC_SHA='0100da0b55f552134d732acdd0325e84a0ef731a305c15f6a2ea24308de09759'

            BUILD_SYSTEM_NAME='cmake'
            BUILD_CONFIG_ARGS='-DINSTALL_EXECUTABLES=OFF -DINSTALL_LIBRARIES=ON'
            ;;
        perl)
            SRC_URL='https://cpan.metacpan.org/authors/id/R/RJ/RJBS/perl-5.36.0.tar.xz'
            SRC_SHA='0f386dccbee8e26286404b2cca144e1005be65477979beb9b1ba272d4819bcf0'

            BUILD_SYSTEM_NAME='configure'
            BUILD_CONFIG_ARGS=
            ;;
        openssl)
            SRC_URL='https://www.openssl.org/source/openssl-3.0.5.tar.gz'
            SRC_SHA='aa7d8d9bef71ad6525c55ba11e5f4397889ce49c2c9349dcea6d3e4f0b024a7a'

            BUILD_SYSTEM_NAME='configure'
            BUILD_CONFIG_ARGS=
            ;;
        texinfo)
            SRC_URL='https://ftp.gnu.org/gnu/texinfo/texinfo-7.0.tar.xz'
            SRC_SHA='20744b82531ce7a04d8cee34b07143ad59777612c3695d5855f29fba40fbe3e0'

            BUILD_SYSTEM_NAME='configure'
            BUILD_CONFIG_ARGS='--with-included-regex --enable-threads=posix'
            ;;
        help2man)
            SRC_URL='https://ftp.gnu.org/gnu/help2man/help2man-1.49.3.tar.xz'
            SRC_SHA='4d7e4fdef2eca6afe07a2682151cea78781e0a4e8f9622142d9f70c083a2fd4f'

            BUILD_SYSTEM_NAME='configure'
            BUILD_CONFIG_ARGS=
            ;;
        intltool)
            SRC_URL='https://launchpad.net/intltool/trunk/0.51.0/+download/intltool-0.51.0.tar.gz'
            SRC_SHA='67c74d94196b153b774ab9f89b2fa6c6ba79352407037c8c14d5aeb334e959cd'

            BUILD_SYSTEM_NAME='configure'
            BUILD_CONFIG_ARGS=
            ;;
        libtool)
            SRC_URL='https://ftp.gnu.org/gnu/libtool/libtool-2.4.7.tar.xz'
            SRC_SHA='4f7f217f057ce655ff22559ad221a0fd8ef84ad1fc5fcb6990cecc333aa1635d'

            BUILD_SYSTEM_NAME='configure'
            BUILD_CONFIG_ARGS='--enable-ltdl-install'
            ;;
        autoconf)
            SRC_URL='https://ftp.gnu.org/gnu/autoconf/autoconf-2.71.tar.gz'
            SRC_SHA='431075ad0bf529ef13cb41e9042c542381103e80015686222b8a9d4abef42a1c'

            BUILD_SYSTEM_NAME='configure'
            BUILD_CONFIG_ARGS=
            ;;
        automake)
            SRC_URL='https://ftp.gnu.org/gnu/automake/automake-1.16.5.tar.xz'
            SRC_SHA='f01d58cd6d9d77fbdca9eb4bbd5ead1988228fdb73d6f7a201f5f8d6b118b469'

            BUILD_SYSTEM_NAME='configure'
            BUILD_CONFIG_ARGS=
            ;;
        liblzma)
            SRC_URL='https://github.com/xz-mirror/xz/releases/download/v5.4.0/xz-5.4.0.tar.xz'
            SRC_SHA='5f260e3b43f75cf43ca43d107dd18209f7d516782956a74ddd53288e02a83a31'

            BUILD_SYSTEM_NAME='configure'
            BUILD_CONFIG_ARGS='--disable-dependency-tracking --enable-static --disable-shared --disable-nls --enable-largefile --disable-xz --disable-xzdec --disable-lzmadec --disable-lzmainfo --disable-lzma-links --disable-scripts --disable-doc'
            ;;
        gdbm)
            SRC_URL='https://ftp.gnu.org/gnu/gdbm/gdbm-1.23.tar.gz'
            SRC_SHA='74b1081d21fff13ae4bd7c16e5d6e504a4c26f7cde1dca0d963a484174bbcacd'

            BUILD_SYSTEM_NAME='configure'
            BUILD_CONFIG_ARGS='--disable-dependency-tracking --enable-static --disable-shared --disable-nls --enable-largefile --enable-libgdbm-compat --without-readline'
            ;;
        sqlite3)
            SRC_URL='https://www.sqlite.org/2023/sqlite-autoconf-3410100.tar.gz'
            SRC_SHA='4dadfbeab9f8e16c695d4fbbc51c16b2f77fb97ff4c1c3d139919dfc038c9e33'

            BUILD_SYSTEM_NAME='configure'
            BUILD_CONFIG_ARGS='--disable-dependency-tracking --enable-static --disable-shared --enable-largefile --disable-editline --disable-readline'
            ;;
        libffi)
            SRC_URL='https://github.com/libffi/libffi/releases/download/v3.4.4/libffi-3.4.4.tar.gz'
            SRC_SHA='d66c56ad259a82cf2a9dfc408b32bf5da52371500b84745f7fb8b645712df676'

            BUILD_SYSTEM_NAME='configure'
            BUILD_CONFIG_ARGS='--disable-dependency-tracking --enable-static --disable-shared --disable-docs --disable-symvers'
            ;;
        libyaml)
            SRC_URL='https://github.com/yaml/libyaml/releases/download/0.2.5/yaml-0.2.5.tar.gz'
            SRC_SHA='c642ae9b75fee120b2d96c712538bd2cf283228d2337df2cf2988e3c02678ef4'

            BUILD_SYSTEM_NAME='configure'
            BUILD_CONFIG_ARGS='--disable-dependency-tracking --enable-static --disable-shared --enable-largefile'
            ;;
        ruby)
            SRC_URL='https://cache.ruby-lang.org/pub/ruby/3.2/ruby-3.2.2.tar.gz'
            SRC_SHA='96c57558871a6748de5bc9f274e93f4b5aad06cd8f37befa0e8d94e7b8a423bc'

            BUILD_SYSTEM_NAME='configure'
            BUILD_CONFIG_ARGS='--disable-dependency-tracking --enable-static --enable-shared --disable-docs'
            ;;
        python3)
            SRC_URL='https://www.python.org/ftp/python/3.11.2/Python-3.11.2.tgz'
            SRC_SHA='2411c74bda5bbcfcddaf4531f66d1adc73f247f529aee981b029513aefdbf849'

            BUILD_SYSTEM_NAME='configure'
            BUILD_CONFIG_ARGS="--with-system-expat --with-system-ffi --with-openssl=$NDKPKG_CORE_DIR --with-ensurepip=yes --with-lto --enable-ipv6 --enable-shared --enable-largefile --disable-option-checking --disable-nls --disable-debug --disable-loadable-sqlite-extensions --disable-profiling"
            ;;
        perl-XML-Parser)
            SRC_URL='https://cpan.metacpan.org/authors/id/T/TO/TODDR/XML-Parser-2.46.tar.gz'
            SRC_SHA='d331332491c51cccfb4cb94ffc44f9cd73378e618498d4a37df9e043661c515d'

            BUILD_SYSTEM_NAME='configure'
            BUILD_CONFIG_ARGS=
            ;;
        *)  abort 1 "unknown native package name: $1"
    esac

    #########################################################################################

    step "install native package $1 to $NDKPKG_CORE_DIR"

    RECEIPT_FILEPATH="$NDKPKG_CORE_DIR/.$1"

    if [ -f "$RECEIPT_FILEPATH" ] && [ "$(cat "$RECEIPT_FILEPATH")" = "$SRC_SHA" ] ; then
        note "native package '$1' already has been installed, skipped."
        return 0
    fi

    SRC_FILETYPE="$(filetype_from_url "$SRC_URL")"
    SRC_FILENAME="$SRC_SHA$SRC_FILETYPE"

    wfetch "$SRC_URL" --sha256="$SRC_SHA" --output-path="$NDKPKG_DOWNLOADS_DIR/$SRC_FILENAME"

    SRC_DIR="$PACKAGE_WORKING_DIR/$TIMESTAMP_UNIX/$1"

    run install -d "$SRC_DIR"
    run cd         "$SRC_DIR"

    run tar vxf "$FETCH_OUTPUT_PATH" --strip-components=1 --no-same-owner

    #########################################################################################

    if   [ "$1" = 'zlib' ] ; then
        sed_in_place 's|/share/pkgconfig|/lib/pkgconfig|' CMakeLists.txt
    elif [ "$1" = 'python3' ] ; then
        unset PYTHONHOME
        unset PYTHONPATH

        export ZLIB_CFLAGS="-I$NDKPKG_CORE_DIR/include"
        export ZLIB_LIBS="-L$NDKPKG_CORE_DIR/lib -lz"

        export BZIP2_CFLAGS="-I$NDKPKG_CORE_DIR/include"
        export BZIP2_LIBS="-L$NDKPKG_CORE_DIR/lib -lbz2"

        export LIBLZMA_CFLAGS="-I$NDKPKG_CORE_DIR/include"
        export LIBLZMA_LIBS="-L$NDKPKG_CORE_DIR/lib -llzma"

        export LIBSQLITE3_CFLAGS="-I$NDKPKG_CORE_DIR/include"
        export LIBSQLITE3_LIBS="-L$NDKPKG_CORE_DIR/lib -lsqlite3"

        export GDBM_CFLAGS="-I$NDKPKG_CORE_DIR/include"
        export GDBM_LIBS="-L$NDKPKG_CORE_DIR/lib -lgdbm -lgdbm_compat"
    fi

    #########################################################################################

    case $BUILD_SYSTEM_NAME in
        cmake)
            CMAKE="$(command -v cmake)" || abort 1 "command not found: cmake"

            run "$CMAKE" -S . -B build.d -DCMAKE_INSTALL_PREFIX=$NDKPKG_CORE_DIR -DCMAKE_INSTALL_LIBDIR=lib -DBUILD_SHARED_LIBS=ON "$BUILD_CONFIG_ARGS"
            run "$CMAKE" --build   build.d -- -j$BUILD_NJOBS
            run "$CMAKE" --install build.d
            ;;
        configure)
            case $1 in
                openssl)
                    run ./config no-tests no-ssl3 no-ssl3-method no-zlib --prefix=$NDKPKG_CORE_DIR --libdir=$NDKPKG_CORE_DIR/lib --openssldir=$NDKPKG_CORE_DIR/etc/ssl
                    ;;
                perl)
                    run ./Configure "-Dprefix=$NDKPKG_CORE_DIR" "-Dman1dir=$NDKPKG_CORE_DIR/share/man/man1" "-Dman3dir=$NDKPKG_CORE_DIR/share/man/man3" -des -Dmake=gmake -Duselargefiles -Duseshrplib -Dusethreads -Dusenm=false -Dusedl=true
                    ;;
                perl-XML-Parser)
                    run perl Makefile.PL EXPATLIBPATH="$NDKPKG_CORE_DIR/lib" EXPATINCPATH="$NDKPKG_CORE_DIR/include"
                    ;;
                *)  run ./configure "--prefix=$NDKPKG_CORE_DIR" "$BUILD_CONFIG_ARGS"
            esac

            GMAKE="$(command -v gmake)" || abort 1 "command not found: gmake"

            run "$GMAKE" "--jobs=$NATIVE_OS_NCPU"
            run "$GMAKE" install
            ;;
    esac

    printf '%s\n' "$SRC_SHA" > "$RECEIPT_FILEPATH"
}


__install_the_given_package_onexit() {
    if [ "$DRYRUN" != yes ] ; then
        is_package_installed "$PACKAGE_SPEC" || abort 1 "package installation failure: $PACKAGE_SPEC"
    fi
}

# Note: this function must run in a subshell
__install_the_given_package() {
    printf '%b\n' "${COLOR_PURPLE}=============== Installing ${COLOR_OFF}${COLOR_GREEN}${1}${COLOR_OFF}${COLOR_PURPLE} ===============${COLOR_OFF}"

    case $TARGET_ANDROID_ABI in
        armeabi-v7a) TARGET_ANDROID_ARCH='armv7a'  ;;
        arm64-v8a)   TARGET_ANDROID_ARCH='aarch64' ;;
        x86)         TARGET_ANDROID_ARCH='i686'    ;;
        x86_64)      TARGET_ANDROID_ARCH='x86_64'  ;;
    esac

    case $TARGET_ANDROID_ARCH in
        i686|armv7a)
            TARGET_ANDROID_NBIT=32
            ANDROID_DYNAMIC_LINKER_PATH='/system/bin/linker'
            ;;
        x86_64|aarch64)
            TARGET_ANDROID_NBIT=64
            ANDROID_DYNAMIC_LINKER_PATH='/system/bin/linker64'
            ;;
    esac

    #########################################################################################

    trap  __install_the_given_package_onexit EXIT

    # Error: The current work directory doesn't exist, cannot proceed.
    # beacuse previous package's work directory is deleted.
    cd "$HOME"

    #########################################################################################

    PACKAGE_FORMULA_FILEPATH="$SESSION_DIR/$PACKAGE_NAME.yml"

    step "view formula"
    run yq "$PACKAGE_FORMULA_FILEPATH"
   
    step "load formula"
    __load_formula_of_the_given_package "$PACKAGE_NAME" "$PACKAGE_FORMULA_FILEPATH"

    #########################################################################################

    if [ "$PACKAGE_BUILD_IN_PARALLEL" = no ] ; then
        BUILD_NJOBS=1
    fi

    if [ -z "$PACKAGE_API_MIN" ] ; then
        PACKAGE_API_MIN="$ANDROID_NDK_SUPPORTED_MIN_SDK_API_LEVEL"
    fi

    cat <<EOF
supported min sdk api level: $PACKAGE_API_MIN
requested min sdk api level: $TARGET_ANDROID_API
EOF

    if [ "$PACKAGE_API_MIN" -gt "$TARGET_ANDROID_API" ] ; then
        abort 1 "package installation failure: '$1'\n    supported min sdk api level: $PACKAGE_API_MIN\n    requested min sdk api level: $TARGET_ANDROID_API"
    fi

    #########################################################################################

    printf '%s\n' "
     TIMESTAMP_UNIX = $TIMESTAMP_UNIX

     NATIVE_OS_KIND = $NATIVE_OS_KIND
     NATIVE_OS_TYPE = $NATIVE_OS_TYPE
     NATIVE_OS_CODE = $NATIVE_OS_CODE
     NATIVE_OS_NAME = $NATIVE_OS_NAME
     NATIVE_OS_VERS = $NATIVE_OS_VERS
     NATIVE_OS_ARCH = $NATIVE_OS_ARCH
     NATIVE_OS_NCPU = $NATIVE_OS_NCPU
     NATIVE_OS_LIBC = $NATIVE_OS_LIBC
     NATIVE_OS_EUID = $NATIVE_OS_EUID
     NATIVE_OS_EGID = $NATIVE_OS_EGID

     TARGET_ANDROID_API = $TARGET_ANDROID_API
     TARGET_ANDROID_ARCH = $TARGET_ANDROID_ARCH
     TARGET_ANDROID_ABI  = $TARGET_ANDROID_ABI

NDKPKG_VERSION      = $NDKPKG_VERSION
NDKPKG_HOME         = $NDKPKG_HOME
NDKPKG              = $NDKPKG
NDKPKG_URL_TRANSFORM= $NDKPKG_URL_TRANSFORM

          LOG_LEVEL = $LOG_LEVEL
          LINK_TYPE = $LINK_TYPE
         BUILD_TYPE = $BUILD_TYPE
        BUILD_NJOBS = $BUILD_NJOBS

             DRYRUN = $DRYRUN
     CCACHE_ENABLED = $CCACHE_ENABLED
   KEEP_WORKING_DIR = $KEEP_WORKING_DIR
EXPORT_COMPILE_COMMANDS_JSON = $EXPORT_COMPILE_COMMANDS_JSON
    "

    #########################################################################################

    PACKAGE_INSTALL_UTS=
    PACKAGE_INSTALL_UTS="$(date +%s)"

    PACKAGE_INSTALL_SHA=
    PACKAGE_INSTALL_SHA="$(
{
    sha256sum <<EOF
$PACKAGE_SPEC:$$:$PACKAGE_INSTALL_UTS
EOF
} | cut -d ' ' -f1)"

    #########################################################################################

    step "create and change to working directory"

    PACKAGE_WORKING_DIR="$SESSION_DIR/$PACKAGE_NAME"
    PACKAGE_INSTALL_DIR="$NDKPKG_PACKAGE_INSTALLED_ROOT/$PACKAGE_INSTALL_SHA"

    PACKAGE_INSTALLING_SRC_DIR="$PACKAGE_WORKING_DIR/src"
    PACKAGE_INSTALLING_FIX_DIR="$PACKAGE_WORKING_DIR/fix"
    PACKAGE_INSTALLING_RES_DIR="$PACKAGE_WORKING_DIR/res"
    PACKAGE_INSTALLING_BIN_DIR="$PACKAGE_WORKING_DIR/bin"
    PACKAGE_INSTALLING_LIB_DIR="$PACKAGE_WORKING_DIR/lib"
    PACKAGE_INSTALLING_INC_DIR="$PACKAGE_WORKING_DIR/include"

    PACKAGE_BCACHED_DIR="$PACKAGE_WORKING_DIR/src/_"

    rm -rf     "$PACKAGE_WORKING_DIR"

    install -d "$PACKAGE_INSTALLING_SRC_DIR"
    install -d "$PACKAGE_INSTALLING_FIX_DIR"
    install -d "$PACKAGE_INSTALLING_RES_DIR"
    install -d "$PACKAGE_INSTALLING_BIN_DIR"
    install -d "$PACKAGE_INSTALLING_INC_DIR"
    install -d "$PACKAGE_INSTALLING_LIB_DIR"
    install -d "$PACKAGE_BCACHED_DIR"

    install -d "$NDKPKG_CORE_DIR/libexec"

    cat <<EOF
PACKAGE_WORKING_DIR = $PACKAGE_WORKING_DIR
PACKAGE_BCACHED_DIR = $PACKAGE_BCACHED_DIR
PACKAGE_INSTALL_DIR = $PACKAGE_INSTALL_DIR
EOF

    run cd "$PACKAGE_WORKING_DIR"

    #########################################################################################

    step "locate C/C++ toolchain for native build"

    # https://www.real-world-systems.com/docs/xcrun.1.html
    # do not use this environment variable
    unset SDKROOT

    unset      CC_FOR_BUILD
    unset    OBJC_FOR_BUILD
    unset     CXX_FOR_BUILD
    unset     CPP_FOR_BUILD
    unset      AS_FOR_BUILD
    unset      AR_FOR_BUILD
    unset  RANLIB_FOR_BUILD
    unset      LD_FOR_BUILD
    unset      NM_FOR_BUILD
    unset    SIZE_FOR_BUILD
    unset   STRIP_FOR_BUILD
    unset STRINGS_FOR_BUILD
    unset OBJDUMP_FOR_BUILD
    unset OBJCOPY_FOR_BUILD
    unset READELF_FOR_BUILD
    unset SYSROOT_FOR_BUILD

    if [ "$NATIVE_OS_KIND" = 'darwin' ] ; then
             CC_FOR_BUILD="$(xcrun --sdk macosx --find clang)"
           OBJC_FOR_BUILD="$(xcrun --sdk macosx --find clang)"
            CXX_FOR_BUILD="$(xcrun --sdk macosx --find clang++)"
             AS_FOR_BUILD="$(xcrun --sdk macosx --find as)"
             AR_FOR_BUILD="$(xcrun --sdk macosx --find ar)"
         RANLIB_FOR_BUILD="$(xcrun --sdk macosx --find ranlib)"
             LD_FOR_BUILD="$(xcrun --sdk macosx --find ld)"
             NM_FOR_BUILD="$(xcrun --sdk macosx --find nm)"
           SIZE_FOR_BUILD="$(xcrun --sdk macosx --find size)"
          STRIP_FOR_BUILD="$(xcrun --sdk macosx --find strip)"
        STRINGS_FOR_BUILD="$(xcrun --sdk macosx --find strings)"
        OBJDUMP_FOR_BUILD="$(xcrun --sdk macosx --find objdump)"
        SYSROOT_FOR_BUILD="$(xcrun --sdk macosx --show-sdk-path)"
    else
             CC_FOR_BUILD="$(command -v cc || command -v clang || command -v gcc)" || abort 1 "C Compiler for native not found."
           OBJC_FOR_BUILD="$(command -v cc || command -v clang || command -v gcc)" || abort 1 "C Compiler for native not found."
            CXX_FOR_BUILD="$(command -v c++ || command -v clang++ || command -v g++)" || abort 1 "C++ Compiler for native not found."
             AS_FOR_BUILD="$(command -v as)"      || abort 1 "command not found: as"
             AR_FOR_BUILD="$(command -v ar)"      || abort 1 "command not found: ar"
         RANLIB_FOR_BUILD="$(command -v ranlib)"  || abort 1 "command not found: ranlib"
             LD_FOR_BUILD="$(command -v ld)"      || abort 1 "command not found: ld"
             NM_FOR_BUILD="$(command -v nm)"      || abort 1 "command not found: nm"
           SIZE_FOR_BUILD="$(command -v size)"    || abort 1 "command not found: size"
          STRIP_FOR_BUILD="$(command -v strip)"   || abort 1 "command not found: strip"
        STRINGS_FOR_BUILD="$(command -v strings)" || abort 1 "command not found: strings"
        OBJDUMP_FOR_BUILD="$(command -v objdump)" || abort 1 "command not found: objdump"
        OBJCOPY_FOR_BUILD="$(command -v objcopy)" || abort 1 "command not found: objcopy"
        READELF_FOR_BUILD="$(command -v readelf)" || abort 1 "command not found: readelf"
    fi

    CPP_FOR_BUILD="$CC_FOR_BUILD -E"

    for TOOL in CC OBJC CXX AS AR RANLIB LD NM STRIP SIZE STRINGS OBJDUMP OBJCOPY READELF SYSROOT
    do
        export "${TOOL}_FOR_BUILD"
        printf "%17s = %s\n" "${TOOL}_FOR_BUILD" "$(eval echo \$"${TOOL}_FOR_BUILD")"
    done

    ##################################################################################

    if [ "$NATIVE_OS_KIND" = 'darwin' ] ; then
        # If -mmacosx-version-min is unspecified, the default deployment target is read from MACOSX_DEPLOYMENT_TARGET environment variable. This option only affects Darwin targets.
        # https://clang.llvm.org/docs/CommandGuide/clang.html#envvar-MACOSX_DEPLOYMENT_TARGET
        # https://clang.llvm.org/docs/CommandGuide/clang.html#cmdoption-mmacosx-version-min

        NATIVE_OS_VERS_MAJOR="$(printf '%s\n' "$NATIVE_OS_VERS" | cut -d. -f1)"
        NATIVE_OS_VERS_MINOR="$(printf '%s\n' "$NATIVE_OS_VERS" | cut -d. -f2)"

        export MACOSX_DEPLOYMENT_TARGET="$NATIVE_OS_VERS_MAJOR.$NATIVE_OS_VERS_MINOR"

        ##################################################################################

        step "create wrapper for C Compiler for native build"

        cat > wrapper-native-cc.c <<EOF
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int main(int argc, char * argv[]) {
    char* argv2[argc + 2];

    argv2[0] = (char*)"$CC_FOR_BUILD";
    argv2[1] = (char*)"-isysroot";
    argv2[2] = (char*)"$SYSROOT_FOR_BUILD";

    for (int i = 1; i < argc; i++) {
        argv2[i + 2] = argv[i];
    }

    argv2[argc + 2] = NULL;

    execv (argv2[0], argv2);
    perror(argv2[0]);
    return 255;
}
EOF

        WRAPPER_CC_FOR_BUILD="$NDKPKG_CORE_DIR/libexec/wrapper-native-cc"

        run "$CC_FOR_BUILD" -std=c99 -isysroot "$SYSROOT_FOR_BUILD" -o "$WRAPPER_CC_FOR_BUILD" wrapper-native-cc.c

        ##################################################################################

        step "create wrapper for C++ Compiler for native build"

        cat > wrapper-native-c++.c <<EOF
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int main(int argc, char * argv[]) {
    char* argv2[argc + 2];

    argv2[0] = (char*)"$CXX_FOR_BUILD";
    argv2[1] = (char*)"-isysroot";
    argv2[2] = (char*)"$SYSROOT_FOR_BUILD";

    for (int i = 1; i < argc; i++) {
        argv2[i + 2] = argv[i];
    }

    argv2[argc + 2] = NULL;

    execv (argv2[0], argv2);
    perror(argv2[0]);
    return 255;
}
EOF

        WRAPPER_CXX_FOR_BUILD="$NDKPKG_CORE_DIR/libexec/wrapper-native-c++"

        run "$CC_FOR_BUILD" -std=c99 -isysroot "$SYSROOT_FOR_BUILD" -o "$WRAPPER_CXX_FOR_BUILD" wrapper-native-c++.c

        ##################################################################################

        export PROXIED_CC_FOR_BUILD="$CC_FOR_BUILD"
        export PROXIED_CXX_FOR_BUILD="$CXX_FOR_BUILD"

        export CC_FOR_BUILD="$WRAPPER_CC_FOR_BUILD"
        export CXX_FOR_BUILD="$WRAPPER_CXX_FOR_BUILD"
        export CPP_FOR_BUILD="$CC_FOR_BUILD -E"

        cat <<EOF
PROXIED_CC_FOR_BUILD  = $PROXIED_CC_FOR_BUILD
PROXIED_CXX_FOR_BUILD = $PROXIED_CXX_FOR_BUILD

        CC_FOR_BUILD  = $CC_FOR_BUILD
        CPP_FOR_BUILD = $CPP_FOR_BUILD
        CXX_FOR_BUILD = $CXX_FOR_BUILD
EOF
    fi

    #########################################################################################

    step "config CFLAGS_FOR_BUILD OBJCFLAGS_FOR_BUILD CXXFLAGS_FOR_BUILD CPPFLAGS_FOR_BUILD LDFLAGS_FOR_BUILD"

    if [ "$NATIVE_OS_KIND" = 'darwin' ] ; then
          CFLAGS_FOR_BUILD="-isysroot $SYSROOT_FOR_BUILD -mmacosx-version-min=$NATIVE_OS_VERS -arch $NATIVE_OS_ARCH -Qunused-arguments"
       OBJCFLAGS_FOR_BUILD="-isysroot $SYSROOT_FOR_BUILD -mmacosx-version-min=$NATIVE_OS_VERS -arch $NATIVE_OS_ARCH -Qunused-arguments"
        CXXFLAGS_FOR_BUILD="-isysroot $SYSROOT_FOR_BUILD -mmacosx-version-min=$NATIVE_OS_VERS -arch $NATIVE_OS_ARCH -Qunused-arguments"
        CPPFLAGS_FOR_BUILD="-isysroot $SYSROOT_FOR_BUILD -Qunused-arguments"
         LDFLAGS_FOR_BUILD="-isysroot $SYSROOT_FOR_BUILD -mmacosx-version-min=$NATIVE_OS_VERS -arch $NATIVE_OS_ARCH"
    else
          CFLAGS_FOR_BUILD="-fPIC -fno-common"
       OBJCFLAGS_FOR_BUILD="-fPIC -fno-common"
        CXXFLAGS_FOR_BUILD="-fPIC -fno-common"
        CPPFLAGS_FOR_BUILD=
        # https://gcc.gnu.org/onlinedocs/gcc/Link-Options.html
         LDFLAGS_FOR_BUILD="-Wl,--as-needed -Wl,-z,muldefs -Wl,--allow-multiple-definition"
    fi

        CPPFLAGS_FOR_BUILD="$CPPFLAGS_FOR_BUILD -I$NDKPKG_CORE_DIR/include"
         LDFLAGS_FOR_BUILD="$LDFLAGS_FOR_BUILD  -L$NDKPKG_CORE_DIR/lib -Wl,-rpath,$NDKPKG_CORE_DIR/lib"

    if [ "$LOG_LEVEL" -ge 3 ] ; then
          CFLAGS_FOR_BUILD="$CFLAGS_FOR_BUILD -v"
        CXXFLAGS_FOR_BUILD="$CXXFLAGS_FOR_BUILD -v"
       OBJCFLAGS_FOR_BUILD="$OBJCFLAGS_FOR_BUILD -v"
         LDFLAGS_FOR_BUILD="$LDFLAGS_FOR_BUILD -Wl,-v"
    fi

    if [ "$BUILD_TYPE" = release ] ; then
          CFLAGS_FOR_BUILD="$CFLAGS_FOR_BUILD -Os"
        CXXFLAGS_FOR_BUILD="$CXXFLAGS_FOR_BUILD -Os"
       OBJCFLAGS_FOR_BUILD="$OBJCFLAGS_FOR_BUILD -Os"
         LDFLAGS_FOR_BUILD="$LDFLAGS_FOR_BUILD -Wl,-S"
    fi

    export    CFLAGS_FOR_BUILD
    export  CPPFLAGS_FOR_BUILD
    export  CXXFLAGS_FOR_BUILD
    export OBJCFLAGS_FOR_BUILD
    export   LDFLAGS_FOR_BUILD

    printf '%b\n' "${COLOR_PURPLE}==>${COLOR_OFF} CFLAGS_FOR_BUILD"
    printf '%s\n' "$CFLAGS_FOR_BUILD"   | xargs printf '        %s\n'
    printf '\n'

    printf '%b\n' "${COLOR_PURPLE}==>${COLOR_OFF} OBJCFLAGS_FOR_BUILD"
    printf '%s\n' "$OBJCFLAGS_FOR_BUILD" | xargs printf '        %s\n'
    printf '\n'

    printf '%b\n' "${COLOR_PURPLE}==>${COLOR_OFF} CXXFLAGS_FOR_BUILD"
    printf '%s\n' "$CXXFLAGS_FOR_BUILD" | xargs printf '        %s\n'
    printf '\n'

    printf '%b\n' "${COLOR_PURPLE}==>${COLOR_OFF} CPPFLAGS_FOR_BUILD"
    printf '%s\n' "$CPPFLAGS_FOR_BUILD" | xargs printf '        %s\n'
    printf '\n'

    printf '%b\n' "${COLOR_PURPLE}==>${COLOR_OFF} LDFLAGS_FOR_BUILD"
    printf '%s\n' "$LDFLAGS_FOR_BUILD"  | xargs printf '        %s\n'

    #########################################################################################

    # install perl module need these, they will be override when cross compile starting

    export      CC="$CC_FOR_BUILD"
    export    OBJC="$OBJC_FOR_BUILD"
    export     CXX="$CXX_FOR_BUILD"
    export     CPP="$CPP_FOR_BUILD"
    export      AS="$AS_FOR_BUILD"
    export      AR="$AR_FOR_BUILD"
    export  RANLIB="$RANLIB_FOR_BUILD"
    export      LD="$LD_FOR_BUILD"
    export      NM="$NM_FOR_BUILD"
    export    SIZE="$SIZE_FOR_BUILD"
    export   STRIP="$STRIP_FOR_BUILD"
    export STRINGS="$STRINGS_FOR_BUILD"
    export OBJDUMP="$OBJDUMP_FOR_BUILD"

    export    CFLAGS="$CFLAGS_FOR_BUILD"
    export OBJCFLAGS="$OBJCFLAGS_FOR_BUILD"
    export  CXXFLAGS="$CXXFLAGS_FOR_BUILD"
    export  CPPFLAGS="$CPPFLAGS_FOR_BUILD"
    export   LDFLAGS="$LDFLAGS_FOR_BUILD"

    #########################################################################################

    if [ "$PACKAGE_BUILD_SYSTEM_CMAKE" = yes ] ; then
        step "config environment variables for cmake for native build"

        # https://cmake.org/cmake/help/latest/manual/cmake-env-variables.7.html#manual:cmake-env-variables(7)

        unset CMAKE_PREFIX_PATH
        unset CMAKE_APPLE_SILICON_PROCESSOR
        unset CMAKE_BUILD_PARALLEL_LEVEL
        unset CMAKE_BUILD_TYPE
        unset CMAKE_CONFIGURATION_TYPES
        unset CMAKE_CONFIG_TYPE
        unset CMAKE_EXPORT_COMPILE_COMMANDS
        unset CMAKE_GENERATOR
        unset CMAKE_GENERATOR_INSTANCE
        unset CMAKE_GENERATOR_PLATFORM
        unset CMAKE_GENERATOR_TOOLSET
        unset CMAKE_INSTALL_MODE
        unset CMAKE_C_COMPILER_LAUNCHER
        unset CMAKE_C_LINKER_LAUNCHER
        unset CMAKE_CXX_COMPILER_LAUNCHER
        unset CMAKE_CXX_LINKER_LAUNCHER
        unset CMAKE_MSVCIDE_RUN_PATH
        unset CMAKE_NO_VERBOSE
        unset CMAKE_OSX_ARCHITECTURES
        unset CMAKE_TOOLCHAIN_FILE
        unset DESTDIR
        unset CTEST_INTERACTIVE_DEBUG_MODE
        unset CTEST_OUTPUT_ON_FAILURE
        unset CTEST_PARALLEL_LEVEL
        unset CTEST_PROGRESS_OUTPUT
        unset CTEST_USE_LAUNCHERS_DEFAULT
        unset DASHBOARD_TEST_FROM_CTEST

        # https://cmake.org/cmake/help/latest/envvar/CMAKE_BUILD_PARALLEL_LEVEL.html
        export CMAKE_BUILD_PARALLEL_LEVEL="$BUILD_NJOBS"

        # https://cmake.org/cmake/help/latest/envvar/CMAKE_GENERATOR.html
        if [ "$PACKAGE_BUILD_SYSTEM_NINJA" = yes ] ; then
            export CMAKE_GENERATOR='Ninja'
        else
            export CMAKE_GENERATOR='Unix Makefiles'
        fi

        # https://cmake.org/cmake/help/latest/envvar/CMAKE_EXPORT_COMPILE_COMMANDS.html
        if [ "$EXPORT_COMPILE_COMMANDS_JSON" = yes ] ; then
            export CMAKE_EXPORT_COMPILE_COMMANDS=ON
        else
            export CMAKE_EXPORT_COMPILE_COMMANDS=OFF
        fi

        case $BUILD_TYPE in
            debug)   CMAKE_BUILD_TYPE=Debug   ;;
            release) CMAKE_BUILD_TYPE=Release ;;
        esac

        if [ "$LOG_LEVEL" -eq 0 ] ; then
            CMAKE_VERBOSE_MAKEFILE=OFF
            CMAKE_COLOR_MAKEFILE=OFF
        else
            CMAKE_VERBOSE_MAKEFILE=ON
            CMAKE_COLOR_MAKEFILE=ON
        fi

        # https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_DEBUG_MODE.html
        if [ "$LOG_LEVEL" -ge 3 ] ; then
            CMAKE_FIND_DEBUG_MODE=ON
        else
            CMAKE_FIND_DEBUG_MODE=OFF
        fi

        env | sed -n '/^CMAKE_/p'
    fi

    #########################################################################################

    unset RECURSIVE_DEPENDENT_PACKAGE_NAMES

    [ -n "$PACKAGE_DEP_PKG" ] && {
        step "calculate dependency list of $1"

        unset PACKAGE_NAME_STACK

        for item in $PACKAGE_DEP_PKG
        do
            if [ -z "$item" ] ; then
                PACKAGE_NAME_STACK="$item"
            else
                PACKAGE_NAME_STACK="$PACKAGE_NAME_STACK;$item"
            fi
        done

        while [ -n "$PACKAGE_NAME_STACK" ]
        do
            case $PACKAGE_NAME_STACK in
                *\;*) TOPE="${PACKAGE_NAME_STACK##*;}" ; PACKAGE_NAME_STACK="${PACKAGE_NAME_STACK%;*}" ;;
                *)    TOPE="${PACKAGE_NAME_STACK}"     ; PACKAGE_NAME_STACK=
            esac

            RECURSIVE_DEPENDENT_PACKAGE_NAMES2="$TOPE"

            for item in $RECURSIVE_DEPENDENT_PACKAGE_NAMES
            do
                if [ "$item" != "$TOPE" ] ; then
                    RECURSIVE_DEPENDENT_PACKAGE_NAMES2="$RECURSIVE_DEPENDENT_PACKAGE_NAMES2 $item"
                fi
            done

            RECURSIVE_DEPENDENT_PACKAGE_NAMES="$RECURSIVE_DEPENDENT_PACKAGE_NAMES2"

            unset TOPE_UPPERCASE_UNDERSCORE
            TOPE_UPPERCASE_UNDERSCORE=$(printf '%s\n' "$TOPE" | tr '@+-.' '_' | tr a-z A-Z)

            for item in $(eval echo \$PACKAGE_DEP_PKG_"${TOPE_UPPERCASE_UNDERSCORE}")
            do
                if [ -z "$item" ] ; then
                    PACKAGE_NAME_STACK="$item"
                else
                    PACKAGE_NAME_STACK="$PACKAGE_NAME_STACK;$item"
                fi
            done
        done

        printf '%s\n' "$RECURSIVE_DEPENDENT_PACKAGE_NAMES"
    }

    #########################################################################################

    unset RECURSIVE_DEPENDENT_PACKAGE_INSTALL_DIRS

    [ -n "$PACKAGE_DEP_PKG" ] && {
        for DEPENDENT_PACKAGE_NAME in $RECURSIVE_DEPENDENT_PACKAGE_NAMES
        do
            DEPENDENT_PACKAGE_INSTALL_DIR="$(readlink -f "$NDKPKG_PACKAGE_INSTALLED_ROOT/$DEPENDENT_PACKAGE_NAME:$TARGET_ANDROID_SPEC")"

            if [ -z "$RECURSIVE_DEPENDENT_PACKAGE_INSTALL_DIRS" ] ; then
                RECURSIVE_DEPENDENT_PACKAGE_INSTALL_DIRS="$DEPENDENT_PACKAGE_INSTALL_DIR"
            else
                RECURSIVE_DEPENDENT_PACKAGE_INSTALL_DIRS="$RECURSIVE_DEPENDENT_PACKAGE_INSTALL_DIRS $DEPENDENT_PACKAGE_INSTALL_DIR"
            fi

            #########################################################################################

            DEPENDENT_PACKAGE_BINARY__DIR="$NDKPKG_HOME/native/$DEPENDENT_PACKAGE_NAME/bin"

            if [ -d  "$DEPENDENT_PACKAGE_BINARY__DIR" ] ; then
                PATH="$DEPENDENT_PACKAGE_BINARY__DIR:$PATH"
            fi

            DEPENDENT_PACKAGE_BINARY__DIR="$NDKPKG_HOME/native/$DEPENDENT_PACKAGE_NAME/sbin"

            if [ -d  "$DEPENDENT_PACKAGE_BINARY__DIR" ] ; then
                PATH="$DEPENDENT_PACKAGE_BINARY__DIR:$PATH"
            fi

            if [ -d          "$NDKPKG_HOME/native/$DEPENDENT_PACKAGE_NAME/share/aclocal" ] ; then
                ACLOCAL_PATH="$NDKPKG_HOME/native/$DEPENDENT_PACKAGE_NAME/share/aclocal:$ACLOCAL_PATH"
            fi
        done
    }

    #########################################################################################

    [ -n "$PACKAGE_DEP_PKG" ] && {
        step "generate  dependency tree of $1"

        unset DOT_CONTENT

        PACKAGE_NAME_STACK="$PACKAGE_NAME"

        while [ -n "$PACKAGE_NAME_STACK" ]
        do
            case $PACKAGE_NAME_STACK in
                *\;*) TOPE="${PACKAGE_NAME_STACK##*;}" ; PACKAGE_NAME_STACK="${PACKAGE_NAME_STACK%;*}" ;;
                *)    TOPE="${PACKAGE_NAME_STACK}"     ; PACKAGE_NAME_STACK=
            esac

            unset TOPE_UPPERCASE_UNDERSCORE
            TOPE_UPPERCASE_UNDERSCORE=$(printf '%s\n' "$TOPE" | tr '@+-.' '_' | tr a-z A-Z)

            TOPE_DEP_PKG="$(eval echo \$PACKAGE_DEP_PKG_"${TOPE_UPPERCASE_UNDERSCORE}")"

            if [ -n "$TOPE_DEP_PKG" ] ; then
                unset X; X="$(printf '"%s" ' $TOPE_DEP_PKG)"
                unset Y; Y="$(printf '    "%s" -> { %s}\n' "$TOPE" "$X")"

                if [ -z "$DOT_CONTENT" ] ; then
                    DOT_CONTENT="$Y"
                else
                    DOT_CONTENT="$(printf '%s\n%s\n' "$DOT_CONTENT" "$Y")"
                fi
            fi

            for item in $TOPE_DEP_PKG
            do

                if [ -z "$item" ] ; then
                    PACKAGE_NAME_STACK="$item"
                else
                    PACKAGE_NAME_STACK="$PACKAGE_NAME_STACK;$item"
                fi
            done
        done

        DOT_CONTENT="digraph G {
$DOT_CONTENT
}"

        ############################################################################

        PACKAGE_DEPENDENCY_GRAPH_FILEPATH_DOT="$PACKAGE_WORKING_DIR/dependencies.dot"
        PACKAGE_DEPENDENCY_GRAPH_FILEPATH_BOX="$PACKAGE_WORKING_DIR/dependencies.box"

        ############################################################################

        printf '%s\n' "$DOT_CONTENT" > "$PACKAGE_DEPENDENCY_GRAPH_FILEPATH_DOT"

        ############################################################################

        # https://github.com/ggerganov/dot-to-ascii
        curl \
            -o "$PACKAGE_DEPENDENCY_GRAPH_FILEPATH_BOX" \
            -s \
            -G \
            --data-urlencode "boxart=1" \
            --data-urlencode "src=$DOT_CONTENT" \
            "https://dot-to-ascii.ggerganov.com/dot-to-ascii.php" || true

        ############################################################################

        command -v dot > /dev/null && {
            run dot -Tsvg -o "$PACKAGE_WORKING_DIR/dependencies.svg" "$PACKAGE_DEPENDENCY_GRAPH_FILEPATH_DOT" || true
            run dot -Tpng -o "$PACKAGE_WORKING_DIR/dependencies.png" "$PACKAGE_DEPENDENCY_GRAPH_FILEPATH_DOT" || true
        }

        ############################################################################

        if [ -f "$PACKAGE_DEPENDENCY_GRAPH_FILEPATH_BOX" ] ; then
            cat "$PACKAGE_DEPENDENCY_GRAPH_FILEPATH_BOX"
        else
            cat "$PACKAGE_DEPENDENCY_GRAPH_FILEPATH_DOT"
        fi
    }

    #########################################################################################

    PACKAGE_DEP_UPP="${PACKAGE_DEP_UPP#' '}"

    PACKAGE_DEP_UPP_ALL="$PACKAGE_DEP_UPP pkg-config"

    if [ "$PACKAGE_BUILD_SYSTEM_GMAKE" = yes ] && [ "$EXPORT_COMPILE_COMMANDS_JSON" = yes ] && [ "$BEAR_ENABLED" = yes ] ; then
        PACKAGE_DEP_UPP_ALL="$PACKAGE_DEP_UPP_ALL bear"
    fi

    if [ "$CCACHE_ENABLED" = yes ] ; then
        PACKAGE_DEP_UPP_ALL="$PACKAGE_DEP_UPP_ALL ccache"
    fi

    PACKAGE_DEP_UPP_ALL="$PACKAGE_DEP_UPP_ALL patchelf tree"

    #########################################################################################

    step "install needed packages via uppm"

    run "$UPPM" env
    run "$UPPM" update

    # these packages are not relocatable, we should build them from source locally.
    PACKAGE_USE_RUBY=no
    PACKAGE_USE_PERL=no
    PACKAGE_USE_OPENSSL=no
    PACKAGE_USE_TEXINFO=no
    PACKAGE_USE_HELP2MAN=no
    PACKAGE_USE_INTLTOOL=no
    PACKAGE_USE_PYTHON3=no
    PACKAGE_USE_LIBTOOL=no
    PACKAGE_USE_AUTOMAKE=no
    PACKAGE_USE_AUTOCONF=no

    for item in $PACKAGE_DEP_UPP_ALL
    do
        case $item in
            perl)     PACKAGE_DEP_UPP_ALL="$PACKAGE_DEP_UPP_ALL gmake"       ; PACKAGE_USE_PERL=yes ;;
            openssl)  PACKAGE_DEP_UPP_ALL="$PACKAGE_DEP_UPP_ALL gmake"       ; PACKAGE_USE_PERL=yes ; PACKAGE_USE_OPENSSL=yes  ;;
            texinfo)  PACKAGE_DEP_UPP_ALL="$PACKAGE_DEP_UPP_ALL gmake"       ; PACKAGE_USE_PERL=yes ; PACKAGE_USE_TEXINFO=yes  ;;
            help2man) PACKAGE_DEP_UPP_ALL="$PACKAGE_DEP_UPP_ALL gmake"       ; PACKAGE_USE_PERL=yes ; PACKAGE_USE_HELP2MAN=yes ;;
            intltool) PACKAGE_DEP_UPP_ALL="$PACKAGE_DEP_UPP_ALL gmake cmake" ; PACKAGE_USE_PERL=yes ; PACKAGE_USE_INTLTOOL=yes ;;
            python3)  PACKAGE_DEP_UPP_ALL="$PACKAGE_DEP_UPP_ALL gmake cmake" ; PACKAGE_USE_PERL=yes ; PACKAGE_USE_PYTHON3=yes  ; PACKAGE_USE_OPENSSL=yes ;;
            ruby)     PACKAGE_DEP_UPP_ALL="$PACKAGE_DEP_UPP_ALL gmake cmake" ; PACKAGE_USE_PERL=yes ; PACKAGE_USE_RUBY=yes     ; PACKAGE_USE_OPENSSL=yes ;;
            libtool)  PACKAGE_DEP_UPP_ALL="$PACKAGE_DEP_UPP_ALL gmake gm4"   ;                        PACKAGE_USE_LIBTOOL=yes  ;;
            autoconf) PACKAGE_DEP_UPP_ALL="$PACKAGE_DEP_UPP_ALL gmake gm4"   ; PACKAGE_USE_PERL=yes ; PACKAGE_USE_AUTOCONF=yes ;;
            automake) PACKAGE_DEP_UPP_ALL="$PACKAGE_DEP_UPP_ALL gmake gm4"   ; PACKAGE_USE_PERL=yes ; PACKAGE_USE_AUTOCONF=yes ; PACKAGE_USE_AUTOMAKE=yes ;;
        esac
    done

    for item in $PACKAGE_DEP_UPP_ALL
    do
        case $item in
            python3|perl|ruby|texinfo|help2man|intltool|libtool|autoconf|automake) continue
        esac

        run "$UPPM" install "$item"

        UPPM_PACKAGE_INSTALLED_DIR="$("$UPPM" info "$item" installed-dir)"

        if [ -d  "$UPPM_PACKAGE_INSTALLED_DIR/bin" ] ; then
            PATH="$UPPM_PACKAGE_INSTALLED_DIR/bin:$PATH"
        fi

        if [ -d  "$UPPM_PACKAGE_INSTALLED_DIR/sbin" ] ; then
            PATH="$UPPM_PACKAGE_INSTALLED_DIR/sbin:$PATH"
        fi

        if [ -d          "$UPPM_PACKAGE_INSTALLED_DIR/share/aclocal" ] ; then
            ACLOCAL_PATH="$UPPM_PACKAGE_INSTALLED_DIR/share/aclocal:$ACLOCAL_PATH"
        fi

        if [ "$item" = 'docbook-xsl' ] ; then
            # http://xmlsoft.org/xslt/xsltproc.html
            export XML_CATALOG_FILES="$UPPM_PACKAGE_INSTALLED_DIR/catalog.xml"
            printf '%s\n' "XML_CATALOG_FILES=$XML_CATALOG_FILES"
        fi
    done

    (
        export PKG_CONFIG_PATH="$NDKPKG_CORE_DIR/lib/pkgconfig"


        [ "$PACKAGE_USE_PERL"     = yes ] && __install_native_package_to_core_dir perl
        [ "$PACKAGE_USE_OPENSSL"  = yes ] && __install_native_package_to_core_dir openssl
        [ "$PACKAGE_USE_TEXINFO"  = yes ] && __install_native_package_to_core_dir texinfo
        [ "$PACKAGE_USE_HELP2MAN" = yes ] && __install_native_package_to_core_dir help2man
        [ "$PACKAGE_USE_LIBTOOL"  = yes ] && __install_native_package_to_core_dir libtool
        [ "$PACKAGE_USE_AUTOCONF" = yes ] && __install_native_package_to_core_dir autoconf
        [ "$PACKAGE_USE_AUTOMAKE" = yes ] && __install_native_package_to_core_dir automake

        [ "$PACKAGE_USE_INTLTOOL" = yes ] && {
            __install_native_package_to_core_dir expat
            __install_native_package_to_core_dir perl-XML-Parser
            __install_native_package_to_core_dir intltool
        }

        [ "$PACKAGE_USE_PYTHON3" = yes ] && {
            __install_native_package_to_core_dir zlib
            __install_native_package_to_core_dir libbz2
            __install_native_package_to_core_dir liblzma
            __install_native_package_to_core_dir gdbm
            __install_native_package_to_core_dir expat
            __install_native_package_to_core_dir sqlite3
            __install_native_package_to_core_dir libffi
            __install_native_package_to_core_dir python3
        }

        [ "$PACKAGE_USE_RUBY" = yes ] && {
            __install_native_package_to_core_dir zlib
            __install_native_package_to_core_dir libyaml
            __install_native_package_to_core_dir libffi
            __install_native_package_to_core_dir ruby
        }

        :
    )

    PATH="$(printf '%s\n' "$PATH" | sed "s|:$NDKPKG_CORE_BIN_DIR||g")"
    PATH="$NDKPKG_CORE_BIN_DIR:$PATH"

    #########################################################################################

    [ -n "$PACKAGE_DEP_PYM" ] && {
        step "install needed python packages via pip3"

        run pip3 --version
        run pip3 install --upgrade pip setuptools wheel
        run pip3 --version

        for item in $PACKAGE_DEP_PYM
        do
            run pip3 install "$item" --upgrade
        done
    }

    #########################################################################################

    # cpan use the C/C++ compiler same as perl was built with
    # so make sure C/C++ compiler be found before reaching here

    [ -n "$PACKAGE_DEP_PLM" ] && {
        step "install needed perl modules via cpan"

        for item in $PACKAGE_DEP_PLM
        do
            if perl -M"$item" -le 'print "installed"' > /dev/null 2>&1 ; then
                note "perl module $item has been already installed."
                continue
            fi

            if [ "$item" = 'XML::Parser' ] ; then
                __install_native_package_to_core_dir expat
                __install_native_package_to_core_dir perl-XML-Parser
            else
                # Would you like to configure as much as possible automatically? [yes]
                # https://perldoc.perl.org/cpan#PERL_MM_USE_DEFAULT
                export PERL_MM_USE_DEFAULT=1
                run cpan "$item"
            fi
        done

        if [ -d "$HOME/perl5/bin" ] ; then
            # cpan install to default local location
            bppend_to_PATH "$HOME/perl5/bin"
        fi
    }

    #########################################################################################

    [ "$PACKAGE_BUILD_SYSTEM_CARGO" = yes ] && {
        command -v rustup > /dev/null || {
            # https://www.rust-lang.org/tools/install
            note "${COLOR_GREEN}rustup cargo rustc${COLOR_OFF} ${COLOR_YELLOW}commands are required, but it was not found, let's install it.${COLOR_OFF}"

            RUST_INIT_SH_FILEPATH="$PACKAGE_WORKING_DIR/rustup-init.sh"

            wfetch 'https://sh.rustup.rs' --output-path="$RUST_INIT_SH_FILEPATH"

            run bash "$RUST_INIT_SH_FILEPATH" -y

            export CARGO_HOME="$HOME/.cargo"
            export PATH="$CARGO_HOME/bin:$PATH"
        }
    }

    #########################################################################################

    step "locate build tools"

    unset AUTORECONF
    unset AUTOCONF
    unset AUTOMAKE
    unset ACLOCAL
    unset PERL
    unset M4

    unset MESON
    unset CMAKE
    unset XMAKE
    unset GMAKE
    unset NINJA

    unset BEAR
    unset CCACHE
    unset PKG_CONFIG

    if [ "$PACKAGE_BUILD_SYSTEM_AUTOGENSH" = yes ] || [ "$PACKAGE_BUILD_SYSTEM_AUTOTOOLS" = yes ] ; then
        AUTORECONF=$(command -v autoreconf) || abort 1 "command not found: autoreconf"
        AUTOCONF=$(command -v autoconf)     || abort 1 "command not found: autoconf"
        AUTOMAKE=$(command -v automake)     || abort 1 "command not found: automake"
        ACLOCAL=$(command -v aclocal)       || abort 1 "command not found: aclocal"
        PERL=$(command -v perl)             || abort 1 "command not found: perl"
        M4=$(command -v m4)                 || abort 1 "command not found: m4"

        run "$AUTORECONF" --version
        printf '\n'
        run "$AUTOCONF"   --version
        printf '\n'
        run "$AUTOMAKE"   --version
        printf '\n'
        run "$ACLOCAL"    --version
        printf '\n'
        run "$PERL"       --version
        printf '\n'
        run "$M4"         --version
        printf '\n'
    fi

    [ "$PACKAGE_BUILD_SYSTEM_MESON" = yes ] && {
        MESON=$(command -v meson) || abort 1 "command not found: meson"
        run "$MESON"      --version
        printf '\n'
    }

    [ "$PACKAGE_BUILD_SYSTEM_CMAKE" = yes ] && {
        CMAKE=$(command -v cmake) || abort 1 "command not found: cmake"
        run "$CMAKE"      --version
        printf '\n'
    }

    [ "$PACKAGE_BUILD_SYSTEM_XMAKE" = yes ] && {
        XMAKE=$(command -v xmake) || abort 1 "command not found: xmake"

        # error: Running xmake as root is extremely dangerous and no longer supported.
        # As xmake does not drop privileges on installation you would be giving all
        # build scripts full access to your system.
        # Or you can add `--root` option or XMAKE_ROOT=y to allow run as root temporarily.
        export XMAKE_ROOT=y

        run "$XMAKE"      --version
        printf '\n'
    }

    [ "$PACKAGE_BUILD_SYSTEM_GMAKE" = yes ] && {
        GMAKE=$(command -v gmake || command -v make) || abort 1 "command not found: gmake and make"
        run "$GMAKE"      --version
        printf '\n'
    }

    [ "$PACKAGE_BUILD_SYSTEM_NINJA" = yes ] && {
        NINJA=$(command -v ninja) || abort 1 "command not found: ninja"
        run "$NINJA"      --version
        printf '\n'
    }

    [ "$PACKAGE_BUILD_SYSTEM_CARGO" = yes ] && {
        RUSTUP=$(command -v rustup) || abort 1 "command not found: rustup"
        CARGO=$(command -v cargo)   || abort 1 "command not found: cargo"
        run "$RUSTUP"     --version
        printf '\n'
        run "$CARGO"      --version
        printf '\n'
    }

    [ "$PACKAGE_BUILD_SYSTEM_GO" = yes ] && {
        GO=$(command -v go) || abort 1 "command not found: go"
        run "$GO"      version
        printf '\n'
    }

    [ "$CCACHE_ENABLED" = yes ] && {
        CCACHE=$(command -v ccache) || abort 1 "command not found: ccache"
        run "$CCACHE"    --version
        printf '\n'
    }

    PKG_CONFIG=$(command -v pkg-config || command -v pkgconf) || abort 1 "command not found: pkg-config"

    run "$PKG_CONFIG"    --version
    printf '\n'

    unset  M4
    export M4="$(command -v m4 || true)"

    PATCHELF=$(command -v patchelf) || abort 1 "command not found: patchelf"
    run "$PATCHELF" --version
    printf '\n'

    TREE=$(command -v tree) || abort 1 "command not found: tree"
    run "$TREE" --version
    printf '\n'

    #########################################################################################

    step "fetch source/patches/resources from server"
    __fetch_sources_of_the_given_package
    __fetch_patches_of_the_given_package

    #########################################################################################

    case $PACKAGE_SRC_FILETYPE in
        .dir)
            if [ "$PACKAGE_SRC_FILEPATH" = '/dev/null' ] ; then
                :
            elif [ -d "$PACKAGE_SRC_FILEPATH" ] ; then
                if [ -d "$PACKAGE_SRC_FILEPATH/.git" ] && command -v git > /dev/null ; then
                    PACKAGE_GIT_SHA=$(git -C "$PACKAGE_SRC_FILEPATH" rev-parse HEAD || true)
                fi
                step "copy source files to the installing src directory"
                run cp -r "$PACKAGE_SRC_FILEPATH/." "$PACKAGE_INSTALLING_SRC_DIR"
            else
                abort 1 "src-url point to dir does not exist."
            fi
            ;;
        .git)
            if [ -z "$PACKAGE_GIT_SHA" ] ; then
                PACKAGE_GIT_SHA=$(git -C "$PACKAGE_SRC_FILEPATH" rev-parse HEAD || true)
            fi
            step "copy source files to the installing src directory"
            run cp -r "$PACKAGE_SRC_FILEPATH/." "$PACKAGE_INSTALLING_SRC_DIR"
            ;;
        .zip)
            step "uncompressed source file to the installing src directory"
            run unzip  "$PACKAGE_SRC_FILEPATH" -d "$PACKAGE_INSTALLING_SRC_DIR"
            ;;
        .txz|.tgz|.tlz|.tbz2)
            step "uncompressed source file to the installing src directory"
            run tar xf "$PACKAGE_SRC_FILEPATH" -C "$PACKAGE_INSTALLING_SRC_DIR" --strip-components 1 --no-same-owner
            ;;
        *)  step "copy source files to the installing src directory"
            run cp     "$PACKAGE_SRC_FILEPATH"    "$PACKAGE_INSTALLING_SRC_DIR"
    esac

    if [ -n "$PACKAGE_FIX_FILETYPE" ] ; then
        case $PACKAGE_FIX_FILETYPE in
            .zip)
                step "uncompressed patch file to the installing fix directory"
                run unzip  "$PACKAGE_FIX_FILEPATH" -d "$PACKAGE_INSTALLING_FIX_DIR"
                ;;
            .txz|.tgz|.tlz|.tbz2)
                step "uncompressed patch file to the installing fix directory"
                run tar xf "$PACKAGE_FIX_FILEPATH" -C "$PACKAGE_INSTALLING_FIX_DIR" --strip-components 1 --no-same-owner
                ;;
            *)  step "copy patch file to the installing fix directory"
                run cp     "$PACKAGE_FIX_FILEPATH"    "$PACKAGE_INSTALLING_FIX_DIR"
        esac
    fi

    if [ -n "$PACKAGE_RES_FILETYPE" ] ; then
        case $PACKAGE_RES_FILETYPE in
            .zip)
                step "uncompressed res file to the installing res directory"
                run unzip "$PACKAGE_RES_FILEPATH" -d "$PACKAGE_INSTALLING_RES_DIR"
                ;;
            .txz|.tgz|.tlz|.tbz2)
                step "uncompressed res file to the installing res directory"
                run tar xf "$PACKAGE_RES_FILEPATH" -C "$PACKAGE_INSTALLING_RES_DIR" --strip-components 1 --no-same-owner
                ;;
            *)  step "copy res file to the installing res directory"
                run cp    "$PACKAGE_RES_FILEPATH"   "$PACKAGE_INSTALLING_RES_DIR"
        esac
    fi

    #########################################################################################

    PACKAGE_BSCRIPT_DIR="$PACKAGE_INSTALLING_SRC_DIR/$PACKAGE_BSCRIPT"
    PACKAGE_BSCRIPT_DIR="${PACKAGE_BSCRIPT_DIR%/}"

    step "tree files of the installing top directory"
    run tree --dirsfirst -L 2 "$PACKAGE_WORKING_DIR"

    step "list files of the installing src directory"
    run ls -l "$PACKAGE_INSTALLING_SRC_DIR"

    if [ -n "$PACKAGE_BSCRIPT" ] ; then
        step "list files of the installing build script directory"
        run ls -l "$PACKAGE_BSCRIPT_DIR"
    fi

    #########################################################################################

    [ "$DRYRUN" = yes ] && {
        [ -z "$SHELL" ] || SHELL=$(command -v zsh || command -v bash || command -v sh) || abort 1 "none of zsh|bash|sh shell found in your system."
        exec "$SHELL"
    }

    #########################################################################################

    # https://www.gnu.org/software/gettext/manual/html_node/config_002eguess.html
    # https://git.savannah.gnu.org/cgit/config.git/tree/

    step "replace config.sub and config.guess with the lastest version"

    {
        [ "$PACKAGE_BUILD_SYSTEM_AUTOGENSH" = yes ] ||
        [ "$PACKAGE_BUILD_SYSTEM_AUTOTOOLS" = yes ] ||
        [ "$PACKAGE_BUILD_SYSTEM_CONFIGURE" = yes ]
    } && {
        for FILENAME in config.sub config.guess
        do
            FILEPATH="$PACKAGE_WORKING_DIR/$FILENAME"

            wfetch "http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=$FILENAME;hb=HEAD" --output-path="$FILEPATH"

            run chmod a+x "$FILEPATH"

            if [ "$FILENAME" = 'config.sub' ] ; then
                sed_in_place 's/arm64-*/arm64-*|arm64e-*/g' "$FILEPATH"
            fi

            find "$PACKAGE_BSCRIPT_DIR" -name "$FILENAME" -exec cp -vf "$FILEPATH" {} \;
        done
    }

    #########################################################################################

    step "build for native"

    if [ -z "$PACKAGE_BUILD0_ACTIONS" ] ; then
        note "build0 mapping was not found in formula, skipped."
    else
        NATIVE_BCACHED_DIR="$PACKAGE_WORKING_DIR/src/-"
        NATIVE_INSTALL_DIR="$NDKPKG_HOME/native/$PACKAGE_NAME"

        cat <<EOF
NATIVE_BCACHED_DIR = $NATIVE_BCACHED_DIR
NATIVE_INSTALL_DIR = $NATIVE_INSTALL_DIR
EOF

        eval "
build0() {
$PACKAGE_BUILD0_ACTIONS
}"

        if [ -f "$NATIVE_INSTALL_DIR/version.txt" ] ; then
            if [ "$(cat "$NATIVE_INSTALL_DIR/version.txt")" != "$PACKAGE_VERSION" ] ; then
                note "build for native already have been done, but not same version. I will remove it then rebuild it."
                run rm -rf "$NATIVE_INSTALL_DIR"
            fi
        fi

        if [ -f "$NATIVE_INSTALL_DIR/version.txt" ] ; then
            note "build for native already have been done, skipped."
        else
            run install -d "$NATIVE_BCACHED_DIR"

            if [ "$PACKAGE_BUILD_IN_BSCRIPT_DIR" = yes ] ; then
                if [ "$PWD" != "$PACKAGE_BSCRIPT_DIR" ] ; then
                    run cd "$PACKAGE_BSCRIPT_DIR"
                fi
            else
                    run cd "$NATIVE_BCACHED_DIR"
            fi

            run build0

            [ -d "$NATIVE_INSTALL_DIR" ] && {
                printf '%s\n' "$PACKAGE_VERSION" > "$NATIVE_INSTALL_DIR/version.txt"

                if [ -d  "$NATIVE_INSTALL_DIR/bin" ] ; then
                    PATH="$NATIVE_INSTALL_DIR/bin:$PATH"
                fi

                if [ -d  "$NATIVE_INSTALL_DIR/sbin" ] ; then
                    PATH="$NATIVE_INSTALL_DIR/sbin:$PATH"
                fi

                if [ -d          "$NATIVE_INSTALL_DIR/share/aclocal" ] ; then
                    ACLOCAL_PATH="$NATIVE_INSTALL_DIR/share/aclocal:$ACLOCAL_PATH"
                fi
            }
        fi
    fi

    #########################################################################################

    if [ "$TARGET_ANDROID_ARCH" = armv7a ] ; then
        TARGET_TRIPLE='armv7a-linux-androideabi'
    else
        TARGET_TRIPLE="$TARGET_ANDROID_ARCH-linux-android"
    fi

    export ANDROID_TARGET="${TARGET_TRIPLE}${TARGET_ANDROID_API}"
    export ANDROID_NDK_CC
    export ANDROID_NDK_CXX
    export ANDROID_NDK_SYSROOT

    #########################################################################################

    step "locate C/C++ toolchain for target build"

    export      CC="${ANDROID_NDK_TOOLCHAIN_BIND}/${TARGET_TRIPLE}${TARGET_ANDROID_API}-clang"
    export     CXX="${ANDROID_NDK_TOOLCHAIN_BIND}/${TARGET_TRIPLE}${TARGET_ANDROID_API}-clang++"
    export     CPP="$CC -E"
    export      LD="$ANDROID_NDK_LD"
    export      AS="$ANDROID_NDK_AS"
    export      AR="$ANDROID_NDK_AR"
    export      NM="$ANDROID_NDK_NM"
    export    SIZE="$ANDROID_NDK_SIZE"
    export   STRIP="$ANDROID_NDK_STRIP"
    export  RANLIB="$ANDROID_NDK_RANLIB"
    export STRINGS="$ANDROID_NDK_STRINGS"
    export OBJDUMP="$ANDROID_NDK_OBJDUMP"
    export OBJCOPY="$ANDROID_NDK_OBJCOPY"
    export READELF="$ANDROID_NDK_READELF"
    export SYSROOT="$ANDROID_NDK_SYSROOT"

    for TOOL in CC CXX CPP AS AR RANLIB LD NM STRIP SIZE STRINGS OBJDUMP OBJCOPY READELF SYSROOT
    do
        printf "%7s = %s\n" "${TOOL}" "$(eval echo \$"${TOOL}")"
    done

    ##################################################################################

    step "create wrapper for C Compiler for target build"

    cat > wrapper-target-cc.c <<EOF
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <regex.h>

#define ACTION_COMPILE 1
#define ACTION_CREATE_SHARED_LIBRARY 2
#define ACTION_CREATE_STATICALLY_LINKED_EXECUTABLE 3
#define ACTION_CREATE_DYNAMICALLY_LINKED_EXECUTABLE 4

int main(int argc, char * argv[]) {
    const char * options[6] = { "-shared", "-static", "--static", "-pie", "-c", "-o" };
          int    indexes[6] = {    -1,         -1,        -1,       -1,    -1,   -1  };

    for (int i = 1; i < argc; i++) {
        for (int j = 0; j < 6; j++) {
            if (strcmp(argv[i], options[j]) == 0) {
                indexes[j] = i;
                break;
            }
        }
    }

    int action = 0;

    if (indexes[0] > 0) {
        // if -shared option is specified, then remove -static , --static , -pie options if they also are specified
        action = ACTION_CREATE_SHARED_LIBRARY;
    } else if ((indexes[1] > 0) || (indexes[2] > 0)) {
        // if -shared option is not specified, but -static or --static option is specified, then remove -pie , -Wl,-Bdynamic option if it also is specified
        action = ACTION_CREATE_STATICALLY_LINKED_EXECUTABLE;
    } else if (indexes[3] > 0) {
        action = ACTION_CREATE_DYNAMICALLY_LINKED_EXECUTABLE;
    }

    /////////////////////////////////////////////////////////////////

#ifdef USED_AS_CXX
    char * const compiler = getenv("ANDROID_NDK_CXX");

    if (compiler == NULL) {
        fprintf(stderr, "ANDROID_NDK_CXX environment variable is not set.\n");
        return 1;
    }

    if (compiler[0] == '\0') {
        fprintf(stderr, "ANDROID_NDK_CXX environment variable value should be a non-empty string.\n");
        return 2;
    }
#else
    char * const compiler = getenv("ANDROID_NDK_CC");

    if (compiler == NULL) {
        fprintf(stderr, "ANDROID_NDK_CC environment variable is not set.\n");
        return 1;
    }

    if (compiler[0] == '\0') {
        fprintf(stderr, "ANDROID_NDK_CC environment variable value should be a non-empty string.\n");
        return 2;
    }
#endif

    /////////////////////////////////////////////////////////////////

    const char * const TARGET = getenv("ANDROID_TARGET");

    if (TARGET == NULL) {
        fprintf(stderr, "ANDROID_TARGET environment variable is not set.\n");
        return 1;
    }

    if (TARGET[0] == '\0') {
        fprintf(stderr, "ANDROID_TARGET environment variable value should be a non-empty string.\n");
        return 2;
    }

    size_t   targetArgLength = strlen(TARGET) + 10U;
    char     targetArg[targetArgLength];
    snprintf(targetArg, targetArgLength, "--target=%s", TARGET);

    /////////////////////////////////////////////////////////////////

    const char * const SYSROOT = getenv("ANDROID_NDK_SYSROOT");

    if (SYSROOT == NULL) {
        fprintf(stderr, "ANDROID_NDK_SYSROOT environment variable is not set.\n");
        return 1;
    }

    if (SYSROOT[0] == '\0') {
        fprintf(stderr, "ANDROID_NDK_SYSROOT environment variable value should be a non-empty string.\n");
        return 2;
    }

    size_t   sysrootArgLength = strlen(SYSROOT) + 11U;
    char     sysrootArg[sysrootArgLength];
    snprintf(sysrootArg, sysrootArgLength, "--sysroot=%s", SYSROOT);

    /////////////////////////////////////////////////////////////////

    char   sonameArg[100] = {0};

    char * argv2[argc + 4];

    argv2[0] = compiler;
    argv2[1] = targetArg;
    argv2[2] = sysrootArg;

    if (action == ACTION_CREATE_SHARED_LIBRARY) {
        for (int i = 1; i < argc; i++) {
            if (strcmp(argv[i], "-static") == 0) {
                argv2[i + 2] = (char*)"--shared";
            } else if (strcmp(argv[i], "--static") == 0) {
                argv2[i + 2] = (char*)"--shared";
            } else if (strcmp(argv[i], "-pie") == 0) {
                argv2[i + 2] = (char*)"--shared";
            } else {
                argv2[i + 2] = argv[i];
            }
        }

        char * filepath = NULL;
        char * filename = NULL;

        if (indexes[5] == -1) {
            // It's rare to see. like -o/a/b/libxx.so.1
            for (int i = 1; i < argc; i++) {
                if (strncmp(argv[i], "-o", 2) == 0) {
                    indexes[5] = i;
                    filepath = &argv[i][2];
                    break;
                }
            }
        } else {
            // if -o <FILE> option is specified.
            int i = indexes[5] + 1;

            if (i < argc) {
                filepath = argv[i];
            }
        }

        if (filepath != NULL) {
            int len = 0;

            for (;;) {
                if (filepath[len] == '\0') {
                    break;
                } else {
                    len++;
                }
            }

            for (int i = len - 1; i > 0; i--) {
                if (filepath[i] == '/') {
                    filename = filepath + i + 1;
                    break;
                }
            }

            if (filename == NULL) {
                filename = filepath;
            }

            regex_t regex;

            if (regcomp(&regex, "^lib.*\\\\.so", 0) != 0) {
                perror(NULL);
                regfree(&regex);
                return 1;
            }

            regmatch_t regmatch[2];

            if (regexec(&regex, filename, 2, regmatch, 0) == 0) {
                //printf("regmatch[0].rm_so=%d\n", regmatch[0].rm_so);
                //printf("regmatch[0].rm_eo=%d\n", regmatch[0].rm_eo);

                if ((regmatch[0].rm_so >= 0) && (regmatch[0].rm_eo > regmatch[0].rm_so)) {
                    int n = regmatch[0].rm_eo - regmatch[0].rm_so;
                    const char * str = &filename[regmatch[0].rm_so];
                    snprintf(sonameArg, n + 13, "-Wl,-soname,%s", str);
                }
            }

            regfree(&regex);
        }
    } else if (action == ACTION_CREATE_STATICALLY_LINKED_EXECUTABLE) {
        for (int i = 1; i < argc; i++) {
            if (strcmp(argv[i], "-rdynamic") == 0) {
                argv2[i + 2] = (char*)"-static";
            } else if (strcmp(argv[i], "-Wl,--export-dynamic") == 0) {
                argv2[i + 2] = (char*)"-static";
            } else if (strcmp(argv[i], "-Wl,-Bdynamic") == 0) {
                argv2[i + 2] = (char*)"-static";
            } else if (strcmp(argv[i], "-pie") == 0) {
                argv2[i + 2] = (char*)"-static";
            } else {
                argv2[i + 2] = argv[i];
            }
        }
    } else {
        for (int i = 1; i < argc; i++) {
            argv2[i + 2] = argv[i];
        }
    }

    if (sonameArg[0] == '\0') {
        argv2[argc + 2] = NULL;
    } else {
        argv2[argc + 2] = sonameArg;
        argv2[argc + 3] = NULL;
    }

    execv (compiler, argv2);
    perror(compiler);
    return -1;
}
EOF

    WRAPPER_CC="$NDKPKG_CORE_DIR/libexec/wrapper-target-cc"

    run "$CC_FOR_BUILD" -UUSED_AS_CXX -std=c99 -o "$WRAPPER_CC" wrapper-target-cc.c

    ##################################################################################

    step "create wrapper for C++ Compiler for target build"

    WRAPPER_CXX="$NDKPKG_CORE_DIR/libexec/wrapper-target-c++"

    run "$CC_FOR_BUILD" -DUSED_AS_CXX -std=c99 -o "$WRAPPER_CXX" wrapper-target-cc.c

    #########################################################################################

    export CC="$WRAPPER_CC"
    export CXX="$WRAPPER_CXX"
    export CPP="$CC -E"

cat <<EOF
    CC  = $CC
    CPP = $CPP
    CXX = $CXX
EOF

    #########################################################################################

    TARGET_TRIPLE2=$(printf '%s\n' "$TARGET_TRIPLE" | sed 's/armv7a/arm/')

    SYSTEM_INCLUDE_DIR="$SYSROOT/usr/include"
    SYSTEM_LIBRARY_DIR="$SYSROOT/usr/lib/$TARGET_TRIPLE2"

    NDKPKG_COMMON_H_FILEPATH="$PACKAGE_INSTALLING_INC_DIR/ndk-pkg-common.h"

    #########################################################################################

    step "config CFLAGS CXXFLAGS CPPFLAGS LDFLAGS"

    CCFLAGS="--sysroot $SYSROOT -Qunused-arguments -fPIC"
    XXFLAGS="--sysroot $SYSROOT -Qunused-arguments -fPIC"
    PPFLAGS="--sysroot $SYSROOT -Qunused-arguments -include $NDKPKG_COMMON_H_FILEPATH"
    LDFLAGS="--sysroot $SYSROOT -Wl,--as-needed -Wl,-z,muldefs -Wl,--allow-multiple-definition"

    CCFLAGS="$CCFLAGS $PACKAGE_CCFLAGS"
    XXFLAGS="$XXFLAGS $PACKAGE_XXFLAGS"
    PPFLAGS="$PPFLAGS $PACKAGE_PPFLAGS"
    LDFLAGS="$LDFLAGS $PACKAGE_LDFLAGS"

    ##############################################

    _F_COMMON_OPT_IS_SET=no

    for item in $PACKAGE_CCFLAGS
    do
        [ "$item" = '-fcommon' ] && {
            _F_COMMON_OPT_IS_SET=yes
            break
        }
    done

    if [ "$_F_COMMON_OPT_IS_SET" = no ] ; then
        CCFLAGS="$CCFLAGS -fno-common"
    fi

    ##############################################

    _F_COMMON_OPT_IS_SET=no

    for item in $PACKAGE_XXFLAGS
    do
        [ "$item" = '-fcommon' ] && {
            _F_COMMON_OPT_IS_SET=yes
            break
        }
    done

    if [ "$_F_COMMON_OPT_IS_SET" = no ] ; then
        XXFLAGS="$XXFLAGS -fno-common"
    fi

    ##############################################

    CCFLAGS="$(printf '%s\n' "$CCFLAGS" | sed -e 's|--static||g' -e 's|-static||g')"
    XXFLAGS="$(printf '%s\n' "$XXFLAGS" | sed -e 's|--static||g' -e 's|-static||g')"
    LDFLAGS="$(printf '%s\n' "$LDFLAGS" | sed -e 's|--static||g' -e 's|-static||g')"

    ##############################################

    if [ "$LINK_TYPE" = 'static-only' ] ; then
        LDFLAGS="$LDFLAGS -static --static -ffunction-sections -fdata-sections -Wl,--gc-sections -Wl,--no-dynamic-linker"
    fi

    ##############################################

    if [ "$LOG_LEVEL" -ge 3 ] ; then
        CCFLAGS="$CCFLAGS -v"
        XXFLAGS="$XXFLAGS -v"
        LDFLAGS="$LDFLAGS -Wl,-v"
    fi

    if [ "$BUILD_TYPE" = release ] ; then
        PPFLAGS="$PPFLAGS -DNDEBUG"
        CCFLAGS="$CCFLAGS -Os"
        XXFLAGS="$XXFLAGS -Os"
        LDFLAGS="$LDFLAGS -Wl,-S"
    fi

    ##############################################

    for DEPENDENT_PACKAGE_NAME in $RECURSIVE_DEPENDENT_PACKAGE_NAMES
    do
        DEPENDENT_PACKAGE_NAME_UNDERSCORE=$(printf '%s\n' "$DEPENDENT_PACKAGE_NAME" | tr '@+-.' '_')

        DEPENDENT_PACKAGE_INSTALL_DIR="$(readlink -f "$NDKPKG_PACKAGE_INSTALLED_ROOT/$DEPENDENT_PACKAGE_NAME:$TARGET_ANDROID_SPEC")"
        DEPENDENT_PACKAGE_BINARY__DIR="$DEPENDENT_PACKAGE_INSTALL_DIR/bin"
        DEPENDENT_PACKAGE_INCLUDE_DIR="$DEPENDENT_PACKAGE_INSTALL_DIR/include"
        DEPENDENT_PACKAGE_LIBRARY_DIR="$DEPENDENT_PACKAGE_INSTALL_DIR/lib"
        DEPENDENT_PACKAGE_PKGCONF_DIR="$DEPENDENT_PACKAGE_INSTALL_DIR/lib/pkgconfig"

        eval "${DEPENDENT_PACKAGE_NAME_UNDERSCORE}_INSTALL_DIR='$DEPENDENT_PACKAGE_INSTALL_DIR'"
        eval "${DEPENDENT_PACKAGE_NAME_UNDERSCORE}_BINARY__DIR='$DEPENDENT_PACKAGE_BINARY__DIR'"
        eval "${DEPENDENT_PACKAGE_NAME_UNDERSCORE}_INCLUDE_DIR='$DEPENDENT_PACKAGE_INCLUDE_DIR'"
        eval "${DEPENDENT_PACKAGE_NAME_UNDERSCORE}_LIBRARY_DIR='$DEPENDENT_PACKAGE_LIBRARY_DIR'"

        if [ -d "$DEPENDENT_PACKAGE_INCLUDE_DIR" ] ; then
            PPFLAGS="-I$DEPENDENT_PACKAGE_INCLUDE_DIR $PPFLAGS"
        fi

        if [ -d "$DEPENDENT_PACKAGE_LIBRARY_DIR" ] ; then
            LDFLAGS="-L$DEPENDENT_PACKAGE_LIBRARY_DIR -Wl,-rpath-link,$DEPENDENT_PACKAGE_LIBRARY_DIR $LDFLAGS"
        fi
    done

    PPFLAGS="-I$PACKAGE_INSTALLING_INC_DIR $PPFLAGS"
    LDFLAGS="-L$PACKAGE_INSTALLING_LIB_DIR $LDFLAGS"

    for DEPENDENT_PACKAGE_NAME in $PACKAGE_DEP_PKG
    do
        # https://android.googlesource.com/platform/bionic/+/master/docs/status.md

        if [ "$DEPENDENT_PACKAGE_NAME" = libexecinfo ] ; then
            if [ "$TARGET_ANDROID_API" -lt 33 ] ; then
                # https://android.googlesource.com/platform/bionic/+/master/libc/include/execinfo.h
                # https://android.googlesource.com/platform/bionic/+/master/libc/bionic/execinfo.cpp
                CPPFLAGS="$CPPFLAGS -include $libexecinfo_INCLUDE_DIR/execinfo.h"
                LDFLAGS="$LDFLAGS -l:libexecinfo.a"
            fi
        fi

        if [ "$DEPENDENT_PACKAGE_NAME" = libgetloadavg ] ; then
            if [ "$TARGET_ANDROID_API" -lt 29 ] ; then
                # https://android.googlesource.com/platform/bionic/+/master/libc/include/stdlib.h#157
                # https://android.googlesource.com/platform/bionic/+/master/libc/bionic/getloadavg.cpp
                # int getloadavg(double __averages[], int __n) __INTRODUCED_IN(29);
                CPPFLAGS="$CPPFLAGS -include $libgetloadavg_INCLUDE_DIR/getloadavg.h"
                LDFLAGS="$LDFLAGS -l:libgetloadavg.a"
            fi
        fi

        if [ "$DEPENDENT_PACKAGE_NAME" = libglob ] ; then
            # https://pubs.opengroup.org/onlinepubs/9699919799/functions/glob.html
            # https://android.googlesource.com/platform/bionic/+/master/libc/include/glob.h
            if [ "$TARGET_ANDROID_API" -lt 28 ] ; then
                LDFLAGS="$LDFLAGS -l:libglob.a"
            fi
        fi

        if [ "$DEPENDENT_PACKAGE_NAME" = liblanginfo ] ; then
            # https://pubs.opengroup.org/onlinepubs/9699919799/functions/nl_langinfo.html
            # https://android.googlesource.com/platform/bionic/+/master/libc/include/langinfo.h
            if [ "$TARGET_ANDROID_API" -lt 26 ] ; then
                LDFLAGS="$LDFLAGS -l:liblanginfo.a"
            fi
        fi

        if [ "$DEPENDENT_PACKAGE_NAME" = libmblen ] ; then
            # https://android.googlesource.com/platform/bionic/+/master/libc/include/stdlib.h#163
            # https://android.googlesource.com/platform/bionic/+/master/libc/bionic/mblen.cpp
            # int mblen(const char* __s, size_t __n) __INTRODUCED_IN_NO_GUARD_FOR_NDK(26);
            if [ "$TARGET_ANDROID_API" -lt 26 ] ; then
                CPPFLAGS="$CPPFLAGS -include $libmblen_INCLUDE_DIR/mblen.h"
                LDFLAGS="$LDFLAGS -l:libmblen.a"
            fi
        fi

        if [ "$DEPENDENT_PACKAGE_NAME" = libgetdomainname ] ; then
            # https://android.googlesource.com/platform/bionic/+/master/libc/include/unistd.h#313
            # https://android.googlesource.com/platform/bionic/+/master/libc/bionic/getdomainname.cpp
            # int getdomainname(char* __buf, size_t __buf_size) __INTRODUCED_IN(26);
            if [ "$TARGET_ANDROID_API" -lt 26 ] ; then
                CPPFLAGS="$CPPFLAGS -include $libgetdomainname_INCLUDE_DIR/getdomainname.h"
                LDFLAGS="$LDFLAGS -l:libgetdomainname.a"
            fi
        fi

        if [ "$DEPENDENT_PACKAGE_NAME" = libstrchrnul ] ; then
            # https://android.googlesource.com/platform/bionic/+/master/libc/include/string.h#68
            # char* strchrnul(char* __s, int __ch) __RENAME(strchrnul) __attribute_pure__ __INTRODUCED_IN(24);
            if [ "$TARGET_ANDROID_API" -lt 24 ] ; then
                CPPFLAGS="$CPPFLAGS -include $libstrchrnul_INCLUDE_DIR/strchrnul.h"
                LDFLAGS="$LDFLAGS -l:libstrchrnul.a"
            fi
        fi

        if [ "$DEPENDENT_PACKAGE_NAME" = libgetdtablesize ] ; then
            CPPFLAGS="$CPPFLAGS -include $libgetdtablesize_INCLUDE_DIR/getdtablesize.h"
            # https://android.googlesource.com/platform/bionic/+/72dc1c22dc6a92dea925398c9e3880364ab29c1c/libc/bionic/getdtablesize.c
            LDFLAGS="$LDFLAGS -l:libgetdtablesize.a"
        fi
    done

    export   CFLAGS="$CCFLAGS"
    export CXXFLAGS="$XXFLAGS"
    export CPPFLAGS="$PPFLAGS"
    export  LDFLAGS="$LDFLAGS"

    printf '%b\n' "${COLOR_PURPLE}==>${COLOR_OFF} CFLAGS"
    printf '%s\n' "$CFLAGS" | xargs printf '        %s\n'
    printf '\n'

    printf '%b\n' "${COLOR_PURPLE}==>${COLOR_OFF} CXXFLAGS"
    printf '%s\n' "$CXXFLAGS" | xargs printf '        %s\n'
    printf '\n'

    printf '%b\n' "${COLOR_PURPLE}==>${COLOR_OFF} CPPFLAGS"
    printf '%s\n' "$CPPFLAGS" | xargs printf '        %s\n'
    printf '\n'

    printf '%b\n' "${COLOR_PURPLE}==>${COLOR_OFF} LDFLAGS"
    printf '%s\n' "$LDFLAGS" | xargs printf '        %s\n'

    #########################################################################################

    step "list XDG_DATA_DIRS"

    # https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html
    export XDG_DATA_DIRS

    for DEPENDENT_PACKAGE_INSTALL_DIR in $RECURSIVE_DEPENDENT_PACKAGE_INSTALL_DIRS
    do
        # https://gi.readthedocs.io/en/latest/tools/g-ir-scanner.html#environment-variables
        if [ -d "$DEPENDENT_PACKAGE_INSTALL_DIR/share/gir-1.0" ] ; then
            if [ -z "$XDG_DATA_DIRS" ] ; then
                XDG_DATA_DIRS="$DEPENDENT_PACKAGE_INSTALL_DIR/share"
            else
                XDG_DATA_DIRS="$DEPENDENT_PACKAGE_INSTALL_DIR/share:$XDG_DATA_DIRS"
            fi
        fi

        # https://help.gnome.org/admin//system-admin-guide/2.32/mimetypes-database.html.en
        if [ -d "$DEPENDENT_PACKAGE_INSTALL_DIR/share/mime" ] ; then
            if [ -z "$XDG_DATA_DIRS" ] ; then
                XDG_DATA_DIRS="$DEPENDENT_PACKAGE_INSTALL_DIR/share"
            else
                XDG_DATA_DIRS="$DEPENDENT_PACKAGE_INSTALL_DIR/share:$XDG_DATA_DIRS"
            fi
        fi
    done

    printf '%s\n' "$XDG_DATA_DIRS" | tr : '\n'

    #########################################################################################

    step "list ACLOCAL_PATH"

    # https://www.gnu.org/software/automake/manual/html_node/Macro-Search-Path.html
    export ACLOCAL_PATH

    for DEPENDENT_PACKAGE_INSTALL_DIR in $RECURSIVE_DEPENDENT_PACKAGE_INSTALL_DIRS
    do
        DEPENDENT_PACKAGE_ACLOCAL_PATH="$DEPENDENT_PACKAGE_INSTALL_DIR/share/aclocal"

        if [ -d "$DEPENDENT_PACKAGE_ACLOCAL_PATH" ] ; then
            if [ -z "$ACLOCAL_PATH" ] ; then
                ACLOCAL_PATH="$DEPENDENT_PACKAGE_ACLOCAL_PATH"
            else
                ACLOCAL_PATH="$DEPENDENT_PACKAGE_ACLOCAL_PATH:$ACLOCAL_PATH"
            fi
        fi
    done

    printf '%s\n' "$ACLOCAL_PATH" | tr : '\n'

    #########################################################################################

    step "list PATH"

    PATH="$PACKAGE_INSTALLING_BIN_DIR:$ANDROID_NDK_HOME:$PATH"

    printf '%s\n' "$PATH" | tr : '\n'

    #########################################################################################

    step "config environment variables for pkg-config"

    if [ "$LOG_LEVEL" -ge 3 ] ; then
        export PKG_CONFIG_DEBUG_SPEW='set'
    fi

    # override the default search directory (usually /usr/lib/pkgconfig:/usr/share/pkgconfig)
    # because we only want to use our own
    export PKG_CONFIG_LIBDIR="$PACKAGE_WORKING_DIR/lib/pkgconfig"
    export PKG_CONFIG_PATH="$PACKAGE_WORKING_DIR/lib/pkgconfig"

    for DEPENDENT_PACKAGE_INSTALL_DIR in $RECURSIVE_DEPENDENT_PACKAGE_INSTALL_DIRS
    do
        for d in lib share
        do
            DEPENDENT_PACKAGE_PKGCONF_DIR="$DEPENDENT_PACKAGE_INSTALL_DIR/$d/pkgconfig"

            if [ -d "$DEPENDENT_PACKAGE_PKGCONF_DIR" ] ; then
                PKG_CONFIG_PATH="$PKG_CONFIG_PATH:$DEPENDENT_PACKAGE_PKGCONF_DIR"
            fi
        done
    done

    printf 'PKG_CONFIG_DEBUG_SPEW = %s\n' "$PKG_CONFIG_DEBUG_SPEW"

    printf 'PKG_CONFIG          = %s\n' "$PKG_CONFIG"

    printf 'PKG_CONFIG_LIBDIR   = %s\n' "$PKG_CONFIG_LIBDIR"

    export IFS=':'

    FIRST=yes

    for item in $(printf '%s\n' "$PKG_CONFIG_PATH")
    do
        if [ "$FIRST" = yes ] ; then
            FIRST=no
            printf 'PKG_CONFIG_PATH     = %s\n' "$item"
        else
            printf '%s\n' "                      $item"
        fi
    done

    unset IFS

    #########################################################################################

    if [ "$PACKAGE_BUILD_SYSTEM_CMAKE" = yes ] ; then
        step "config environment variables for cmake"

        # https://cmake.org/cmake/help/latest/manual/cmake-env-variables.7.html#manual:cmake-env-variables(7)

        unset CMAKE_PREFIX_PATH
        unset CMAKE_APPLE_SILICON_PROCESSOR
        unset CMAKE_BUILD_PARALLEL_LEVEL
        unset CMAKE_BUILD_TYPE
        unset CMAKE_CONFIGURATION_TYPES
        unset CMAKE_CONFIG_TYPE
        unset CMAKE_EXPORT_COMPILE_COMMANDS
        unset CMAKE_GENERATOR
        unset CMAKE_GENERATOR_INSTANCE
        unset CMAKE_GENERATOR_PLATFORM
        unset CMAKE_GENERATOR_TOOLSET
        unset CMAKE_INSTALL_MODE
        unset CMAKE_C_COMPILER_LAUNCHER
        unset CMAKE_C_LINKER_LAUNCHER
        unset CMAKE_CXX_COMPILER_LAUNCHER
        unset CMAKE_CXX_LINKER_LAUNCHER
        unset CMAKE_MSVCIDE_RUN_PATH
        unset CMAKE_NO_VERBOSE
        unset CMAKE_OSX_ARCHITECTURES
        unset CMAKE_TOOLCHAIN_FILE
        unset DESTDIR
        unset CTEST_INTERACTIVE_DEBUG_MODE
        unset CTEST_OUTPUT_ON_FAILURE
        unset CTEST_PARALLEL_LEVEL
        unset CTEST_PROGRESS_OUTPUT
        unset CTEST_USE_LAUNCHERS_DEFAULT
        unset DASHBOARD_TEST_FROM_CTEST

        # https://cmake.org/cmake/help/latest/envvar/CMAKE_BUILD_PARALLEL_LEVEL.html
        export CMAKE_BUILD_PARALLEL_LEVEL="$BUILD_NJOBS"

        # https://cmake.org/cmake/help/latest/envvar/CMAKE_GENERATOR.html
        if [ "$PACKAGE_BUILD_SYSTEM_NINJA" = yes ] ; then
            export CMAKE_GENERATOR='Ninja'
        else
            export CMAKE_GENERATOR='Unix Makefiles'
        fi

        # https://cmake.org/cmake/help/latest/envvar/CMAKE_EXPORT_COMPILE_COMMANDS.html
        if [ "$EXPORT_COMPILE_COMMANDS_JSON" = yes ] ; then
            export CMAKE_EXPORT_COMPILE_COMMANDS=ON
        else
            export CMAKE_EXPORT_COMPILE_COMMANDS=OFF
        fi

        case $BUILD_TYPE in
            debug)   CMAKE_BUILD_TYPE=Debug   ;;
            release) CMAKE_BUILD_TYPE=Release ;;
        esac

        if [ "$LOG_LEVEL" -eq 0 ] ; then
            CMAKE_VERBOSE_MAKEFILE=OFF
            CMAKE_COLOR_MAKEFILE=OFF
        else
            CMAKE_VERBOSE_MAKEFILE=ON
            CMAKE_COLOR_MAKEFILE=ON
        fi

        # https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_DEBUG_MODE.html
        if [ "$LOG_LEVEL" -ge 3 ] ; then
            CMAKE_FIND_DEBUG_MODE=ON
        else
            CMAKE_FIND_DEBUG_MODE=OFF
        fi

        CMAKE_TOOLCHAIN_FILE="$PACKAGE_WORKING_DIR/toolchain.cmake"

        # https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_ROOT_PATH.html
        unset CMAKE_FIND_ROOT_PATH

        if [ -n "$PACKAGE_DEP_PKG" ] ; then
            CMAKE_FIND_ROOT_PATH="$(printf '%s\n' "$RECURSIVE_DEPENDENT_PACKAGE_INSTALL_DIRS" | tr ' ' ';')"
        fi

        env | sed -n '/^CMAKE_/p'
    fi

    #########################################################################################

    if [ "$PACKAGE_BUILD_SYSTEM_CARGO" = yes ] ; then
        step "config environment variables for cargo and rustc"

        # https://docs.rs/backtrace/latest/backtrace/
        export RUST_BACKTRACE=1

        # this environment variable is not defined by Rust, but it is widely used by third-party project.
        case $TARGET_ANDROID_ARCH in
            armv7a)  export RUST_TARGET='armv7-linux-androideabi' ;;
            aarch64) export RUST_TARGET='aarch64-linux-android'   ;;
            i686)    export RUST_TARGET='i686-linux-android'      ;;
            x86_64)  export RUST_TARGET='x86_64-linux-android'    ;;
        esac

        RUST_TARGET_UPPERCASE_UNDERSCORE=$(printf '%s\n' "$RUST_TARGET" | tr a-z A-Z | tr - _)

        # https://doc.rust-lang.org/cargo/reference/config.html#environment-variables
        # https://doc.rust-lang.org/cargo/reference/environment-variables.html
        export "CARGO_TARGET_${RUST_TARGET_UPPERCASE_UNDERSCORE}_AR"="$AR"
        export "CARGO_TARGET_${RUST_TARGET_UPPERCASE_UNDERSCORE}_LINKER"="$CC"

        export CARGO_BUILD_JOBS="$BUILD_NJOBS"

        unset RUSTFLAGS

        if [ "$LINK_TYPE" = 'static-only' ] ; then
            run "echo '!<arch>' > '$PACKAGE_WORKING_DIR/lib/liblog.a'"

            RUSTFLAGS="$RUSTFLAGS -Clink-arg=-static -Clink-arg=-ffunction-sections -Clink-arg=-fdata-sections -Clink-arg=-Wl,--gc-sections -Clink-arg=-Wl,--no-dynamic-linker"
        fi

        for DEPENDENT_PACKAGE_INSTALL_DIR in $RECURSIVE_DEPENDENT_PACKAGE_INSTALL_DIRS
        do
            DEPENDENT_PACKAGE_LIBRARY_DIR="$DEPENDENT_PACKAGE_INSTALL_DIR/lib"

            if [ -d "$DEPENDENT_PACKAGE_LIBRARY_DIR" ] ; then
                RUSTFLAGS="-Clink-arg=-L$DEPENDENT_PACKAGE_LIBRARY_DIR -Clink-arg=-Wl,-rpath-link,$DEPENDENT_PACKAGE_LIBRARY_DIR $RUSTFLAGS"
            fi
        done

        # https://doc.rust-lang.org/rustc/codegen-options/index.html#link-arg
        export RUSTFLAGS="-Clinker=$CC -Clink-arg=-L$PACKAGE_WORKING_DIR/lib $RUSTFLAGS"

        for DEPENDENT_PACKAGE_NAME in $PACKAGE_DEP_PKG
        do
            if [ "$DEPENDENT_PACKAGE_NAME" = libgetloadavg ] ; then
                if [ "$TARGET_ANDROID_API" -lt 29 ] ; then
                    # https://android.googlesource.com/platform/bionic/+/master/libc/include/stdlib.h#157
                    # https://android.googlesource.com/platform/bionic/+/master/libc/bionic/getloadavg.cpp
                    # int getloadavg(double __averages[], int __n) __INTRODUCED_IN(29);
                    # CPPFLAGS="$CPPFLAGS -include $libgetloadavg_INCLUDE_DIR/getloadavg.h"
                    export RUSTFLAGS="$RUSTFLAGS -Clink-arg=$libgetloadavg_LIBRARY_DIR/libgetloadavg.a"
                fi
            fi

            if [ "$DEPENDENT_PACKAGE_NAME" = libglob ] ; then
                # https://pubs.opengroup.org/onlinepubs/9699919799/functions/glob.html
                # https://android.googlesource.com/platform/bionic/+/master/libc/include/glob.h
                if [ "$TARGET_ANDROID_API" -lt 28 ] ; then
                    export RUSTFLAGS="$RUSTFLAGS -Clink-arg=$libglob_LIBRARY_DIR/libglob.a"
                fi
            fi

            if [ "$DEPENDENT_PACKAGE_NAME" = liblanginfo ] ; then
                # https://pubs.opengroup.org/onlinepubs/9699919799/functions/nl_langinfo.html
                # https://android.googlesource.com/platform/bionic/+/master/libc/include/langinfo.h
                if [ "$TARGET_ANDROID_API" -lt 26 ] ; then
                    export RUSTFLAGS="$RUSTFLAGS -Clink-arg=$liblanginfo_LIBRARY_DIR/liblanginfo.a"
                fi
            fi

            if [ "$DEPENDENT_PACKAGE_NAME" = libmblen ] ; then
                # https://android.googlesource.com/platform/bionic/+/master/libc/include/stdlib.h#163
                # https://android.googlesource.com/platform/bionic/+/master/libc/bionic/mblen.cpp
                # int mblen(const char* __s, size_t __n) __INTRODUCED_IN_NO_GUARD_FOR_NDK(26);
                if [ "$TARGET_ANDROID_API" -lt 26 ] ; then
                    CPPFLAGS="$CPPFLAGS -include $libmblen_INCLUDE_DIR/mblen.h"
                    export RUSTFLAGS="$RUSTFLAGS -Clink-arg=$libmblen_LIBRARY_DIR/libmblen.a"
                fi
            fi

            if [ "$DEPENDENT_PACKAGE_NAME" = libgetdomainname ] ; then
                # https://android.googlesource.com/platform/bionic/+/master/libc/include/unistd.h#313
                # https://android.googlesource.com/platform/bionic/+/master/libc/bionic/getdomainname.cpp
                # int getdomainname(char* __buf, size_t __buf_size) __INTRODUCED_IN(26);
                if [ "$TARGET_ANDROID_API" -lt 26 ] ; then
                    # CPPFLAGS="$CPPFLAGS -include $libgetdomainname_INCLUDE_DIR/getdomainname.h"
                    export RUSTFLAGS="$RUSTFLAGS -Clink-arg=$libgetdomainname_LIBRARY_DIR/libgetdomainname.a"
                fi
            fi

            if [ "$DEPENDENT_PACKAGE_NAME" = libstrchrnul ] ; then
                # https://android.googlesource.com/platform/bionic/+/master/libc/include/string.h#68
                # char* strchrnul(char* __s, int __ch) __RENAME(strchrnul) __attribute_pure__ __INTRODUCED_IN(24);
                if [ "$TARGET_ANDROID_API" -lt 24 ] ; then
                    # CPPFLAGS="$CPPFLAGS -include $libstrchrnul_INCLUDE_DIR/strchrnul.h"
                    export RUSTFLAGS="$RUSTFLAGS -Clink-arg=$libstrchrnul_LIBRARY_DIR/libstrchrnul.a"
                fi
            fi

            if [ "$DEPENDENT_PACKAGE_NAME" = libgetdtablesize ] ; then
                # CPPFLAGS="$CPPFLAGS -include $libgetdtablesize_INCLUDE_DIR/getdtablesize.h"
                # https://android.googlesource.com/platform/bionic/+/72dc1c22dc6a92dea925398c9e3880364ab29c1c/libc/bionic/getdtablesize.c
                export RUSTFLAGS="$RUSTFLAGS -Clink-arg=$libgetdtablesize_LIBRARY_DIR/libgetdtablesize.a"
            fi
        done

        env | grep CARGO_
        env | grep RUST_

        printf '%b\n' "${COLOR_PURPLE}==>${COLOR_OFF} RUSTFLAGS"
        printf '%s\n' "$RUSTFLAGS" | xargs printf '        %s\n'

        for item in $RECURSIVE_DEPENDENT_PACKAGE_NAMES
        do
            case $item in
                openssl)
                    # https://docs.rs/openssl/0.10.35/openssl/
                    export OPENSSL_DIR="$openssl_INSTALL_DIR"
                    ;;
                openssl@1.1)
                    # https://docs.rs/openssl/0.10.35/openssl/
                    export OPENSSL_DIR="$openssl_1_1_INSTALL_DIR"
                    ;;
            esac
        done

        # https://libraries.io/cargo/cc
        # https://crates.io/crates/cc
        # https://docs.rs/cc/latest/cc/
        # https://github.com/alexcrichton/cc-rs
        export HOST_CC="$CC_FOR_BUILD"
        export HOST_CFLAGS="$CFLAGS_FOR_BUILD"

        export HOST_CXX="$CXX_FOR_BUILD"
        export HOST_CXXFLAGS="$CXXFLAGS_FOR_BUILD"

        export HOST_AR="$AR_FOR_BUILD"

        export TARGET_CC="$CC"
        export TARGET_CFLAGS="$CFLAGS $CPPFLAGS $LDFLAGS"

        export TARGET_CXX="$CXX"
        export TARGET_CXXFLAGS="$CXXFLAGS $CPPFLAGS $LDFLAGS"

        export TARGET_AR="$AR"


        # https://libraries.io/cargo/pkg-config
        # https://crates.io/crates/pkg-config
        # https://docs.rs/pkg-config/latest/pkg_config/
        # https://github.com/rust-lang/pkg-config-rs
        export TARGET_PKG_CONFIG_ALLOW_CROSS=1


        # https://libraries.io/cargo/cmake
        # https://crates.io/crates/cmake
        # https://docs.rs/cmake/latest/cmake/
        # https://github.com/alexcrichton/cmake-rs
        # this variable is not motioned in their document. you must read the source code of cmake-rs crate.
        export TARGET_CMAKE_TOOLCHAIN_FILE="$PACKAGE_WORKING_DIR/android.toolchain.cmake"

        cat > "$TARGET_CMAKE_TOOLCHAIN_FILE" <<EOF
set(TARGET_ANDROID_ABI "${TARGET_ANDROID_ABI}")
set(ANDROID_PLATFORM "android-${TARGET_ANDROID_API}")
include(${ANDROID_NDK_HOME}/build/cmake/android.toolchain.cmake)
EOF
    fi

    #########################################################################################

    if [ "$PACKAGE_BUILD_SYSTEM_GO" = yes ] ; then
        step "config environment variables for go"

        # https://pkg.go.dev/cmd/cgo
        export CGO_ENABLED=1
        export CGO_CFLAGS="$CFLAGS"
        export CGO_CXXFLAGS="$CXXFLAGS"
        export CGO_CPPFLAGS="$CPPFLAGS"
        export CGO_LDFLAGS="$LDFLAGS"

        # https://go.dev/blog/go116-module-changes
        export GO111MODULE='auto'

        if [ "$COUNTRY" = china ] ; then
            export GOPROXY='https://goproxy.cn'
        fi

        # https://golang.org/doc/install/source#environment
        export GOOS='android'

        case $TARGET_ANDROID_ARCH in
            armv7a)  export GOARCH=arm   ;;
            aarch64) export GOARCH=arm64 ;;
            i686)    export GOARCH=386   ;;
            x86_64)  export GOARCH=amd64 ;;
        esac

        if [ "$LINK_TYPE" = 'static-only' ] ; then
            run "echo '!<arch>' > '$PACKAGE_WORKING_DIR/lib/liblog.a'"
        fi
    fi

    #########################################################################################

    [ "$LOG_LEVEL" -ge 3 ] && {
        step "show export variables"
        run export -p
        echo
    }

    #########################################################################################

    step "create ndk-pkg-common.h"

    # https://pubs.opengroup.org/onlinepubs/000095399/functions/rindex.html
    # https://pubs.opengroup.org/onlinepubs/000095399/functions/bcmp.html
    # https://linux.die.net/man/2/wait3
    # https://stackoverflow.com/questions/32826175/ftello-and-fseeko-android-build-errors
    # https://linux.die.net/man/3/ftello
    # int   fseeko(FILE* __fp, off_t __offset, int __whence) __RENAME(fseeko64) __INTRODUCED_IN(24);
    # off_t ftello(FILE* __fp) __RENAME(ftello64) __INTRODUCED_IN(24);

    cat > "$NDKPKG_COMMON_H_FILEPATH" <<EOF
#ifndef NDKPKG_COMMON_H
#define NDKPKG_COMMON_H

#define rindex(a,b) strrchr((a),(b))

#define bcmp(b1,b2,len) memcmp((b1), (b2), (size_t)(len))

#define wait3(status,options,rusage) waitpid(-1,status,options)

#if __ANDROID_API__ < 24
    #define ftello(f) ftell(f)
    #define fseeko    fseek
#endif

#endif
EOF

    if command -v bat > /dev/null ; then
        run bat --style=plain --paging=never "$NDKPKG_COMMON_H_FILEPATH"
    else
        run cat "$NDKPKG_COMMON_H_FILEPATH"
    fi

    #########################################################################################

    if false ; then
    #if [ -n "$PACKAGE_LICENSE" ] ; then
        step "copy or fetch licenses"

        I=0

        for item in $PACKAGE_LICENSE
        do
            unset LICENSE_PATH
            unset LICENSE_URL_

            I=$(expr "$I" + 1)

            case $item in
                *\|*)
                    LICENSE_PATH="$(printf '%s\n' "$item" | cut -d '|' -f2)"
                    LICENSE_URL_="$(printf '%s\n' "$item" | cut -d '|' -f3)"
                    ;;
                *)  LICENSE_URL_="https://raw.githubusercontent.com/spdx/license-list-data/master/text/$item.txt"
            esac

            # https://github.com/spdx/license-list-data

            if [ -z "$LICENSE_PATH" ] ; then
                wfetch "$LICENSE_URL_"  --output-dir="$PACKAGE_WORKING_DIR" --output-name="LICENSE$I"
            else
                cp "$PACKAGE_INSTALLING_SRC_DIR/$LICENSE_PATH" "$PACKAGE_WORKING_DIR/LICENSE$I"
            fi
        done

        unset LICENSE_PATH
        unset LICENSE_URL_
    fi

    #########################################################################################

    step "create linker script"

    # https://developer.android.com/ndk/guides/stable_apis#c_library
    # Note that on Android, unlike Linux, there are no separate libpthread or librt libraries.
    # That functionality is included directly in libc, which does not need to be explicitly linked against.
    run "echo '!<arch>' > '$PACKAGE_WORKING_DIR/lib/libpthread.a'"
    run "echo '!<arch>' > '$PACKAGE_WORKING_DIR/lib/librt.a'"

    if [ "$ANDROID_NDK_VERSION_MAJOR" -ge 23 ] ; then
        # https://github.com/rust-windowing/android-ndk-rs/issues/149
        if [ "$TARGET_ANDROID_ARCH" = 'x86_64' ] ; then
            LIBCLANG_RT_BUILTINS_FILEPATH="$("$CC" -print-libgcc-file-name)"
        else
            LIBCLANG_RT_BUILTINS_FILEPATH=
        fi
        run "echo 'INPUT($LIBCLANG_RT_BUILTINS_FILEPATH -l:libunwind.a)' > '$PACKAGE_WORKING_DIR/lib/libgcc.a'"
    fi

    #if [ "$LINK_TYPE" = 'static-only' ] ; then
        #run "echo 'INPUT($SYSTEM_LIBRARY_DIR/libc.a)'  > '$PACKAGE_WORKING_DIR/lib/libc.a'"
        #run "echo 'INPUT($SYSTEM_LIBRARY_DIR/libm.a)'  > '$PACKAGE_WORKING_DIR/lib/libm.a'"
        #run "echo 'INPUT($SYSTEM_LIBRARY_DIR/libz.a)'  > '$PACKAGE_WORKING_DIR/lib/libz.a'"
        #run "echo 'INPUT($SYSTEM_LIBRARY_DIR/libdl.a)' > '$PACKAGE_WORKING_DIR/lib/libdl.a'"
    #fi

    #########################################################################################

    [ -n "$RECURSIVE_DEPENDENT_PACKAGE_NAMES" ] && {
        step "create symlinks for dependent libraries"

        case $LINK_TYPE in
            static-only|static-prefered) LINK_LIBRARY_TYPE='a'  ;;
            shared-only|shared-prefered) LINK_LIBRARY_TYPE='so' ;;
        esac

        for DEPENDENT_PACKAGE_INSTALL_DIR in $RECURSIVE_DEPENDENT_PACKAGE_INSTALL_DIRS
        do
            DEPENDENT_PACKAGE_LIBRARY_DIR="$DEPENDENT_PACKAGE_INSTALL_DIR/lib"

            [ -d "$DEPENDENT_PACKAGE_LIBRARY_DIR" ] || continue

            for f in $(find "$DEPENDENT_PACKAGE_LIBRARY_DIR" -maxdepth 1 -mindepth 1 -name "lib*.$LINK_LIBRARY_TYPE" -printf '%P\n')
            do
                #if [ -e "$PACKAGE_WORKING_DIR/lib/$f" ] ; then
                #    continue
                #else
                    cp -v "$DEPENDENT_PACKAGE_LIBRARY_DIR/$f" "$PACKAGE_WORKING_DIR/lib/$f"
                #fi
            done
        done

        unset LINK_LIBRARY_TYPE
    }

    #########################################################################################

    step "config ccache"

    if [ "$CCACHE_ENABLED" = yes ] ; then
        run ln -sf "$CCACHE" "$PACKAGE_WORKING_DIR/bin/wrapper-target-cc"
        run ln -sf "$CCACHE" "$PACKAGE_WORKING_DIR/bin/wrapper-target-c++"
    else
        note "ccache is disabled, skipped."
    fi

    if [ "$CCACHE_ENABLED" = yes ] ; then
        ccache -s > "$PACKAGE_WORKING_DIR/ccache-s.txt"
    fi

    #########################################################################################

    step "dopatch for target"

    if [ "$PWD" != "$PACKAGE_BSCRIPT_DIR" ] ; then
        run cd "$PACKAGE_BSCRIPT_DIR"
    fi

    if [ -n "$PACKAGE_DOPATCH_ACTIONS" ] ; then
        eval "
dopatch() {
$PACKAGE_DOPATCH_ACTIONS
}"
        dopatch "$1"
    else
        note "dopatch mapping was not found in formula, skipped."
    fi

    #########################################################################################

    case $PACKAGE_BUILD_SYSTEM in
        autogen)
            if [ -f configure ] ; then
                CONFIGURE_FILE_LAST_MODIFIED_TIMESTAMP="$(stat --format=%Y configure)"

                if [ -z "$CONFIGURE_FILE_LAST_MODIFIED_TIMESTAMP" ] ; then
                    run NOCONFIGURE=yes ./autogen.sh
                elif [ "$CONFIGURE_FILE_LAST_MODIFIED_TIMESTAMP" -lt "$TIMESTAMP_UNIX" ] ; then
                    run NOCONFIGURE=yes ./autogen.sh
                fi
            else
                run NOCONFIGURE=yes ./autogen.sh
            fi
            ;;
        autotools)
            if [ -f configure ] ; then
                CONFIGURE_FILE_LAST_MODIFIED_TIMESTAMP="$(stat --format=%Y configure)"

                if [ -z "$CONFIGURE_FILE_LAST_MODIFIED_TIMESTAMP" ] ; then
                    run autoreconf -ivf
                elif [ "$CONFIGURE_FILE_LAST_MODIFIED_TIMESTAMP" -lt "$TIMESTAMP_UNIX" ] ; then
                    run autoreconf -ivf
                fi
            else
                run autoreconf -ivf
            fi
            ;;
    esac

    #########################################################################################

    step "install for target"

    if [ "$PACKAGE_BUILD_IN_BSCRIPT_DIR" = yes ] ; then
        if [ "$PWD" != "$PACKAGE_BSCRIPT_DIR" ] ; then
            run cd "$PACKAGE_BSCRIPT_DIR"
        fi
    else
            run cd "$PACKAGE_BCACHED_DIR"
    fi

    if [ -d "$PACKAGE_INSTALL_DIR" ] ; then
        run rm -rf "$PACKAGE_INSTALL_DIR"
    fi

    eval "
dobuild() {
$PACKAGE_DOBUILD_ACTIONS
}"

    dobuild "$1"

    #########################################################################################

    [ "$PACKAGE_BUILD_SYSTEM_CARGO" = yes ] && {
        rm -f "$PACKAGE_INSTALL_DIR/.crates.toml"
        rm -f "$PACKAGE_INSTALL_DIR/.crates2.json"
    }

    #########################################################################################

    cd "$PACKAGE_INSTALL_DIR" || abort 1 "nothing is installed."

    [ -z "$(ls)" ]            && abort 1 "nothing is installed."

    #########################################################################################

    # reassigned to make sure it has the right value, becsuse it may be changed in dopatch and install block.

    PACKAGE_INSTALLING_SRC_DIR="$PACKAGE_WORKING_DIR/src"
    PACKAGE_INSTALLING_FIX_DIR="$PACKAGE_WORKING_DIR/fix"
    PACKAGE_INSTALLING_RES_DIR="$PACKAGE_WORKING_DIR/res"
    PACKAGE_INSTALLING_BIN_DIR="$PACKAGE_WORKING_DIR/bin"
    PACKAGE_INSTALLING_LIB_DIR="$PACKAGE_WORKING_DIR/lib"
    PACKAGE_INSTALLING_INC_DIR="$PACKAGE_WORKING_DIR/include"

    #########################################################################################

    PACKAGE_METAINF_DIR="$PACKAGE_INSTALL_DIR/.ndk-pkg"

    PACKAGE_MANIFEST_FILEPATH="$PACKAGE_METAINF_DIR/MANIFEST.txt"
    PACKAGE_RECEIPT_FILEPATH="$PACKAGE_METAINF_DIR/RECEIPT.yml"

    install -d "$PACKAGE_METAINF_DIR"

    #########################################################################################

    step "install COPYING"

    COPYING_FOUND=0

    for item in $(find "$PACKAGE_INSTALLING_SRC_DIR" -mindepth 1 -maxdepth 1 -name "COPYING*")
    do
        if [ -f "$item" ] ; then
            COPYING_FOUND=1
            install -v -m 644 "$item" "$PACKAGE_METAINF_DIR/"
        fi
    done

    if [ "$COPYING_FOUND" = 0 ] ; then
        note "'COPYING' named file was not found, skipped."
    fi

    #########################################################################################

    step "install LICENSE"

    if [ -f "$PACKAGE_INSTALLING_SRC_DIR/LICENSE" ] ; then
        install -v -m 644 "$PACKAGE_INSTALLING_SRC_DIR/LICENSE" "$PACKAGE_METAINF_DIR/"
    else
        note "'LICENSE' named file was not found, skipped."
    fi

    #########################################################################################

    step "install AUTHORS"

    if [ -f "$PACKAGE_INSTALLING_SRC_DIR/AUTHORS" ] ; then
        install -v -m 644 "$PACKAGE_INSTALLING_SRC_DIR/AUTHORS" "$PACKAGE_METAINF_DIR/"
    else
        note "'AUTHORS' named file was not found, skipped."
    fi

    #########################################################################################

    step "install CONTRIBUTORS"

    CONTRIBUTORS_FOUND=0

    for item in CONTRIBUTORS CONTRIBUTORS.md CONTRIBUTORS.rst
    do
        if [ -f "$PACKAGE_INSTALLING_SRC_DIR/$item" ] ; then
            CONTRIBUTORS_FOUND=1
            install -v -m 644 "$PACKAGE_INSTALLING_SRC_DIR/$item" "$PACKAGE_METAINF_DIR/"
        fi
    done

    if [ "$CONTRIBUTORS_FOUND" = 0 ] ; then
        note "none of 'CONTRIBUTORS' 'CONTRIBUTORS.md' 'CONTRIBUTORS.rst' named files was found, skipped."
    fi

    #########################################################################################

    step "install README"

    README_FOUND=0

    for item in README README.md README.rst
    do
        if [ -f "$PACKAGE_INSTALLING_SRC_DIR/$item" ] ; then
            README_FOUND=1
            install -v -m 644 "$PACKAGE_INSTALLING_SRC_DIR/$item" "$PACKAGE_METAINF_DIR/"
        fi
    done

    if [ "$README_FOUND" = 0 ] ; then
        note "none of 'README' 'README.md' 'README.rst' named files was found, skipped."
    fi

    #########################################################################################

    step "install CONTRIBUTING"

    CONTRIBUTING_FOUND=0

    for item in CONTRIBUTING CONTRIBUTING.md CONTRIBUTING.rst
    do
        if [ -f "$PACKAGE_INSTALLING_SRC_DIR/$item" ] ; then
            CONTRIBUTING_FOUND=1
            install -v -m 644 "$PACKAGE_INSTALLING_SRC_DIR/$item" "$PACKAGE_METAINF_DIR/"
        fi
    done

    if [ "$CONTRIBUTING_FOUND" = 0 ] ; then
        note "none of 'CONTRIBUTING' 'CONTRIBUTING.md' 'CONTRIBUTING.rst' named files was found, skipped."
    fi

    #########################################################################################

    step "install CHANGELOG"

    CHANGELOG_FOUND=0

    for item in CHANGELOG CHANGELOG.md CHANGES
    do
        if [ -f "$PACKAGE_INSTALLING_SRC_DIR/$item" ] ; then
            install -v -m 644 "$PACKAGE_INSTALLING_SRC_DIR/$item" "$PACKAGE_METAINF_DIR/"
            CHANGELOG_FOUND=1
            break;
        fi
    done

    if [ "$CHANGELOG_FOUND" = 0 ] ; then
        note "none of 'CHANGELOG' 'CHANGELOG.md' 'CHANGES' named files was found, skipped."
    fi

    #########################################################################################

    step "install NEWS"

    if [ -f "$PACKAGE_INSTALLING_SRC_DIR/NEWS" ] ; then
        install -v -m 644 "$PACKAGE_INSTALLING_SRC_DIR/NEWS" "$PACKAGE_METAINF_DIR/"
    else
        note "'NEWS' named file was not found, skipped."
    fi

    #########################################################################################

    step "install TODO"

    if [ -f "$PACKAGE_INSTALLING_SRC_DIR/TODO" ] ; then
        install -v -m 644 "$PACKAGE_INSTALLING_SRC_DIR/TODO" "$PACKAGE_METAINF_DIR/"
    else
        note "'TODO' named file was not found, skipped."
    fi

    #########################################################################################

    step "install FAQ"

    if [ -f "$PACKAGE_INSTALLING_SRC_DIR/FAQ" ] ; then
        install -v -m 644 "$PACKAGE_INSTALLING_SRC_DIR/FAQ" "$PACKAGE_METAINF_DIR/"
    else
        note "'FAQ' named file was not found, skipped."
    fi

    #########################################################################################

    step "install THANKS"

    if [ -f "$PACKAGE_INSTALLING_SRC_DIR/THANKS" ] ; then
        install -v -m 644 "$PACKAGE_INSTALLING_SRC_DIR/THANKS" "$PACKAGE_METAINF_DIR/"
    else
        note "'THANKS' named file was not found, skipped."
    fi

    #########################################################################################

    step "install config.log"

    for dir in "$PACKAGE_BCACHED_DIR" "$PACKAGE_BSCRIPT_DIR"
    do
        if [ -f "$dir/config.log" ] ; then
            install -v -m 644 "$dir/config.log" "$PACKAGE_METAINF_DIR"
        fi
    done

    #########################################################################################

    step "install compile_commands.json"

    for dir in "$PACKAGE_BCACHED_DIR" "$PACKAGE_BSCRIPT_DIR"
    do
        if [ -f "$dir/compile_commands.json" ] ; then
            install -v -m 644 "$dir/compile_commands.json" "$PACKAGE_METAINF_DIR"
        fi
    done

    #########################################################################################

    step "install dependency graph files"

    find "$PACKAGE_WORKING_DIR" -mindepth 1 -maxdepth 1 \( -name dependencies.dot -o -name dependencies.box -o -name dependencies.svg -o -name dependencies.png \) -exec install -v -m 644 {} "$PACKAGE_METAINF_DIR" \;

    #########################################################################################

    [ -n "$PACKAGE_DEP_PKG" ] && {
        step "install dependency formulas"

        install -v -d "$PACKAGE_METAINF_DIR/formula"

        for DEPENDENT_PACKAGE_NAME in $RECURSIVE_DEPENDENT_PACKAGE_NAMES
        do
            install -v -m 644 "$SESSION_DIR/$DEPENDENT_PACKAGE_NAME.yml" "$PACKAGE_METAINF_DIR/formula"
        done
    }

    #########################################################################################

    step "install LICENSEs"
    if [        -f "$PACKAGE_WORKING_DIR/LICENSE1" ] ; then
        if [    -f "$PACKAGE_WORKING_DIR/LICENSE2" ] ; then
            run mv "$PACKAGE_WORKING_DIR/LICENSE[1-9]" "$PACKAGE_METAINF_DIR"
        else
            run mv "$PACKAGE_WORKING_DIR/LICENSE1"     "$PACKAGE_METAINF_DIR/LICENSE"
        fi
    else
        warn "no LICENSEs, skipped."
    fi

    #########################################################################################

    step "adjust ELF files for ${COLOR_GREEN}$@${COLOR_OFF}"
    __adjust_elf_files_for_the_given_target $@

    if [ -d "$PACKAGE_INSTALL_DIR/lib" ] ; then
        step "adjust .la files for ${COLOR_GREEN}$@${COLOR_OFF}"
        __adjust_la_files_for_the_given_target $@

        step "adjust .pc files for ${COLOR_GREEN}$@${COLOR_OFF}"
        __adjust_pc_files_for_the_given_target $@

        step "install no versioning libraries for ${COLOR_GREEN}$@${COLOR_OFF}"

        PACKAGE_LIBRARY_DIR="$PACKAGE_INSTALL_DIR/lib"

        PACKAGE_LIBRARY_DIR_NOVERSIOING="$PACKAGE_INSTALL_DIR/lib-for-apk"

        run install -d "$PACKAGE_LIBRARY_DIR_NOVERSIOING/cmake/$PACKAGE_NAME"

        find "$PACKAGE_LIBRARY_DIR" -maxdepth 1 -mindepth 1 -type f -name 'lib*.a'  -exec cp -v {} "$PACKAGE_LIBRARY_DIR_NOVERSIOING" \;
        find "$PACKAGE_LIBRARY_DIR" -maxdepth 1 -mindepth 1 -type f -name 'lib*.so' -exec cp -v {} "$PACKAGE_LIBRARY_DIR_NOVERSIOING" \;

        for SO_FILE_PATH_HAVE_VERSION in $(find "$PACKAGE_LIBRARY_DIR" -maxdepth 1 -mindepth 1 -name 'lib*.so.*')
        do
            SO_FILE_NAME_NO_VERSION=
            SO_FILE_NAME_NO_VERSION="$(basename "$SO_FILE_PATH_HAVE_VERSION" | sed 's/\(lib.*\.so\)\..*/\1/')"

            if [ ! -f "$PACKAGE_LIBRARY_DIR_NOVERSIOING/$SO_FILE_NAME_NO_VERSION" ] ; then
                run cp "$SO_FILE_PATH_HAVE_VERSION" "$PACKAGE_LIBRARY_DIR_NOVERSIOING/$SO_FILE_NAME_NO_VERSION"
            fi
        done

        cd "$PACKAGE_LIBRARY_DIR_NOVERSIOING"

        step "adjust no versioning .so files for ${COLOR_GREEN}$@${COLOR_OFF}"

        for sofile in $(find . -maxdepth 1 -mindepth 1 -type f -name 'lib*.so' -printf '%P\n')
        do
            # http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#dynamic_section

            DT_SONAME="$(patchelf --print-soname "$sofile")"

            if [ -z "$DT_SONAME" ] ; then
                abort 1 "unexpected so file: $sofile\n    DT_SONAME: not set"
            fi

            if [ "$DT_SONAME" != "$sofile" ] ; then
                abort 1 "unexpected so file: $sofile\n    DT_SONAME: $DT_SONAME"
            fi

            DT_NEEDED_LIST="$(patchelf --print-needed "$sofile")"

            for DT_NEEDED in $DT_NEEDED_LIST
            do
                case $DT_NEEDED in
                    lib*.so)
                        ;;
                    *)  abort 1 "unexpected so file: $sofile\n    DT_NEEDED: $DT_NEEDED"
                esac
            done
        done

        step "create cmake config files for ${COLOR_GREEN}$@${COLOR_OFF}"
        __create_cmake_config_files_for_the_given_target "$@"
    fi

    #########################################################################################

    cd "$PACKAGE_INSTALL_DIR"

    step "generate MANIFEST.txt"
    __generate_manifest_of_the_given_package "$1"

    step "generate RECEIPT.yml"
    __generate_receipt_of_the_given_package "$1"

    run ln -sr "$PACKAGE_INSTALL_DIR" "$NDKPKG_PACKAGE_INSTALLED_ROOT/$PACKAGE_SPEC"

    #########################################################################################

    [ "$CCACHE_ENABLED" = yes ] && {
        step "show ccache statistics summary"
        note "Before Build:"
        run  cat "$PACKAGE_WORKING_DIR/ccache-s.txt"
        note "After  Build:"
        run  ccache -s
    }

    [ "$KEEP_WORKING_DIR" != yes ] && {
        step "delete the installing directory"
        run rm -rf "$PACKAGE_WORKING_DIR"
    }

    printf '\n'
    success "$1 have been successfully installed."

    step "show installed files in tree-like format"
    run tree --dirsfirst -a "$PACKAGE_INSTALL_DIR"
}

__create_cmake_config_files_for_the_given_target() {
    TARGET_CMAKE_CONFIG_FILEPATH="$PACKAGE_LIBRARY_DIR_NOVERSIOING/cmake/$PACKAGE_NAME/${PACKAGE_NAME}Config.cmake"

    cat > "$TARGET_CMAKE_CONFIG_FILEPATH" << EOF
# generated by ndk-pkg $NDKPKG_VERSION

get_filename_component(${PACKAGE_NAME}_INSTALL_DIR "\${CMAKE_CURRENT_LIST_DIR}/../../../" ABSOLUTE)

set(${PACKAGE_NAME}_INCLUDE_DIR "\${${PACKAGE_NAME}_INSTALL_DIR}/include")
set(${PACKAGE_NAME}_LIBRARY_DIR "\${${PACKAGE_NAME}_INSTALL_DIR}/lib-for-apk")

EOF

    unset CMAKE_IMPORTED_TARGETS

    for libfilename in $(find . -maxdepth 1 -mindepth 1 -a \( -name 'lib*.a' -o -name 'lib*.so' \) -printf '%P\n')
    do
        case $libfilename in
            lib*.a)  LIBRARY_TYPE=STATIC ;;
            lib*.so) LIBRARY_TYPE=SHARED ;;
            *)       abort 1 "unrecognized library filename: $libfilename"
        esac

        CMAKE_IMPORTED_TARGET="$PACKAGE_NAME::$libfilename"

        if [ -z "$CMAKE_IMPORTED_TARGETS" ] ; then
            CMAKE_IMPORTED_TARGETS="$CMAKE_IMPORTED_TARGET"
        else
            CMAKE_IMPORTED_TARGETS="$CMAKE_IMPORTED_TARGETS;$CMAKE_IMPORTED_TARGET"
        fi

        cat >> "$TARGET_CMAKE_CONFIG_FILEPATH" << EOF

if (NOT TARGET  $CMAKE_IMPORTED_TARGET)
    add_library($CMAKE_IMPORTED_TARGET STATIC IMPORTED)
    set_target_properties($CMAKE_IMPORTED_TARGET PROPERTIES
        IMPORTED_LOCATION             "\${${PACKAGE_NAME}_LIBRARY_DIR}/$libfilename"
        INTERFACE_INCLUDE_DIRECTORIES "\${${PACKAGE_NAME}_INCLUDE_DIR}"
    )
endif()
EOF
    done

    cat >> "$TARGET_CMAKE_CONFIG_FILEPATH" << EOF

set(${PACKAGE_NAME}_IMPORTED_TARGETS "$CMAKE_IMPORTED_TARGETS")
EOF

    cat > "$PACKAGE_LIBRARY_DIR_NOVERSIOING/cmake/$PACKAGE_NAME/${PACKAGE_NAME}ConfigVersion.cmake" << EOF
# generated by ndk-pkg $NDKPKG_VERSION
#
# https://cmake.org/cmake/help/latest/command/find_package.html#config-mode-version-selection

set(PACKAGE_VERSION $PACKAGE_VERSION)

if ("\${PACKAGE_VERSION}" VERSION_LESS "\${PACKAGE_FIND_VERSION}")
    set(PACKAGE_VERSION_COMPATIBLE FALSE)
else()
    set(PACKAGE_VERSION_COMPATIBLE TRUE)
    if ("\${PACKAGE_VERSION}" VERSION_EQUAL "\${PACKAGE_FIND_VERSION}")
        set(PACKAGE_VERSION_EXACT TRUE)
    endif()
endif()
EOF
}

__adjust_elf_files_for_the_given_target() {
    BASE64_ENCODED_RELATIVE_FILEPATH_LIST=
    BASE64_ENCODED_RELATIVE_FILEPATH_LIST="$(cd "$PACKAGE_INSTALL_DIR" && find -not -name . -type f -exec base64-encode '{}' \;)"

    for BASE64_ENCODED_RELATIVE_FILEPATH in $BASE64_ENCODED_RELATIVE_FILEPATH_LIST
    do
        BASE64_DECODED_RELATIVE_FILEPATH=
        BASE64_DECODED_RELATIVE_FILEPATH="$(base64-decode "$BASE64_ENCODED_RELATIVE_FILEPATH")"

        FILEPATH="$PACKAGE_INSTALL_DIR/${BASE64_DECODED_RELATIVE_FILEPATH#./}"

        [ -w "$FILEPATH" ] || continue

        FILE_HEADER_EXPACT=
        FILE_HEADER_ACTUAL=
        FILE_HEADER_ACTUAL="$(head -c 20 "$FILEPATH" | base16-encode)"

        # http://www.sco.com/developers/gabi/latest/ch4.eheader.html
        case $FILE_HEADER_ACTUAL in
            7F454C46*)
                ELF_TYPE=
                ELF_TYPE="$(printf '%s\n' "$FILE_HEADER_ACTUAL" | cut -c33-34)"

                case $TARGET_ANDROID_ABI in
                    armeabi-v7a) FILE_HEADER_EXPACT="7F454C46010101000000000000000000${ELF_TYPE}002800" ;;
                    arm64-v8a)   FILE_HEADER_EXPACT="7F454C46020101000000000000000000${ELF_TYPE}00B700" ;;
                    x86)         FILE_HEADER_EXPACT="7F454C46010101000000000000000000${ELF_TYPE}000300" ;;
                    x86_64)      FILE_HEADER_EXPACT="7F454C46020101000000000000000000${ELF_TYPE}003E00" ;;
                esac

                if [ "$FILE_HEADER_EXPACT" != "$FILE_HEADER_ACTUAL" ] ; then
                    abort 1 "ELF file header mismatch: $FILEPATH\n    expect : $FILE_HEADER_EXPACT\n    actual : $FILE_HEADER_ACTUAL"
                fi

                # may report: patchelf: cannot find section '.interp'. The input file is most likely statically linked
                PT_INTERP=
                PT_INTERP="$(patchelf --print-interpreter "$FILEPATH" 2>/dev/null || true)"

                if [ -n  "$PT_INTERP" ] ; then
                    if [ "$PT_INTERP" != "$ANDROID_DYNAMIC_LINKER_PATH" ] ; then
                        abort 1 "ELF file PT_INTERP mismatch: $FILEPATH\n    expect : $ANDROID_DYNAMIC_LINKER_PATH\n    actual : $PT_INTERP"
                    fi

                    DT_SONAME=
                    DT_SONAME="$(patchelf --print-soname "$FILEPATH")"

                    if [ -z "$DT_SONAME" ] ; then
                        # In general, a shared library would not have the .interp section.
                        # a dynamically linked executable always have the .interp section.
                        #
                        # https://source.android.com/security/enhancements/enhancements50
                        # Android 5.0 and later only support position-independent executables (-fPIE)
                        if ! "$READELF" -d "$FILEPATH" | grep FLAGS_1 | grep -q PIE ; then
                            abort 1 "invalid ELF file: $FILEPATH. Android 5.0 and later requires dynamically linked executable to support PIE (position-independent executables)."
                        fi
                    fi
                fi

                if basename "$FILEPATH" | grep -q '^lib.*\.so' ; then
                    :
                else

                    if [ "$BUILD_TYPE" = release ] ; then
                        run "$STRIP" $STRIP_ARG "$FILEPATH" || true
                    fi
                fi
        esac
    done
}

__adjust_la_files_for_the_given_target() {
    [ -d "$PACKAGE_INSTALL_DIR/lib" ] || {
        note "no .la files installed, skipped"
        return 0
    }

    LA_FILES="$(find "$PACKAGE_INSTALL_DIR/lib" -name '*.la')"

    [ -z "$LA_FILES" ] && {
        note "no .la files installed, skipped"
        return 0
    }

    for lafile in $LA_FILES
    do
        sed_in_place 's|-lpthread||g'              "$lafile"
        sed_in_place 's|-Wl,--strip-debug||g'      "$lafile"
        sed_in_place "s|-L$NDKPKG_HOME[^' ]*||g"   "$lafile"
        sed_in_place "s|-L$SYSTEM_LIBRARY_DIR||g"  "$lafile"
        sed_in_place "s|--sysroot $SYSROOT||g"     "$lafile"
    done
}

__adjust_pc_files_for_the_given_target() {
    [ -d "$PACKAGE_INSTALL_DIR/lib/pkgconfig" ] || {
        note "no .pc files installed, skipped"
        return 0
    }

    PC_FILES="$(find "$PACKAGE_INSTALL_DIR/lib/pkgconfig" -name "*.pc")"

    [ -z "$PC_FILES" ] && {
        note "no .pc files installed, skipped"
        return 0
    }

    for pcfile in $PC_FILES
    do
        sed_in_place "s|$PACKAGE_INSTALL_DIR|\${pcfiledir}/../..|g" "$pcfile"
        sed_in_place 's|-lpthread||g'              "$pcfile"
        sed_in_place 's|-Wl,--strip-debug||g'      "$pcfile"
        sed_in_place "s|-I$NDKPKG_HOME[^' ]*||g"   "$pcfile"
        sed_in_place "s|-L$NDKPKG_HOME[^' ]*||g"   "$pcfile"
        sed_in_place "s|-L$SYSTEM_LIBRARY_DIR||g"  "$pcfile"
        sed_in_place "s|--sysroot $SYSROOT||"      "$pcfile"

        if grep -q 'Libs.private:' "$pcfile" ; then
            LIBS_CONTENT=$(awk '/Libs:/{print}' "$pcfile")
            LIBS_PRIVATE_CONTENT=$(awk -F: '/Libs.private:/{print $2}' "$pcfile")
            sed_in_place "s|$LIBS_CONTENT|$LIBS_CONTENT$LIBS_PRIVATE_CONTENT|" "$pcfile"
            sed_in_place '/Libs.private/d' "$pcfile"
        fi

        if grep -q 'Requires.private:' "$pcfile" ; then
            if grep -q 'Requires:' "$pcfile" ; then
                REQUIRES_PRIVATE_CONTENT=$(sed -n '/Requires.private:/p' "$pcfile" | cut -c18-)
                sed_in_place "/Requires:/s|\$|$REQUIRES_PRIVATE_CONTENT|" "$pcfile"
                sed_in_place '/Requires.private:/d' "$pcfile"
            else
                sed_in_place 's|Requires.private:|Requires:|' "$pcfile"
            fi
        fi
    done
}

install_incs() {
    while [ -n "$1" ]
    do
        unset X1
        unset X2
        X1=$(printf '%s\n' "$1" | cut -d: -f1)
        X2=$(printf '%s\n' "$1" | cut -d: -f2)

        if [ "$X1" = "$X2" ] ; then
            unset X2
        fi

        install -v -d         "$PACKAGE_INSTALL_DIR/include/$X2"
        install -v -m 644 $X1 "$PACKAGE_INSTALL_DIR/include/$X2"

        shift
    done
}

install_libs() {
    install -v -d "$PACKAGE_INSTALL_DIR/lib"
    for item in $@
    do
        case $item in
            *.a) install -v -m 644 $item "$PACKAGE_INSTALL_DIR/lib" ;;
            *)   install -v -m 755 $item "$PACKAGE_INSTALL_DIR/lib" ;;
        esac
    done
}

install_pcfs() {
    install -v -d        "$PACKAGE_INSTALL_DIR/lib/pkgconfig" &&
    install -v -m 644 $@ "$PACKAGE_INSTALL_DIR/lib/pkgconfig"
}

install_bins() {
    install -v -d        "$PACKAGE_INSTALL_DIR/bin" &&
    install -v -m 755 $@ "$PACKAGE_INSTALL_DIR/bin"
}

install_etcs() {
    install -v -d        "$PACKAGE_INSTALL_DIR/etc" &&
    install -v -m 644 $@ "$PACKAGE_INSTALL_DIR/etc"
}

install_mans() {
    for item in $@
    do
        unset NUMBER
        NUMBER=$(printf '%s\n' "$item" | cut -c ${#item}-${#item})
        case $NUMBER in
            [1-8]);;
            *)    abort 1 "$item: not a manpage."
        esac
        install -v -d           "$PACKAGE_INSTALL_DIR/share/man/man$NUMBER" &&
        install -v -m 644 $item "$PACKAGE_INSTALL_DIR/share/man/man$NUMBER"
    done
}

# install_completion <fish|bash|zsh> <COMMAND> <FILE-PATH>
  install_completion() {
    case $1 in
        bash)
            install -v -d          "$PACKAGE_INSTALL_DIR/share/bash/completions" &&
            install -v -m 644 "$3" "$PACKAGE_INSTALL_DIR/share/bash/completions/$2"
            ;;
        fish)
            install -v -d          "$PACKAGE_INSTALL_DIR/share/fish/vendor_completions.d" &&
            install -v -m 644 "$3" "$PACKAGE_INSTALL_DIR/share/fish/vendor_completions.d/$2.fish"
            ;;
        zsh)
            install -v -d          "$PACKAGE_INSTALL_DIR/share/zsh/site-functions" &&
            install -v -m 644 "$3" "$PACKAGE_INSTALL_DIR/share/zsh/site-functions/_$2"
            ;;
        *)  abort 1 "install_completion unsupported shell: $1"
    esac
}

install_pc_file() {
    install -v -d "$PACKAGE_INSTALL_DIR/lib/pkgconfig" &&
    cat >         "$PACKAGE_INSTALL_DIR/lib/pkgconfig/$1.pc"
}

__record_installed_files_of_the_given_package() {
    if [ -z "$2" ] ; then
        INSTALLED_FILES_FILEPATH="$PACKAGE_INSTALL_DIR/installed-files"
        printf '%s\n' "-- Installing: $INSTALLED_FILES_FILEPATH"

        touch "$INSTALLED_FILES_FILEPATH"
        return 0

        # TODO
        exec 7> "$INSTALLED_FILES_FILEPATH"

        __record_installed_files_of_the_given_package "$1" "$PACKAGE_INSTALL_DIR"

        exec 7>&-

        sed_in_place "s|$PACKAGE_INSTALL_DIR/||" "$INSTALLED_FILES_FILEPATH"
    else
        for file in $(ls $2)
        do
            file="$2/$file"
            if [ -d "$file" ] ; then
                __record_installed_files_of_the_given_package "$1" "$file"
            else
                printf '%s %s\n' $(md5sum "$file") "$file" >&7
            fi
        done
    fi
}

gow() {
    if command -v bat > /dev/null ; then
        run "go env | bat --language=bash --paging=never --style=plain"
    else
        run "go env"
    fi

    printf '\n'

    # https://pkg.go.dev/cmd/go
    # https://pkg.go.dev/cmd/link

    unset GO_BUILD_ARGS
    unset GO_BUILD_ARGV_V
    unset GO_BUILD_ARGV_X
    unset GO_BUILD_ARGV_O
    unset GO_BUILD_ARGV_MOD
    unset GO_BUILD_ARGV_TAGS
    unset GO_BUILD_ARGV_LDFLAGS

    unset GO_BUILD_ARGS_EXTRA

    while [ -n "$1" ]
    do
        case $1 in
            -v) shift ; GO_BUILD_ARGV_V='-v' ;;
            -x) shift ; GO_BUILD_ARGV_X='-x' ;;
            -o) shift ; GO_BUILD_ARGV_O="$1" ; shift ;;
            -X) shift
                if [ -z "$GO_BUILD_ARGV_LDFLAGS" ] ; then
                    GO_BUILD_ARGV_LDFLAGS="-X $1"
                else
                    GO_BUILD_ARGV_LDFLAGS="$GO_BUILD_ARGV_LDFLAGS -X $1"
                fi
                shift
                ;;
            -ldflags)
                shift
                if [ -z "$GO_BUILD_ARGV_LDFLAGS" ] ; then
                    GO_BUILD_ARGV_LDFLAGS="$1"
                else
                    GO_BUILD_ARGV_LDFLAGS="$1 $GO_BUILD_ARGV_LDFLAGS"
                fi
                shift
                ;;
            *)  GO_BUILD_ARGS_EXTRA="$GO_BUILD_ARGS_EXTRA $1" ; shift
        esac
    done

    GO_BUILD_ARGS='-trimpath'

    if [ -z "$GO_BUILD_ARGV_V" ] ; then
        if [ "$LOG_LEVEL" -gt 0 ] ; then
            GO_BUILD_ARGS="$GO_BUILD_ARGS -v"
        fi
    else
        GO_BUILD_ARGS="$GO_BUILD_ARGS -v"
    fi

    if [ -z "$GO_BUILD_ARGV_X" ] ; then
        if [ "$LOG_LEVEL" -ge 2 ] ; then
            GO_BUILD_ARGS="$GO_BUILD_ARGS -x"
        fi
    else
        GO_BUILD_ARGS="$GO_BUILD_ARGS -x"
    fi

    if [ "$BUILD_TYPE" = release ] ; then
        GO_BUILD_ARGV_LDFLAGS="$GO_BUILD_ARGV_LDFLAGS -s -w"
    fi

    if [ "$NATIVE_OS_KIND" != darwin ] ; then
        if [ "$LINK_TYPE" = static-only ] && [ "$CGO_ENABLED" -eq 1 ] ; then
            GO_BUILD_ARGV_LDFLAGS="$GO_BUILD_ARGV_LDFLAGS -linkmode external \"-extldflags=-static\""
        fi
    fi

    GO_BUILD_ARGS="$GO_BUILD_ARGS -ldflags '$GO_BUILD_ARGV_LDFLAGS'"

    if [ -z "$GO_BUILD_ARGV_O" ] ; then
        GO_BUILD_ARGS="$GO_BUILD_ARGS -o $PACKAGE_BCACHED_DIR/"
    else
        GO_BUILD_ARGS="$GO_BUILD_ARGS -o $PACKAGE_BCACHED_DIR/$GO_BUILD_ARGV_O"
    fi

    GO_BUILD_ARGS="$GO_BUILD_ARGS $GO_BUILD_ARGS_EXTRA"

    # shellcheck disable=SC2086
    run go build $GO_BUILD_ARGS

    for item in $(ls "$PACKAGE_BCACHED_DIR")
    do
        case $item in
            *.a)  run install_libs "$PACKAGE_BCACHED_DIR/$item" ;;
            *.so) run install_libs "$PACKAGE_BCACHED_DIR/$item" ;;
            *)    run install_bins "$PACKAGE_BCACHED_DIR/$item" ;;
        esac
    done
}

cargow() {
    run rustup target add "$RUST_TARGET"

    case $1 in
        build)
            # https://doc.rust-lang.org/cargo/commands/cargo-clean.html
            # https://doc.rust-lang.org/cargo/commands/cargo-build.html

            unset CARGO_BUILD_ARGS
            unset CARGO_BUILD_ARG_VV
            unset CARGO_BUILD_ARG_TARGET
            unset CARGO_BUILD_ARG_RELEASE

            for arg in $@
            do
                case $arg in
                    --vv)      CARGO_BUILD_ARG_VV=set      ;;
                    --target)  CARGO_BUILD_ARG_TARGET=set  ;;
                    --release) CARGO_BUILD_ARG_RELEASE=set ;;
                esac
            done

            CARGO_BUILD_ARGS="$@"

            if [ -z "$CARGO_BUILD_ARG_VV" ] ; then
                CARGO_BUILD_ARGS="$CARGO_BUILD_ARGS -vv"
            fi

            if [ -z "$CARGO_BUILD_ARG_RELEASE" ] ; then
                CARGO_BUILD_ARGS="$CARGO_BUILD_ARGS --release"
            fi

            if [ -z "$CARGO_BUILD_ARG_TARGET" ] ; then
                CARGO_BUILD_ARGS="$CARGO_BUILD_ARGS --target $RUST_TARGET"
            fi

            run cargo clean && run cargo $CARGO_BUILD_ARGS
            ;;
        install)
            # https://doc.rust-lang.org/cargo/commands/cargo-clean.html
            # https://doc.rust-lang.org/cargo/commands/cargo-install.html

            unset CARGO_INSTALL_ARGS
            unset CARGO_INSTALL_ARG_TARGET
            unset CARGO_INSTALL_ARG_PATH
            unset CARGO_INSTALL_ARG_ROOT
            unset CARGO_INSTALL_ARG_VV

            for arg in $@
            do
                case $arg in
                    --target) CARGO_INSTALL_ARG_TARGET=set ;;
                    --path)   CARGO_INSTALL_ARG_PATH=set   ;;
                    --root)   CARGO_INSTALL_ARG_ROOT=set   ;;
                    --vv)     CARGO_INSTALL_ARG_VV=set     ;;
                esac
            done

            CARGO_INSTALL_ARGS="$@"

            if [ -z "$CARGO_INSTALL_ARG_VV" ] ; then
                CARGO_INSTALL_ARGS="$CARGO_INSTALL_ARGS -vv"
            fi

            if [ -z "$CARGO_INSTALL_ARG_TARGET" ] ; then
                CARGO_INSTALL_ARGS="$CARGO_INSTALL_ARGS --target $RUST_TARGET"
            fi

            if [ -z "$CARGO_INSTALL_ARG_PATH" ] ; then
                CARGO_INSTALL_ARGS="$CARGO_INSTALL_ARGS --path $PACKAGE_BSCRIPT_DIR"
            fi

            if [ -z "$CARGO_INSTALL_ARG_ROOT" ] ; then
                CARGO_INSTALL_ARGS="$CARGO_INSTALL_ARGS --root=$PACKAGE_INSTALL_DIR"
            fi

            run cargo clean && run cargo $CARGO_INSTALL_ARGS
            ;;
        cbuild|cinstall)
            unset CARGO_CINSTALL_ARGS
            unset CARGO_CINSTALL_ARG_Q
            unset CARGO_CINSTALL_ARG_V
            unset CARGO_CINSTALL_ARG_VV
            unset CARGO_CINSTALL_ARG_DEBUG
            unset CARGO_CINSTALL_ARG_RELEASE
            unset CARGO_CINSTALL_ARG_TARGET
            unset CARGO_CINSTALL_ARG_PREFIX

            for arg in $@
            do
                case $arg in
                    -q|--quiet)   CARGO_CINSTALL_ARG_Q=set       ;;
                    -v|--verbose) CARGO_CINSTALL_ARG_V=set       ;;
                    -vv)          CARGO_CINSTALL_ARG_VV=set      ;;
                    --debug)      CARGO_CINSTALL_ARG_DEBUG=set   ;;
                    --release)    CARGO_CINSTALL_ARG_RELEASE=set ;;
                    --target)     CARGO_CINSTALL_ARG_TARGET=set  ;;
                    --prefix)     CARGO_CINSTALL_ARG_PREFIX=set  ;;
                esac
            done

            CARGO_CINSTALL_ARGS="$@"

            if [ -z "$CARGO_CINSTALL_ARG_Q" ] && [ -z "$CARGO_CINSTALL_ARG_V" ] && [ -z "$CARGO_CINSTALL_ARG_VV" ] ; then
                CARGO_CINSTALL_ARGS="$CARGO_CINSTALL_ARGS -vv"
            fi

            if [ -z "$CARGO_CINSTALL_ARG_DEBUG" ] && [ -z "$CARGO_CINSTALL_ARG_RELEASE" ] ; then
                CARGO_CINSTALL_ARGS="$CARGO_CINSTALL_ARGS --release"
            fi

            if [ -z "$CARGO_CINSTALL_ARG_TARGET" ] ; then
                CARGO_CINSTALL_ARGS="$CARGO_CINSTALL_ARGS --target $RUST_TARGET"
            fi

            if [ -z "$CARGO_CINSTALL_ARG_PREFIX" ] ; then
                CARGO_CINSTALL_ARGS="$CARGO_CINSTALL_ARGS --prefix $PACKAGE_INSTALL_DIR"
            fi

            run cargo $CARGO_CINSTALL_ARGS
            ;;
        *) cargo $@
    esac
}

# run in a subshell
configure() {
    if [ "$STEP_MESSAGE" = 'build for native' ] ; then
        if run "$PACKAGE_BSCRIPT_DIR"/configure \
            --prefix="$NATIVE_INSTALL_DIR" \
            $@ ; then
            echo
        else
            if [ -f "$PACKAGE_BCACHED_DIR/config.log" ] ; then
                run cat "$PACKAGE_BCACHED_DIR/config.log"
            elif [ -f "$PACKAGE_BSCRIPT_DIR/config.log" ] ; then
                run cat "$PACKAGE_BSCRIPT_DIR/config.log"
            fi
            return 1
        fi
    else
        export ac_cv_func_faccessat=yes
        export ac_cv_func_sigsetmask=no

        export ac_cv_func_malloc_0_nonnull=yes
        export ac_cv_func_calloc_0_nonnull=yes
        export ac_cv_func_realloc_0_nonnull=yes

        # https://android.googlesource.com/platform/bionic/+/master/docs/32-bit-abi.md#is-32_bit-on-lp32-y2038
        if [ "$TARGET_ANDROID_NBIT" -eq 32 ] ; then
            export ac_year2038_required=no
        fi

        CONFIGURE_ARG_ENABLE_NLS=no
        CONFIGURE_ARG_ENABLE_RPATH=no
        CONFIGURE_ARG_ENABLE_LARGEFILE=yes

        CONFIGURE_ARG_ENABLE_DEBUG=
        CONFIGURE_ARG_ENABLE_STATIC=
        CONFIGURE_ARG_ENABLE_SHARED=

        for arg in "$@"
        do
            case $arg in
                --enable-nls)      CONFIGURE_ARG_ENABLE_NLS=yes ;;
                --enable-nls=yes)  CONFIGURE_ARG_ENABLE_NLS=yes ;;
                --enable-nls=no)   CONFIGURE_ARG_ENABLE_NLS=no  ;;
                --disable-nls)     CONFIGURE_ARG_ENABLE_NLS=no  ;;

                --enable-rpath)     CONFIGURE_ARG_ENABLE_RPATH=yes ;;
                --enable-rpath=yes) CONFIGURE_ARG_ENABLE_RPATH=yes ;;
                --enable-rpath=no)  CONFIGURE_ARG_ENABLE_RPATH=no  ;;
                --disable-rpath)    CONFIGURE_ARG_ENABLE_RPATH=no  ;;

                --enable-largefile)     CONFIGURE_ARG_ENABLE_LARGEFILE=yes ;;
                --enable-largefile=yes) CONFIGURE_ARG_ENABLE_LARGEFILE=yes ;;
                --enable-largefile=no)  CONFIGURE_ARG_ENABLE_LARGEFILE=no  ;;
                --disable-largefile)    CONFIGURE_ARG_ENABLE_LARGEFILE=no  ;;

                --enable-debug)     CONFIGURE_ARG_ENABLE_DEBUG=yes ;;
                --enable-debug=yes) CONFIGURE_ARG_ENABLE_DEBUG=yes ;;
                --enable-debug=no)  CONFIGURE_ARG_ENABLE_DEBUG=no  ;;
                --disable-debug)    CONFIGURE_ARG_ENABLE_DEBUG=no  ;;

                --enable-static)     CONFIGURE_ARG_ENABLE_STATIC=yes ;;
                --enable-static=yes) CONFIGURE_ARG_ENABLE_STATIC=yes ;;
                --enable-static=no)  CONFIGURE_ARG_ENABLE_STATIC=no  ;;
                --disable-static)    CONFIGURE_ARG_ENABLE_STATIC=no  ;;

                --enable-shared)     CONFIGURE_ARG_ENABLE_SHARED=yes ;;
                --enable-shared=yes) CONFIGURE_ARG_ENABLE_SHARED=yes ;;
                --enable-shared=no)  CONFIGURE_ARG_ENABLE_SHARED=no  ;;
                --disable-shared)    CONFIGURE_ARG_ENABLE_SHARED=no  ;;
            esac
        done

        CONFIGURE_ARGS="--host='$TARGET_TRIPLE' --prefix='$PACKAGE_INSTALL_DIR' --disable-option-checking"

        if [ "$CONFIGURE_ARG_ENABLE_NLS" = yes ] ; then
            CONFIGURE_ARGS="$CONFIGURE_ARGS --enable-nls"
        else
            CONFIGURE_ARGS="$CONFIGURE_ARGS --disable-nls"
        fi

        if [ "$CONFIGURE_ARG_ENABLE_RPATH" = yes ] ; then
            CONFIGURE_ARGS="$CONFIGURE_ARGS --enable-rpath"
        else
            CONFIGURE_ARGS="$CONFIGURE_ARGS --disable-rpath"
        fi

        if [ "$CONFIGURE_ARG_ENABLE_LARGEFILE" = yes ] ; then
            CONFIGURE_ARGS="$CONFIGURE_ARGS --enable-largefile"
        else
            CONFIGURE_ARGS="$CONFIGURE_ARGS --disable-largefile"
        fi

        if [ -z "$CONFIGURE_ARG_ENABLE_DEBUG" ] ; then
            if [ "$LOG_LEVEL" -ge "$LOG_LEVEL_VERY_VERBOSE" ] ; then
                CONFIGURE_ARGS="$CONFIGURE_ARGS --enable-debug"
            else
                CONFIGURE_ARGS="$CONFIGURE_ARGS --disable-debug"
            fi
        fi

        if [ -z "$CONFIGURE_ARG_ENABLE_STATIC" ] ; then
            CONFIGURE_ARGS="$CONFIGURE_ARGS --enable-static"
        fi

        if [ -z "$CONFIGURE_ARG_ENABLE_SHARED" ] ; then
            CONFIGURE_ARGS="$CONFIGURE_ARGS --enable-shared"
        fi

        CONFIGURE_ENVS="$CONFIGURE_ENVS --with-pic
            CC='$CC'
            CFLAGS='$CFLAGS'
            CXX='$CXX'
            CXXFLAGS='$CXXFLAGS'
            CPP='$CPP'
            CPPFLAGS='$CPPFLAGS'
            LDFLAGS='$LDFLAGS'
            AR='$AR'
            RANLIB='$RANLIB'
            PKG_CONFIG='$PKG_CONFIG'
            PKG_CONFIG_PATH='$PKG_CONFIG_PATH'
            PKG_CONFIG_LIBDIR='$PKG_CONFIG_LIBDIR'
            CC_FOR_BUILD='$CC_FOR_BUILD'"

        if run $PACKAGE_BSCRIPT_DIR/configure $CONFIGURE_ARGS $@ $CONFIGURE_ENVS ; then
            echo
        else
            # https://docs.github.com/en/actions/learn-github-actions/environment-variables#default-environment-variables
            if [ "$GITHUB_ACTIONS" = true ] ; then
                if [ -f "$PACKAGE_BCACHED_DIR/config.log" ] ; then
                    run cat "$PACKAGE_BCACHED_DIR/config.log"
                elif [ -f "$PACKAGE_BSCRIPT_DIR/config.log" ] ; then
                    run cat "$PACKAGE_BSCRIPT_DIR/config.log"
                fi
            fi
            return 1
        fi
    fi

    if [ "$LOG_LEVEL" -ge "$LOG_LEVEL_VERBOSE" ] ; then
        for Makefile in $(find "$PACKAGE_BSCRIPT_DIR" -name Makefile)
        do
            sed_in_place 's|\t@|\t|g'     "$Makefile"
            sed_in_place 's|@echo|echo|g' "$Makefile"
        done
        unset Makefile
    fi

    gmakew clean &&
    gmakew       &&
    gmakew install
}

# gmake wrapper
gmakew() {
    unset GMAKE_OPTIONS
    unset GMAKE_OPTION_SETTED_C
    unset GMAKE_OPTION_SETTED_w
    unset GMAKE_OPTION_SETTED_j

    for option in $@
    do
        case $option in
            -C)           GMAKE_OPTION_SETTED_C=yes ;;
            -w)           GMAKE_OPTION_SETTED_w=yes ;;
            -j)           GMAKE_OPTION_SETTED_j=yes ;;
            -j[1-9])      GMAKE_OPTION_SETTED_j=yes ;;
            -j[1-9][0-9]) GMAKE_OPTION_SETTED_j=yes ;;
        esac
    done

    if [ "$GMAKE_OPTION_SETTED_w" != yes ] ; then
        GMAKE_OPTIONS="$GMAKE_OPTIONS -w"
    fi

    if [ "$GMAKE_OPTION_SETTED_C" != yes ] ; then
        if [ "$PACKAGE_BUILD_IN_BSCRIPT_DIR" != yes ] ; then
            if [ "$STEP_MESSAGE" = 'build for native' ] ; then
                GMAKE_OPTIONS="$GMAKE_OPTIONS -C $NATIVE_BCACHED_DIR"
            else
                GMAKE_OPTIONS="$GMAKE_OPTIONS -C $PACKAGE_BCACHED_DIR"
            fi
        fi
    fi

    if [ "$GMAKE_OPTION_SETTED_j" != yes ] ; then
        GMAKE_OPTIONS="$GMAKE_OPTIONS -j$BUILD_NJOBS"
    fi

    if [ "$LOG_LEVEL" -ge "$LOG_LEVEL_VERY_VERBOSE" ] ; then
        GMAKE_OPTIONS="$GMAKE_OPTIONS --debug V=1"
    fi

    if [ "$EXPORT_COMPILE_COMMANDS_JSON" = yes ] && [ "$BEAR_ENABLED" = yes ] ; then
        run bear -- $GMAKE $GMAKE_OPTIONS $*
    else
        run         $GMAKE $GMAKE_OPTIONS $*
    fi
}

# https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html#cross-compiling
# https://cmake.org/cmake/help/latest/variable/CMAKE_EXPORT_COMPILE_COMMANDS.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_ROOT_PATH.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_PREFIX_PATH.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_INSTALL_PREFIX.html
# https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html
# https://cmake.org/cmake/help/latest/variable/BUILD_SHARED_LIBS.html
# https://cmake.org/cmake/help/latest/command/enable_testing.html?highlight=build_testing
# https://developer.android.com/ndk/guides/cmake
# run in a subshell
cmakew() {
    CMAKE_CONFIG_OPTIONS="-Wno-dev -DCMAKE_EXPORT_COMPILE_COMMANDS=$CMAKE_EXPORT_COMPILE_COMMANDS -DBUILD_TESTING=OFF"

    # https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_DEBUG_MODE.html
    if [ "$LOG_LEVEL" -ge "$LOG_LEVEL_VERBOSE" ] ; then
        CMAKE_CONFIG_OPTIONS="$CMAKE_CONFIG_OPTIONS -DCMAKE_FIND_DEBUG_MODE=TRUE"
    fi

    if [ "$STEP_MESSAGE" = 'build for native' ] ; then
        CMAKE_CONFIG_OPTIONS="$CMAKE_CONFIG_OPTIONS -DBUILD_SHARED_LIBS=OFF -DCMAKE_INSTALL_PREFIX='$NATIVE_INSTALL_DIR'"

        CMAKE_CONFIG_OPTIONS="$CMAKE_CONFIG_OPTIONS -S $PACKAGE_BSCRIPT_DIR -B $NATIVE_BCACHED_DIR"

        run $CMAKE $CMAKE_CONFIG_OPTIONS $@ &&
        run $CMAKE --build   "$NATIVE_BCACHED_DIR" -- -j$BUILD_NJOBS &&
        run $CMAKE --install "$NATIVE_BCACHED_DIR"
    else
        case $BUILD_TYPE in
            debug)   CMAKE_CONFIG_OPTIONS="$CMAKE_CONFIG_OPTIONS -DCMAKE_BUILD_TYPE=Debug"   ;;
            release) CMAKE_CONFIG_OPTIONS="$CMAKE_CONFIG_OPTIONS -DCMAKE_BUILD_TYPE=Release" ;;
        esac

        if [ "$LOG_LEVEL" -eq "$LOG_LEVEL_QUIET" ] ; then
            CMAKE_CONFIG_OPTIONS="$CMAKE_CONFIG_OPTIONS -DCMAKE_VERBOSE_MAKEFILE=OFF -DCMAKE_COLOR_MAKEFILE=OFF"
        else
            CMAKE_CONFIG_OPTIONS="$CMAKE_CONFIG_OPTIONS -DCMAKE_VERBOSE_MAKEFILE=ON  -DCMAKE_COLOR_MAKEFILE=ON"
        fi

        case $TARGET_ANDROID_ARCH in
            armv7a)  CMAKE_SYSTEM_PROCESSOR=armv7-a ;;
            aarch64) CMAKE_SYSTEM_PROCESSOR=aarch64 ;;
            i686)    CMAKE_SYSTEM_PROCESSOR=i686    ;;
            x86_64)  CMAKE_SYSTEM_PROCESSOR=x86_64  ;;
        esac

        # https://cmake.org/cmake/help/latest/variable/CMAKE_PROJECT_INCLUDE.html
        CMAKE_PROJECT_INCLUDE="$PACKAGE_WORKING_DIR/project-after.cmake"

        # https://cmake.org/cmake/help/latest/variable/CMAKE_FIND_LIBRARY_SUFFIXES.html
        case $LINK_TYPE in
            static-only)     printf 'set(CMAKE_FIND_LIBRARY_SUFFIXES ".a")\n'          > "$CMAKE_PROJECT_INCLUDE" ;;
            static-prefered) printf 'set(CMAKE_FIND_LIBRARY_SUFFIXES ".a" ".so")\n'    > "$CMAKE_PROJECT_INCLUDE" ;;
            shared-only)     printf 'set(CMAKE_FIND_LIBRARY_SUFFIXES ".so")\n'         > "$CMAKE_PROJECT_INCLUDE" ;;
            shared-prefered) printf 'set(CMAKE_FIND_LIBRARY_SUFFIXES ".so" ".a")\n'    > "$CMAKE_PROJECT_INCLUDE" ;;
        esac

        if [ "$LOG_LEVEL" -gt 0 ] ; then
            run cat "$CMAKE_PROJECT_INCLUDE"
        fi

        CMAKE_SHARED_LINKER_FLAGS="$(printf '%s\n' "$LDFLAGS" | sed -e 's|--static||g' -e 's|-static||g')"

        CMAKE_CONFIG_OPTIONS="$CMAKE_CONFIG_OPTIONS
        -DCMAKE_TOOLCHAIN_FILE='$ANDROID_NDK_HOME/build/cmake/android.toolchain.cmake'
        -DCMAKE_PROJECT_INCLUDE='$CMAKE_PROJECT_INCLUDE'
        -DCMAKE_SYSTEM_PROCESSOR=$CMAKE_SYSTEM_PROCESSOR
        -DCMAKE_FIND_ROOT_PATH='$CMAKE_FIND_ROOT_PATH'
        -DCMAKE_FIND_ROOT_PATH_MODE_PROGRAM=NEVER
        -DCMAKE_INSTALL_PREFIX='$PACKAGE_INSTALL_DIR'
        -DCMAKE_C_FLAGS='$CFLAGS $CPPFLAGS'
        -DCMAKE_CXX_FLAGS='$CXXFLAGS $CPPFLAGS'
        -DCMAKE_SHARED_LINKER_FLAGS='$CMAKE_SHARED_LINKER_FLAGS'
        -DCMAKE_EXE_LINKER_FLAGS='$LDFLAGS'
        -DBUILD_SHARED_LIBS=ON
        -DANDROID_TOOLCHAIN=clang
        -DANDROID_ABI=$TARGET_ANDROID_ABI
        -DANDROID_ARM_NEON=TRUE
        -DANDROID_STL=c++_shared
        -DANDROID_PLATFORM=$TARGET_ANDROID_API"

        if [ "$CCACHE_ENABLED" = yes ] ; then
            CMAKE_CONFIG_OPTIONS="$CMAKE_CONFIG_OPTIONS -DNDK_CCACHE=$CCACHE"
        fi

        CMAKE_CONFIG_OPTIONS="$CMAKE_CONFIG_OPTIONS -S $PACKAGE_BSCRIPT_DIR -B $PACKAGE_BCACHED_DIR"

        run $CMAKE $CMAKE_CONFIG_OPTIONS $@ &&
        run $CMAKE --build   "$PACKAGE_BCACHED_DIR" -- -j$BUILD_NJOBS &&
        run $CMAKE --install "$PACKAGE_BCACHED_DIR"
    fi
}

# https://github.com/xmake-io/xmake/issues/2003
# run in a subshell
xmakew() {
    XMAKE_CONFIG_OPTIONS="$@"

    XMAKE_CONFIG_OPTION_CLEAN=
    XMAKE_CONFIG_OPTION_MODE=
    XMAKE_CONFIG_OPTION_vD=

    for arg in $@
    do
        case $arg in
            -c|--clean)  XMAKE_CONFIG_OPTION_CLEAN=set ;;
            -m|--mode=*) XMAKE_CONFIG_OPTION_MODE=set  ;;
            -vD)         XMAKE_CONFIG_OPTION_vD=set ;;
        esac
    done

    if [ "$LOG_LEVEL" -ge "$LOG_LEVEL_VERY_VERBOSE" ] && [ -z "$XMAKE_CONFIG_OPTION_vD" ] ; then
        XMAKE_CONFIG_OPTIONS="$XMAKE_CONFIG_OPTION_vD -vD"
    fi

    if [ -z "$XMAKE_CONFIG_OPTION_CLEAN" ] ; then
        XMAKE_CONFIG_OPTIONS="$XMAKE_CONFIG_OPTIONS --clean"
    fi

    if [ -z "$XMAKE_CONFIG_OPTION_MODE" ] ; then
        XMAKE_CONFIG_OPTIONS="$XMAKE_CONFIG_OPTIONS --mode=$BUILD_TYPE"
    fi

    if [ "$STEP_MESSAGE" = 'build for native' ] ; then
        run $XMAKE config $XMAKE_CONFIG_OPTIONS --project=$PACKAGE_BSCRIPT_DIR --buildir=$NATIVE_BCACHED_DIR &&
        run $XMAKE --jobs=$BUILD_NJOBS &&
        run $XMAKE install -o "$NATIVE_INSTALL_DIR"
    else
        XMAKE_CONFIG_OPTIONS="$XMAKE_CONFIG_OPTIONS --plat=android --arch=$TARGET_ANDROID_ABI --ndk_sdkver=$TARGET_ANDROID_API --toolchain=ndk --ndk=$ANDROID_NDK_HOME --buildir=$PACKAGE_BCACHED_DIR --cc=$CC --cxx=$CXX --cflags='$CFLAGS' --cxxflags='$CXXFLAGS' --ldflags='$LDFLAGS' --shflags='$LDFLAGS'"

        run $XMAKE config $XMAKE_CONFIG_OPTIONS &&
        run $XMAKE --jobs=$BUILD_NJOBS &&
        run $XMAKE install -o "$PACKAGE_INSTALL_DIR"
    fi
}

# https://mesonbuild.com/Cross-compilation.html
# run in a subshell
mesonw() {
    case $TARGET_ANDROID_ARCH in
        armv7*)
            HOST_MACHINE_CPU_FAMILY='arm'
            HOST_MACHINE_CPU_NAME="$TARGET_ANDROID_ARCH"
            ;;
        arm64*|aarch64)
            HOST_MACHINE_CPU_FAMILY='aarch64'
            HOST_MACHINE_CPU_NAME='armv8a'
            ;;
        i386|i686)
            HOST_MACHINE_CPU_FAMILY='x86'
            HOST_MACHINE_CPU_NAME="$TARGET_ANDROID_ARCH"
            ;;
        x86_64)
            HOST_MACHINE_CPU_FAMILY='x86_64'
            HOST_MACHINE_CPU_NAME="$TARGET_ANDROID_ARCH"
            ;;
    esac

    MESON_CROSS_FILE="$PACKAGE_BCACHED_DIR/cross-file"

    cat > "$MESON_CROSS_FILE" <<EOF
[host_machine]
system = 'android'
endian = 'little'
cpu_family = '$HOST_MACHINE_CPU_FAMILY'
cpu = '$HOST_MACHINE_CPU_NAME'

[binaries]
c = '$CC'
cpp = '$CXX'
ar = '$AR'
strip = '$STRIP'
cmake = '$CMAKE'
pkgconfig = '$PKG_CONFIG'

[built-in options]
c_args = $(to_meson_array $CFLAGS $CPPFLAGS)
c_link_args = $(to_meson_array $LDFLAGS)
cpp_args = $(to_meson_array $CXXFLAGS $CPPFLAGS)
cpp_link_args = $(to_meson_array $LDFLAGS)
EOF

    MESON_SETUP_ARGS="--prefix=$PACKAGE_INSTALL_DIR --buildtype=$BUILD_TYPE --backend=ninja --pkg-config-path=$PKG_CONFIG_PATH --build.pkg-config-path=$PKG_CONFIG_PATH_FOR_BUILD --cross-file=$MESON_CROSS_FILE -Dlibdir=lib"

    MESON_SETUP_ARGS="$MESON_SETUP_ARGS -Ddefault_library=both"

    case $LINK_TYPE in
        static-only|static-prefered) MESON_SETUP_ARGS="$MESON_SETUP_ARGS --prefer-static"
    esac

    MESON_COMPILE_ARGS="-C $PACKAGE_BCACHED_DIR -j $BUILD_NJOBS"
    MESON_INSTALL_ARGS="-C $PACKAGE_BCACHED_DIR"

    if [ "$LOG_LEVEL" -ge 3 ] ; then
        MESON_COMPILE_ARGS="$MESON_COMPILE_ARGS -v"
    fi

    run "$MESON" setup   "$MESON_SETUP_ARGS" "$@" "$PACKAGE_BCACHED_DIR" "$PACKAGE_BSCRIPT_DIR" &&
    run "$MESON" compile "$MESON_COMPILE_ARGS" &&
    run "$MESON" install "$MESON_INSTALL_ARGS"
}

to_meson_array() {
    RESULT=

    for item in "$@"
    do
        if [ -z "$RESULT" ] ; then
            RESULT="'$item'"
        else
            RESULT="$RESULT, '$item'"
        fi
    done

    printf '[%s]\n' "$RESULT"
}

# https://developer.android.com/ndk/guides/ndk-build
ndk_build() {
    # https://developer.android.com/ndk/downloads/revision_history#expandable-33
    # Android NDK r7 (November 2011)
    if [ "$CCACHE_ENABLED" = yes ] ; then
        export NDK_CCACHE=$CCACHE
    fi

    NDK_BUILD_ARGS="NDK_PROJECT_PATH=. APP_BUILD_SCRIPT=Android.mk APP_PLATFORM=android-$TARGET_ANDROID_API APP_STRIP_MODE=-S"

    case $BUILD_TYPE in
        debug)   NDK_BUILD_ARGS="$NDK_BUILD_ARGS NDK_DEBUG=1" ;;
        release) NDK_BUILD_ARGS="$NDK_BUILD_ARGS NDK_DEBUG=0" ;;
    esac

    if [ "$EXPORT_COMPILE_COMMANDS_JSON" = yes ] ; then
        NDK_BUILD_ARGS="$NDK_BUILD_ARGS GEN_COMPILE_COMMANDS_DB=true"
    fi

    if [ "$LOG_LEVEL" -ge "$LOG_LEVEL_VERBOSE" ] ; then
        NDK_BUILD_ARGS="$NDK_BUILD_ARGS V=1"
    fi

    if [ "$LOG_LEVEL" -ge "$LOG_LEVEL_VERY_VERBOSE" ] ; then
        NDK_BUILD_ARGS="$NDK_BUILD_ARGS NDK_LOG=1"
    fi

    run ndk-build $NDK_BUILD_ARGS
}

########################################################################

# must run in a subshell
# ndk_info <ANDROID-NDK-HOME>
ndk_info() {
    [ -z "$1" ] && abort 1 "Usage: ndk_info <ANDROID-NDK-HOME> , <ANDROID-NDK-HOME> is not given."
    [ -d "$1" ] || abort 1 "'$1' was expected to be a directory, but it was not."

    NDK_SOURCE_PROPERTIES_FILEPATH="$1/source.properties"

    [ -e "$NDK_SOURCE_PROPERTIES_FILEPATH" ] || abort 1 "'$NDK_SOURCE_PROPERTIES_FILEPATH' was expected to be exist, but it was not."
    [ -f "$NDK_SOURCE_PROPERTIES_FILEPATH" ] || abort 1 "'$NDK_SOURCE_PROPERTIES_FILEPATH' was expected to be a regular file, but it was not."

    ANDROID_CMAKE_TOOLCHAIN_FILE="$1/build/cmake/android.toolchain.cmake"

    [ -e "$ANDROID_CMAKE_TOOLCHAIN_FILE" ] || abort 1 "'$ANDROID_CMAKE_TOOLCHAIN_FILE' was expected to be exist, but it was not."
    [ -f "$ANDROID_CMAKE_TOOLCHAIN_FILE" ] || abort 1 "'$ANDROID_CMAKE_TOOLCHAIN_FILE' was expected to be a regular file, but it was not."

    ANDROID_NDK_VERSION=
    ANDROID_NDK_VERSION_MAJOR=

    ANDROID_NDK_VERSION="$(sed -n '/Pkg.Revision/p' "$NDK_SOURCE_PROPERTIES_FILEPATH" | sed  's/Pkg\.Revision = \(.*\).*/\1/')"

    if [ -z "$ANDROID_NDK_VERSION" ] ; then
        abort 1 "no Pkg.Revision property in $NDK_SOURCE_PROPERTIES_FILEPATH"
    fi

    ANDROID_NDK_VERSION_MAJOR="$(printf '%s\n' "$ANDROID_NDK_VERSION" | cut -d. -f1)"

    if [ "$NATIVE_OS_KIND" = darwin ] ; then
        ANDROID_NDK_TOOLCHAIN_HOST_TAG='darwin-x86_64'
    else
        ANDROID_NDK_TOOLCHAIN_HOST_TAG="$NATIVE_OS_KIND-$NATIVE_OS_ARCH"
    fi

    ANDROID_NDK_TOOLCHAIN_ROOT="$1/toolchains/llvm/prebuilt/$ANDROID_NDK_TOOLCHAIN_HOST_TAG"

    [ -e "$ANDROID_NDK_TOOLCHAIN_ROOT" ] || abort 1 "'$ANDROID_NDK_TOOLCHAIN_ROOT' was expected to be exist, but it was not."
    [ -d "$ANDROID_NDK_TOOLCHAIN_ROOT" ] || abort 1 "'$ANDROID_NDK_TOOLCHAIN_ROOT' was expected to be a directory, but it was not."

    ANDROID_NDK_TOOLCHAIN_BIND="$ANDROID_NDK_TOOLCHAIN_ROOT/bin"

    [ -e "$ANDROID_NDK_TOOLCHAIN_BIND" ] || abort 1 "'$ANDROID_NDK_TOOLCHAIN_BIND' was expected to be exist, but it was not."
    [ -d "$ANDROID_NDK_TOOLCHAIN_BIND" ] || abort 1 "'$ANDROID_NDK_TOOLCHAIN_BIND' was expected to be a directory, but it was not."

    ANDROID_NDK_SYSROOT="$ANDROID_NDK_TOOLCHAIN_ROOT/sysroot"

    [ -e "$ANDROID_NDK_SYSROOT" ] || abort 1 "'$ANDROID_NDK_SYSROOT' was expected to be exist, but it was not."
    [ -d "$ANDROID_NDK_SYSROOT" ] || abort 1 "'$ANDROID_NDK_SYSROOT' was expected to be a directory, but it was not."

    #########################################################################################

    ANDROID_NDK_CC="$ANDROID_NDK_TOOLCHAIN_BIND/clang"
    ANDROID_NDK_CXX="$ANDROID_NDK_TOOLCHAIN_BIND/clang++"
    ANDROID_NDK_CPP="$ANDROID_NDK_CC -E"

    # https://github.com/android/ndk/wiki/Changelog-r22
    # https://github.com/android/ndk/wiki/Changelog-r23
    if [ "$ANDROID_NDK_VERSION_MAJOR" -ge 22 ] ; then
        ANDROID_NDK_LD="$ANDROID_NDK_TOOLCHAIN_BIND/ld.lld"
        ANDROID_NDK_AS="$ANDROID_NDK_TOOLCHAIN_BIND/llvm-as"
        ANDROID_NDK_AR="$ANDROID_NDK_TOOLCHAIN_BIND/llvm-ar"
        ANDROID_NDK_NM="$ANDROID_NDK_TOOLCHAIN_BIND/llvm-nm"
        ANDROID_NDK_SIZE="$ANDROID_NDK_TOOLCHAIN_BIND/llvm-size"
        ANDROID_NDK_STRIP="$ANDROID_NDK_TOOLCHAIN_BIND/llvm-strip"
        ANDROID_NDK_RANLIB="$ANDROID_NDK_TOOLCHAIN_BIND/llvm-ranlib"
        ANDROID_NDK_STRINGS="$ANDROID_NDK_TOOLCHAIN_BIND/llvm-strings"
        ANDROID_NDK_OBJDUMP="$ANDROID_NDK_TOOLCHAIN_BIND/llvm-objdump"
        ANDROID_NDK_OBJCOPY="$ANDROID_NDK_TOOLCHAIN_BIND/llvm-objcopy"
        ANDROID_NDK_READELF="$ANDROID_NDK_TOOLCHAIN_BIND/llvm-readelf"
    else
        ANDROID_NDK_LD="$ANDROID_NDK_TOOLCHAIN_BIND/aarch64-linux-android-ld"
        ANDROID_NDK_AS="$ANDROID_NDK_TOOLCHAIN_BIND/aarch64-linux-android-as"
        ANDROID_NDK_AR="$ANDROID_NDK_TOOLCHAIN_BIND/aarch64-linux-android-ar"
        ANDROID_NDK_NM="$ANDROID_NDK_TOOLCHAIN_BIND/aarch64-linux-android-nm"
        ANDROID_NDK_SIZE="$ANDROID_NDK_TOOLCHAIN_BIND/aarch64-linux-android-size"
        ANDROID_NDK_STRIP="$ANDROID_NDK_TOOLCHAIN_BIND/aarch64-linux-android-strip"
        ANDROID_NDK_RANLIB="$ANDROID_NDK_TOOLCHAIN_BIND/aarch64-linux-android-ranlib"
        ANDROID_NDK_STRINGS="$ANDROID_NDK_TOOLCHAIN_BIND/aarch64-linux-android-strings"
        ANDROID_NDK_OBJDUMP="$ANDROID_NDK_TOOLCHAIN_BIND/aarch64-linux-android-objdump"
        ANDROID_NDK_OBJCOPY="$ANDROID_NDK_TOOLCHAIN_BIND/aarch64-linux-android-objcopy"
        ANDROID_NDK_READELF="$ANDROID_NDK_TOOLCHAIN_BIND/aarch64-linux-android-readelf"
    fi

    #########################################################################################

    ANDROID_NDK_SUPPORTED_SDK_API_LEVEL_ALL="$(ls "$ANDROID_NDK_TOOLCHAIN_BIND" | sed -n '/aarch64-linux-android[1-9][0-9]-clang++/p' | cut -d- -f3 | sed 's/android//')"
    ANDROID_NDK_SUPPORTED_MIN_SDK_API_LEVEL="$(printf '%s\n' "$ANDROID_NDK_SUPPORTED_SDK_API_LEVEL_ALL" | sort | head -n 1)"
    ANDROID_NDK_SUPPORTED_MAX_SDK_API_LEVEL="$(printf '%s\n' "$ANDROID_NDK_SUPPORTED_SDK_API_LEVEL_ALL" | sort | tail -n 1)"

    #########################################################################################

    cat <<EOF
ANDROID_NDK_HOME='$1'
ANDROID_NDK_ROOT='$1'
ANDROID_NDK_VERSION='$ANDROID_NDK_VERSION'
ANDROID_NDK_VERSION_MAJOR='$ANDROID_NDK_VERSION_MAJOR'
ANDROID_NDK_TOOLCHAIN_ROOT='$ANDROID_NDK_TOOLCHAIN_ROOT'
ANDROID_NDK_TOOLCHAIN_BIND='$ANDROID_NDK_TOOLCHAIN_BIND'
ANDROID_NDK_SYSROOT='$ANDROID_NDK_SYSROOT'
ANDROID_NDK_CC='$ANDROID_NDK_CC'
ANDROID_NDK_CXX='$ANDROID_NDK_CXX'
ANDROID_NDK_CPP='$ANDROID_NDK_CPP'
ANDROID_NDK_LD='$ANDROID_NDK_LD'
ANDROID_NDK_AS='$ANDROID_NDK_AS'
ANDROID_NDK_AR='$ANDROID_NDK_AR'
ANDROID_NDK_NM='$ANDROID_NDK_NM'
ANDROID_NDK_SIZE='$ANDROID_NDK_SIZE'
ANDROID_NDK_STRIP='$ANDROID_NDK_STRIP'
ANDROID_NDK_RANLIB='$ANDROID_NDK_RANLIB'
ANDROID_NDK_STRINGS='$ANDROID_NDK_STRINGS'
ANDROID_NDK_OBJDUMP='$ANDROID_NDK_OBJDUMP'
ANDROID_NDK_OBJCOPY='$ANDROID_NDK_OBJCOPY'
ANDROID_NDK_READELF='$ANDROID_NDK_READELF'
ANDROID_NDK_SUPPORTED_MIN_SDK_API_LEVEL='$ANDROID_NDK_SUPPORTED_MIN_SDK_API_LEVEL'
ANDROID_NDK_SUPPORTED_MAX_SDK_API_LEVEL='$ANDROID_NDK_SUPPORTED_MAX_SDK_API_LEVEL'
EOF
}

# must run in a subshell
# ndkinfo [ANDROID-NDK-HOME]
ndkinfo() {
    if [ -z "$1" ] ; then
        if [ -n "$ANDROID_NDK_ROOT" ] && ndk_info "$ANDROID_NDK_ROOT" ; then
            return 0
        fi

        if [ -n "$ANDROID_NDK_HOME" ] && ndk_info "$ANDROID_NDK_HOME" ; then
            return 0
        fi

        return 1
    else
        ndk_info "$1"
    fi
}

# }}}
##############################################################################
# {{{ ndk-pkg setup

__setup() {
    NATIVE_OS_KIND="$(uname -s | tr A-Z a-z)"
    NATIVE_OS_ARCH="$(uname -m)"

    if [ "$(id -u)" -ne 0 ] ; then
        sudo=sudo
    else
        sudo=
    fi

    #################################################################################

    unset FETCH_TOOL

    for FETCH_TOOL in curl wget http lynx aria2c axel
    do
        if command -v "$FETCH_TOOL" > /dev/null ; then
            break
        else
            unset FETCH_TOOL
        fi
    done

    if [ -z "$FETCH_TOOL" ] ; then
        abort 1 "no any fetch tool[curl, wget, http, lynx, aria2c, axel] found."
    else
        unset FETCH_TOOL
    fi

    ##################################################################################

    WORKING_DIR="$NDKPKG_HOME/run/$$"

    run rm -rf     "$WORKING_DIR"
    run install -d "$WORKING_DIR/core"
    run cd         "$WORKING_DIR"

    ##################################################################################

    wfetch 'https://raw.githubusercontent.com/leleliu008/uppm/master/latest-release' --output-name=uppm-latest-release

    ##################################################################################

    UPPM_LATEST_RELEASE_TAGNAME="$(cat uppm-latest-release)"
    UPPM_LATEST_RELEASE_VERSION="$(printf '%s\n' "$UPPM_LATEST_RELEASE_TAGNAME" | cut -d+ -f1)"

    if [ "$NATIVE_OS_KIND" = darwin ] ; then
        case $(sw_vers -productVersion | cut -d. -f1) in
            10) X='10.15' ;;
            11) X='11.0'  ;;
            12) X='12.0'  ;;
            13) X='13.0'  ;;
            *)  X='13.0'  ;;
        esac

        UPPM_LATEST_RELEASE_ARCHIVE_FILENAME="uppm-${UPPM_LATEST_RELEASE_VERSION}-macos${X}-${NATIVE_OS_ARCH}.tar.xz"
    else
        UPPM_LATEST_RELEASE_ARCHIVE_FILENAME="uppm-${UPPM_LATEST_RELEASE_VERSION}-${NATIVE_OS_KIND}-${NATIVE_OS_ARCH}.tar.xz"
    fi

    wfetch "https://github.com/leleliu008/uppm/releases/download/${UPPM_LATEST_RELEASE_TAGNAME}/${UPPM_LATEST_RELEASE_ARCHIVE_FILENAME}" --output-name="$UPPM_LATEST_RELEASE_ARCHIVE_FILENAME"

    run tar vxf "$UPPM_LATEST_RELEASE_ARCHIVE_FILENAME" --strip-components=1 --no-same-owner -C core

    ##################################################################################

    # https://curl.se/docs/caextract.html
    wfetch 'https://curl.se/ca/cacert.pem' --output-dir=core/etc/ssl/certs

    ##################################################################################

    export SSL_CERT_FILE="$PWD/core/etc/ssl/certs/cacert.pem"

    run core/bin/uppm env
    run core/bin/uppm update

    unset UPPM_PACKAGE_EXEFIND_PATH
    unset UPPM_PACKAGE_ACLOCAL_PATH

    for item in bash coreutils findutils easyutils gawk gsed grep gtar gzip lzip unzip zip xz bzip2 jq yq git curl tree patchelf
    do
        run core/bin/uppm install "$item"

        UPPM_PACKAGE_INSTALLED_DIR="$(core/bin/uppm info "$item" installed-dir)"

        if [ -d "$UPPM_PACKAGE_INSTALLED_DIR/bin" ] ; then
            UPPM_PACKAGE_EXEFIND_PATH="$UPPM_PACKAGE_EXEFIND_PATH:$UPPM_PACKAGE_INSTALLED_DIR/bin"
        fi

        if [ -d "$UPPM_PACKAGE_INSTALLED_DIR/sbin" ] ; then
            UPPM_PACKAGE_EXEFIND_PATH="$UPPM_PACKAGE_EXEFIND_PATH:$UPPM_PACKAGE_INSTALLED_DIR/sbin"
        fi

        if [ -d "$UPPM_PACKAGE_INSTALLED_DIR/share/aclocal" ] ; then
            UPPM_PACKAGE_ACLOCAL_PATH="$UPPM_PACKAGE_ACLOCAL_PATH:$UPPM_PACKAGE_INSTALLED_DIR/share/aclocal"
        fi
    done

    UPPM_PACKAGE_EXEFIND_PATH="${UPPM_PACKAGE_EXEFIND_PATH#':'}"
    UPPM_PACKAGE_ACLOCAL_PATH="${UPPM_PACKAGE_ACLOCAL_PATH#':'}"

    cat > core/env <<EOF
export ACLOCAL_PATH="$UPPM_PACKAGE_ACLOCAL_PATH:\$ACLOCAL_PATH"
export PATH="$UPPM_PACKAGE_EXEFIND_PATH:\$PATH"

# https://git-scm.com/book/en/v2/Git-Internals-Environment-Variables
if [ -d "\$HOME/.uppm/installed/git/libexec/git-core" ] ; then
    export GIT_EXEC_PATH="\$HOME/.uppm/installed/git/libexec/git-core"
    export GIT_TEMPLATE_DIR="\$HOME/.uppm/installed/git/share/git-core/templates"
fi
EOF

    #################################################################################

    if [ -d    "$NDKPKG_CORE_DIR" ] ; then
        rm -rf "$NDKPKG_CORE_DIR"
    fi

    mv core "$NDKPKG_HOME/"

    #################################################################################

    success "ndk-pkg have been succefully setup."
}

# }}}
##############################################################################
# {{{ ndk-pkg help

__help() {
    if command -v base64 > /dev/null ; then
        LOGO_BASE64_ENCODED='ICAgICAgICAgICBfIF8gICAgICAgICAgICAgICBfICAgICAgICAgCiBfIF9fICAgX198IHwgfCBf
XyAgICAgXyBfXyB8IHwgX19fXyBfIAp8ICdfIFwgLyBfYCB8IHwvIC9fX19ffCAnXyBcfCB8LyAv
IF9gIHwKfCB8IHwgfCAoX3wgfCAgIDxfX19fX3wgfF8pIHwgICA8IChffCB8CnxffCB8X3xcX18s
X3xffFxfXCAgICB8IC5fXy98X3xcX1xfXywgfAogICAgICAgICAgICAgICAgICAgICAgfF98ICAg
ICAgICB8X19fLyAK'

        if command -v lolcat > /dev/null ; then
            printf '%s\n' "$LOGO_BASE64_ENCODED" | base64 -d | lolcat -S 350
        elif command -v awk > /dev/null ; then
            printf '%s\n' "$LOGO_BASE64_ENCODED" | base64 -d | lolcat_awk
        else
            printf '%b\n' "${COLOR_BLUE}$(printf '%s\n' "$LOGO_BASE64_ENCODED" | base64 -d)${COLOR_OFF}"
        fi
    fi

    printf '%b\n' "
${COLOR_GREEN}A package manager for Android NDK to build C/C++/Rust/Go project.${COLOR_OFF}

${COLOR_GREEN}ndk-pkg <ACTION> [ARGUMENT...]${COLOR_OFF}

${COLOR_GREEN}ndk-pkg --help${COLOR_OFF}
${COLOR_GREEN}ndk-pkg -h${COLOR_OFF}
    show help of this command.

${COLOR_GREEN}ndk-pkg --version${COLOR_OFF}
${COLOR_GREEN}ndk-pkg -V${COLOR_OFF}
    show version of this command.

${COLOR_GREEN}ndk-pkg env${COLOR_OFF}
    show basic information about this software.

${COLOR_GREEN}ndk-pkg sysinfo${COLOR_OFF}
    show basic information about your current running operation system.

${COLOR_GREEN}ndk-pkg ndkinfo [--ndk-home=<ANDROID-NDK-HOME>]${COLOR_OFF}
    show basic information about the specified location of Android NDK.

    If --ndk-home=<ANDROID-NDK-HOME> is unspecified, then ${COLOR_RED}ANDROID_NDK_ROOT${COLOR_OFF} and ${COLOR_RED}ANDROID_NDK_HOME${COLOR_OFF} environment variable would be checked in order to determine the Android NDK's root directory, if they both are not set or set a empty string, a error will arise.

${COLOR_GREEN}ndk-pkg gen-url-transform-sample${COLOR_OFF}
    generate url-transform sample.

${COLOR_GREEN}ndk-pkg integrate zsh [--output-dir=<DIR>]${COLOR_OFF}
    download a zsh-completion script file to a approprivate location.

${COLOR_GREEN}ndk-pkg update${COLOR_OFF}
    update all the available formula repositories.

${COLOR_GREEN}ndk-pkg upgrade-self${COLOR_OFF}
    upgrade this software.

${COLOR_GREEN}ndk-pkg cleanup${COLOR_OFF}
    delete the unused cached files.


${COLOR_GREEN}ndk-pkg ls-available${COLOR_OFF}
    list all the available packages.

${COLOR_GREEN}ndk-pkg ls-installed${COLOR_OFF}
    list all the installed packages.

${COLOR_GREEN}ndk-pkg ls-outdated${COLOR_OFF}
    list all the outdated  packages.


${COLOR_GREEN}ndk-pkg is-available <PACKAGE-NAME>${COLOR_OFF}
    check if the given package is available.

${COLOR_GREEN}ndk-pkg is-installed <PACKAGE-SPEC>${COLOR_OFF}
    check if the given package is installed.

${COLOR_GREEN}ndk-pkg is-outdated  <PACKAGE-SPEC>${COLOR_OFF}
    check if the given package is outdated.


${COLOR_GREEN}ndk-pkg formula-repo-init <FORMULA-REPO-NAME> <FORMULA-REPO-URL> [--branch=VALUE --pin/--unpin --enable/--disable]${COLOR_OFF}
    create a new empty formula repository.

${COLOR_GREEN}ndk-pkg formula-repo-add  <FORMULA-REPO-NAME> <FORMULA-REPO-URL> [--branch=VALUE --pin/--unpin --enable/--disable]${COLOR_OFF}
    create a new empty formula repository then sync with server.

${COLOR_GREEN}ndk-pkg formula-repo-del  <FORMULA-REPO-NAME>${COLOR_OFF}
    delete the given formula repository.

${COLOR_GREEN}ndk-pkg formula-repo-sync <FORMULA-REPO-NAME>${COLOR_OFF}
    update the given formula repository.

${COLOR_GREEN}ndk-pkg formula-repo-info <FORMULA-REPO-NAME>${COLOR_OFF}
    show information of the given formula repository.

${COLOR_GREEN}ndk-pkg formula-repo-conf <FORMULA-REPO-NAME> [--url=VALUE --branch=VALUE --pin/--unpin --enable/--disable]${COLOR_OFF}
    change the config of the given formula repository.

${COLOR_GREEN}ndk-pkg formula-repo-list${COLOR_OFF}
    list all available formula repositories.


${COLOR_GREEN}ndk-pkg formula-edit <PACKAGE-NAME> --editor=<EDITOR>${COLOR_OFF}
    edit the formula of the given package.

${COLOR_GREEN}ndk-pkg formula <PACKAGE-NAME> [--path] [--yaml] [--json] [<KEY>]${COLOR_OFF}
    show formula of the given available package.


${COLOR_GREEN}ndk-pkg info <PACKAGE-NAME> [--json] [--yaml] [<KEY>]${COLOR_OFF}
    show information of the given package.

${COLOR_GREEN}ndk-pkg info @all [--json] [--yaml]${COLOR_OFF}
    show information of all the available packages.

${COLOR_GREEN}ndk-pkg depends <PACKAGE-NAME> [-t <dot|box|svg|png>] [-o <OUTPUT-PATH>]${COLOR_OFF}
    show the packages that are depended by the given package.

    <OUTPUT-PATH> can be either the filepath or directory where the file will be written to. If <OUTPUT-PATH> is an existing directory or ends with slash, then it will be treated as a directory, otherwize, it will be treated as a filepath.

    If -t <OUTPUT-TYPE> option is not given but -o <OUTPUT-PATH> option is given, if <OUTPUT-PATH> is treated as a directory, then <OUTPU-TYPE> will be box and <OUTPUT-PATH> will be expanded to <OUTPUT-PATH>/<PACKAGE-NAME>-dependencies.box

    If -t <OUTPUT-TYPE> option is not given but -o <OUTPUT-PATH> option is given, if <OUTPUT-PATH> is treated as a filepath, then <OUTPUT-PATH> must ends with one of .dot|.box|.svg|.png

    If -t <OUTPUT-TYPE> and -o <OUTPUT-PATH> options both are not given, <OUTPU-TYPE> will be box and output to stdout.


${COLOR_GREEN}ndk-pkg search <REGULAR-EXPRESSION-PATTERN>${COLOR_OFF}
    search all available packages whose name matches the given regular expression pattern.


${COLOR_GREEN}ndk-pkg fetch <PACKAGE-NAME>${COLOR_OFF}
    download all the resources of the given package to the local cache.

${COLOR_GREEN}ndk-pkg fetch @all${COLOR_OFF}
    download all the resources of all the available packages to the local cache.


${COLOR_GREEN}ndk-pkg install <PACKAGE-NAME>/android-<ANDROID-API>/<ANDROID-ABIS>... [INSTALL-OPTIONS]${COLOR_OFF}
    install the given packages.

    ${COLOR_RED}C and C++ compiler for native build should be installed by yourself using your system's default package manager before running this command.${COLOR_OFF}

    ${COLOR_RED}<ANDROID-ABIS>${COLOR_OFF} is a comma-separated list, any combination of arm64-v8a, armeabi-v7a, x86_64, x86

    INSTALL-OPTIONS:
        ${COLOR_BLUE}--ndk-home=<ANDROID-NDK-HOME>${COLOR_OFF}
            If --ndk-home=<ANDROID-NDK-HOME> is unspecified, then ${COLOR_RED}ANDROID_NDK_ROOT${COLOR_OFF} and ${COLOR_RED}ANDROID_NDK_HOME${COLOR_OFF} environment variable would be checked in order to determine the Android NDK's root directory, if they both are not set or set a empty string or are invalid android ndk home directory, a specific version of Android NDK will be automatically installed for you via uppm.

        ${COLOR_BLUE}--jobs=N${COLOR_OFF}
            set the number of jobs you can run in parallel.

        ${COLOR_BLUE}-q${COLOR_OFF}
            silent mode. no any messages will be output to terminal.

        ${COLOR_BLUE}-v${COLOR_OFF}
            verbose mode. many messages will be output to terminal.

        ${COLOR_BLUE}-vv${COLOR_OFF}
            very verbose mode. many many messages will be output to terminal.

        ${COLOR_BLUE}--build-type=<debug|release>${COLOR_OFF}
            set build type.

        ${COLOR_BLUE}--link-type=<static-only|shared-only|static-prefered|shared-prefered>${COLOR_OFF}
            link static or shared library.

        ${COLOR_BLUE}--disable-ccache${COLOR_OFF}
            do not use ccache.

        ${COLOR_BLUE}--export-compile-commands-json${COLOR_OFF}
            generates compile_commands.json

        ${COLOR_BLUE}--dry-run${COLOR_OFF}
            do not actually install the package.

        ${COLOR_BLUE}--keep-working-dir${COLOR_OFF}
            do not delete the working directory even if this package is successfully installed.

    USAGE-EXAMPLES:
        ndk-pkg install zlib/android-21/arm64-v8a
        ndk-pkg install zlib/android-21/arm64-v8a,armeabi-v7a
        ndk-pkg install zlib/android-21/arm64-v8a,armeabi-v7a,x86_64
        ndk-pkg install zlib/android-21/arm64-v8a,armeabi-v7a,x86_64,x86

${COLOR_GREEN}ndk-pkg reinstall <PACKAGE-NAME>/android-<ANDROID-API>/<ANDROID-ABIS>... [INSTALL-OPTIONS]${COLOR_OFF}
    reinstall the given packages.

${COLOR_GREEN}ndk-pkg upgrade   <PACKAGE-NAME>/android-<ANDROID-API>/<ANDROID-ABIS>... [INSTALL-OPTIONS]${COLOR_OFF}
    upgrade the given packages or all outdated packages.

${COLOR_GREEN}ndk-pkg uninstall <PACKAGE_SPEC>...${COLOR_OFF}
    uninstall the given packages.


${COLOR_GREEN}ndk-pkg receipt <PACKAGE-SPEC> [--path] [--yaml] [--json] [<KEY>]${COLOR_OFF}
    show receipt of the given installed package.

${COLOR_GREEN}ndk-pkg tree <PACKAGE-SPEC> [--dirsfirst | -L N]${COLOR_OFF}
    list the installed files of the given installed package in a tree-like format.

${COLOR_GREEN}ndk-pkg logs <PACKAGE-SPEC>${COLOR_OFF}
    show logs of the given installed package.

${COLOR_GREEN}ndk-pkg pack <PACKAGE-SPEC> [--keep-working-dir] [-t <zip|tar.gz|tar.xz|tar.lz|tar.bz2>] [-o <OUTPUT-PATH>]${COLOR_OFF}
    pack the given installed package.

    <OUTPUT-PATH> can be either the filepath or directory where the packed archive will be written to. If <OUTPUT-PATH> is an existing directory or ends with slash, then it will be treated as a directory, otherwize, it will be treated as a filepath.

    If -t <OUTPUT-TYPE> option is not given but -o <OUTPUT-PATH> option is given, if <OUTPUT-PATH> is treated as a filepath, then <OUTPUT-PATH> must ends with one of .tar.gz|.tar.xz|.tar.lz|.tar.bz2|.tgz|.txz|.tlz|.tbz2|zip

    If -t <OUTPUT-TYPE> option is not given but -o <OUTPUT-PATH> option is given, if <OUTPUT-PATH> is treated as a directory, then <OUTPUT-TYPE> will be .tar.xz, OUTPUT-PATH will be expanded to <OUTPUT-PATH>/\$NDKPKG_HOME/packed/\$PACKAGE_NAME-\$PACKAGE_VERSION-\$TARGET_PLATFORM_NAME-\$TARGET_PLATFORM_ARCH.tar.xz

    If -t <OUTPUT-TYPE> and -o <OUTPUT-PATH> options both are not given, <OUTPUT-TYPE> will be .tar.xz, OUTPUT-PATH will be \$NDKPKG_HOME/packed/\$PACKAGE_NAME-\$PACKAGE_VERSION-\$TARGET_PLATFORM_NAME-\$TARGET_PLATFORM_ARCH.tar.xz


${COLOR_GREEN}ndk-pkg export <PACKAGE-NAME>/android-<ANDROID-API>/<ANDROID-ABIS> [--ndk-home=<ANDROID-NDK-HOME>] [-o <OUTPUT-PATH>]${COLOR_OFF}
    export the given installed package as google prefab aar.

    For details about google prefab, please visit https://google.github.io/prefab/

    For details about the aar file contains google prefab, please visit https://developer.android.com/studio/projects/android-library#aar-contents

    ${COLOR_RED}<ANDROID-ABIS>${COLOR_OFF} is a comma-separated list, any combination of arm64-v8a, armeabi-v7a, x86_64, x86

    If ${COLOR_RED}--ndk-home=<ANDROID-NDK-HOME>${COLOR_OFF} is unspecified, then ${COLOR_RED}ANDROID_NDK_ROOT${COLOR_OFF} and ${COLOR_RED}ANDROID_NDK_HOME${COLOR_OFF} environment variable would be checked in order to determine the Android NDK's root directory, if they both are not set or set a empty string or are invalid android ndk home directory, a specific version of Android NDK will be automatically installed for you via uppm.

    ${COLOR_RED}<OUTPUT-PATH>${COLOR_OFF} can be either the filepath or directory where the aar file will be written to.

    If ${COLOR_RED}<OUTPUT-PATH>${COLOR_OFF} is an existing directory or ends with slash, then it will be treated as a directory, otherwize, it will be treated as a filepath.

    If ${COLOR_RED}<OUTPUT-PATH>${COLOR_OFF} is treated as a directory, then it would be expanded to <OUTPUT-PATH>/<PACKAGE-NAME>-<PACKAGE-VERSION>.aar

${COLOR_GREEN}ndk-pkg deploy <PACKAGE-NAME>/android-<ANDROID-API>/<ANDROID-ABIS> [--ndk-home=<ANDROID-NDK-HOME>] [--debug] [--keep-working-dir] [--dry-run] [--local=<DIR>] [--remote < REMOTE-CONFIG-FILE]${COLOR_OFF}
    export the given installed package as google prefab aar then deploy it to Maven Repository.

    For details about google prefab, please visit https://google.github.io/prefab/

    For details about the aar file contains google prefab, please visit https://developer.android.com/studio/projects/android-library#aar-contents

    ${COLOR_RED}<ANDROID-ABIS>${COLOR_OFF} is a comma-separated list, any combination of arm64-v8a, armeabi-v7a, x86_64, x86

    If ${COLOR_RED}--ndk-home=<ANDROID-NDK-HOME>${COLOR_OFF} is unspecified, then ${COLOR_RED}ANDROID_NDK_ROOT${COLOR_OFF} and ${COLOR_RED}ANDROID_NDK_HOME${COLOR_OFF} environment variable would be checked in order to determine the Android NDK's root directory, if they both are not set or set a empty string or are invalid android ndk home directory, a specific version of Android NDK will be automatically installed for you via uppm.

    If ${COLOR_RED}--remote${COLOR_OFF} is specified, the aar file would be deployed to Sonatype OSSRH (https://s01.oss.sonatype.org/)

    If ${COLOR_RED}--local=<DIR>${COLOR_OFF} is specified, the aar file would be deployed to the specified location of Maven Local Repository.

    If neither ${COLOR_RED}--local=<DIR>${COLOR_OFF} nor ${COLOR_RED}--remote${COLOR_OFF} is specified, the aar file would be deployed to your default Maven Local Repository (usually under ~/.m2/repository/ directory, depending on your settings.xml configuration)

    REMOTE-CONFIG-FILE contains following content:

    SERVER_ID=
    SERVER_URL=
    SERVER_USERNAME=
    SERVER_PASSWORD=
    GPG_PASSPHRASE=


==================
Naming explanation
==================

${COLOR_GREEN}PACKAGE-SPEC${COLOR_OFF}
    a formatted string that has form: <ANDROID-SPEC>/<PACKAGE-NAME>

${COLOR_GREEN}PACKAGE-NAME${COLOR_OFF}
    must match regular expression pattern ^[A-Za-z0-9+-_.@]{1,50}$

${COLOR_GREEN}ANDROID-SPEC${COLOR_OFF}
    a formatted string that has form: android-<ANDROID-API>/<ANDROID-ABI>

${COLOR_GREEN}ANDROID-API${COLOR_OFF}
    indicates which minimum Android SDK API level would be built for or can run on.

    Reference: https://developer.android.com/tools/releases/platforms

${COLOR_GREEN}ANDROID-ABI${COLOR_OFF}
    indicates which Android ABI would be built for or can run on.

    Reference: https://developer.android.com/ndk/guides/abis


=====================
Environment variables
=====================

${COLOR_GREEN}HOME${COLOR_OFF}
    This environment variable already have been set on the most operating systems, if not set or set a empty string, you will receive an error message.

${COLOR_GREEN}PATH${COLOR_OFF}
    This environment variable already have been set on the most operating systems, if not set or set a empty string, you will receive an error message.

${COLOR_GREEN}ANDROID_NDK_ROOT and ANDROID_NDK_HOME${COLOR_OFF}
    If --ndk-home=<ANDROID-NDK-HOME> is unspecified, then ${COLOR_RED}ANDROID_NDK_ROOT${COLOR_OFF} and ${COLOR_RED}ANDROID_NDK_HOME${COLOR_OFF} environment variable would be checked in order to determine the Android NDK's root directory, if they both are not set or set a empty string or are invalid android ndk home directory, a specific version of Android NDK will be automatically installed for you via uppm.

${COLOR_GREEN}NDKPKG_URL_TRANSFORM${COLOR_OFF}

    If you want to change the request url, you can set this environment variable. It is very useful for chinese users.

    exmaple:

    ${COLOR_RED}export NDKPKG_URL_TRANSFORM=/path/of/url-transform${COLOR_OFF}

    /path/of/url-transform command would be invoked as /path/of/url-transform <URL>

    /path/of/url-transform command must output a <URL>

    a url-transform sample can be generated via running ${COLOR_RED}ndk-pkg gen-url-transform-sample${COLOR_OFF}

${COLOR_GREEN}NDKPKG_XTRACE${COLOR_OFF}
    for debugging purposes. to enable set -x: ${COLOR_RED}export NDKPKG_XTRACE=1${COLOR_OFF}

${COLOR_GREEN}NDKPKG_DEFAULT_TARGET_ANDROID_SPEC${COLOR_OFF}
    some sub-commands of ndk-pkg need <PACKAGE-SPEC> to be specified. <PACKAGE-SPEC> has the form <PACKAGE-NAME>:<TARGET-ANDROID-SPEC>, To simplify the usage, you are allowed to omit :<TARGET-ANDROID-SPEC>. If :<TARGET-ANDROID-SPEC> is omitted, this environment variable will be used, if this environment variable is not set, then android-21:arm64-v8a will be used as the default.

    <TARGET-ANDROID-SPEC> has the form android-<MIN-SDK-API-LEVEL>:<ANDROID-ABI>

    Example:

    ${COLOR_RED}export NDKPKG_DEFAULT_TARGET_ANDROID_SPEC='android-21:arm64-v8a'${COLOR_OFF}

    References:

    https://developer.android.com/tools/releases/platforms
    https://developer.android.com/ndk/guides/abis

${COLOR_GREEN}GOPROXY${COLOR_OFF}
    Example: ${COLOR_RED}export GOPROXY='https://goproxy.cn'${COLOR_OFF}


=======
Caveats
=======

This software is being actively developed. It's in beta stage and may not be stable. Some features are subject to change without notice.

This software can NOT run on Android, musl-libc based GNU/Linux, FreeBSD, OpenBSD, NetBSD due to lack of Android NDK for these platforms.

This software can NOT run on Cygwin and MSYS2 due to CMake: Builds hosted on 'CYGWIN' not supported. Android-Determine.cmake

Please do NOT place your own files under ~/.ndk-pkg directory, as ndk-pkg will change files under ~/.ndk-pkg directory without notice.

Please do NOT run ndk-pkg command in parallell to avoid generating dirty data.
    "

    if [ -z "$1" ] ; then
        exit
    else
        exit "$1"
    fi
}

# }}}
##############################################################################
# {{{ ndk-pkg main

main() {
    set -e

    [ -n "$NDKPKG_XTRACE" ] && set -x

    [ -z "$HOME" ] && abort 1 'HOME environment variable is not set.'

    NDKPKG="$CURRENT_SCRIPT_FILEPATH"

    NDKPKG_VERSION=0.6.0

    NDKPKG_ZSH_COMPLETION_SCRIPT_URL='https://raw.githubusercontent.com/leleliu008/ndk-pkg/master/ndk-pkg-zsh-completion'
    NDKPKG_OFFICAL_FORMULA_REPO_URL='https://github.com/leleliu008/ndk-pkg-formula-repository-offical-core.git'
    NDKPKG_UPGRAGE_URL='https://raw.githubusercontent.com/leleliu008/ndk-pkg/master/ndk-pkg'

    NDKPKG_HOME="$HOME/.ndk-pkg"

    NDKPKG_FORMULA_REPO_ROOT="$NDKPKG_HOME/repos.d"
    NDKPKG_PACKAGE_INSTALLED_ROOT="$NDKPKG_HOME/installed"
    NDKPKG_DOWNLOADS_DIR="$NDKPKG_HOME/downloads"

    NDKPKG_CORE_DIR="$NDKPKG_HOME/core"
    NDKPKG_CORE_BIN_DIR="$NDKPKG_CORE_DIR/bin"

    # https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_set_default_verify_paths.html
    if [ -f "$NDKPKG_CORE_DIR/etc/ssl/certs/cacert.pem" ] ; then
        export SSL_CERT_FILE="$NDKPKG_CORE_DIR/etc/ssl/certs/cacert.pem"
    fi

    if [ -n "$NDKPKG_URL_TRANSFORM" ] ; then
        export UPPM_URL_TRANSFORM="$NDKPKG_URL_TRANSFORM"
    fi

    UPPM="$NDKPKG_CORE_BIN_DIR/uppm"

    TIMESTAMP_UNIX="$(date +%s)"

    #########################################################################################

    NDKPKG_ACTION="$1"

    case $1 in
        ''|--help|-h)
            __help
            return 0
            ;;
        --version|-V)
            printf '%s\n' "$NDKPKG_VERSION"
            return 0
            ;;
        env)
            cat <<EOF
ndk-pkg.version: $NDKPKG_VERSION
ndk-pkg.homedir: $NDKPKG_HOME
ndk-pkg.exepath: $NDKPKG
ndk-pkg.website: https://github.com/leleliu008/ndk-pkg
EOF
            return 0
            ;;
        setup)
            shift
            __setup "$@"
            return 0
            ;;
        gen-url-transform-sample)
            shift
            __gen_url_transform_sample "$@"
            return 0
            ;;
    esac

    #########################################################################################

    if [ -z "$CARGO_HOME" ] ; then
        bppend_to_PATH "$HOME/.cargo/bin"
    else
        bppend_to_PATH "$CARGO_HOME/bin"
    fi

    # pip install --user <PKG>
    bppend_to_PATH "$HOME/.local/bin"

    # cpan install to default local location
    bppend_to_PATH "$HOME/perl5/bin"

    #########################################################################################

    if [ -f "$NDKPKG_CORE_DIR/env" ] ; then
        .   "$NDKPKG_CORE_DIR/env"
    else
        abort 1 "please run ${COLOR_GREEN}$_0 setup${COLOR_OFF} command first, then try again."
    fi

    #########################################################################################

    # https://www.gnu.org/software/automake/manual/html_node/Macro-Search-Path.html
    if [ -z  "$ACLOCAL_PATH" ] ; then
        export ACLOCAL_PATH="$NDKPKG_CORE_DIR/share/aclocal"
    else
        export ACLOCAL_PATH="$NDKPKG_CORE_DIR/share/aclocal:$ACLOCAL_PATH"
    fi

    bppend_to_PATH "$NDKPKG_CORE_BIN_DIR"

    #########################################################################################

    NATIVE_OS_KIND="$(sysinfo kind)"
    NATIVE_OS_TYPE="$(sysinfo type)"
    NATIVE_OS_CODE="$(sysinfo code)"
    NATIVE_OS_NAME="$(sysinfo name)"
    NATIVE_OS_VERS="$(sysinfo vers)"
    NATIVE_OS_ARCH="$(sysinfo arch)"
    NATIVE_OS_NCPU="$(sysinfo ncpu)"
    NATIVE_OS_LIBC="$(sysinfo libc)"
    NATIVE_OS_EUID="$(id -u)"
    NATIVE_OS_EGID="$(id -g)"

    if [ "$NATIVE_OS_EUID" -ne 0 ] ; then
        sudo=sudo
    fi

    #########################################################################################

    case $1 in
        ndkinfo)
            shift

            unset USER_SPECIFIED_ANDROID_NDK_HOME

            for arg in "$@"
            do
                case $arg in
                    --ndk-home=*)
                        USER_SPECIFIED_ANDROID_NDK_HOME="${arg#*=}"
                        ;;
                esac
            done

            if [ -z "$USER_SPECIFIED_ANDROID_NDK_HOME" ] ; then
                ndkinfo
            else
                ndkinfo "$USER_SPECIFIED_ANDROID_NDK_HOME"
            fi

            ;;
        sysinfo)
            shift
            sysinfo
            ;;

        ls-available) shift; __list_available_packages ;;
        ls-installed) shift; __list_installed_packages ;;
        ls-outdated)  shift; __list__outdated_packages ;;

        is-available) shift; is_package_available "$@" ;;

        is-installed)
            shift
            PACKAGE_SPEC=
            PACKAGE_SPEC="$(inspect_package_spec "$1")"
            is_package_installed "$PACKAGE_SPEC"
            ;;

        is-outdated)
            shift
            PACKAGE_SPEC=
            PACKAGE_SPEC="$(inspect_package_spec "$1")"
            is_package__outdated "$PACKAGE_SPEC"
            ;;

        formula) shift; __show_formula_of_the_given_package "$@" ;;
        receipt) shift; __show_receipt_of_the_given_package "$@" ;;

        formula-edit) shift; __edit_formula_of_the_given_package "$@" ;;

        update)            shift; __sync_available_formula_repositories "$@" ;;
        formula-repo-list) shift; __list_available_formula_repositories "$@" ;;
        formula-repo-info) shift; __info_the_given_formula_repository "$@" ;;
        formula-repo-conf) shift; __conf_the_given_formula_repository "$@" ;;
        formula-repo-sync) shift; __sync_the_given_formula_repository "$@" ;;
        formula-repo-init)
            shift

            case $1 in
                offical-*) abort 1 "ndk-pkg formula repository name that starts with 'offical-' is reserved for ndk-pkg offical formula repository, please use other name."
            esac

            __create_a_formula_repository "$@"
            ;;
        formula-repo-add)
            shift

            case $1 in
                offical-*) abort 1 "ndk-pkg formula repository name that starts with 'offical-' is reserved for ndk-pkg offical formula repository, please use other name."
            esac

            __create_a_formula_repository_then_sync_it "$@"
            ;;
        formula-repo-del)
            shift
            __delete_a_formula_repository "$@"
            ;;

        cleanup) shift; __cleanup ;;

        search)  shift; __search_packages "$*" ;;

        install) shift;   __install_the_given_packages "$@" ;;
      reinstall) shift; __reinstall_the_given_packages "$@" ;;
      uninstall) shift; __uninstall_the_given_packages "$@" ;;

        upgrade-self)
            shift
            __upgrade_self "$NDKPKG_UPGRAGE_URL" "$@"
            ;;
        upgrade)
            shift
            __upgrade_packages "$@"
            ;;
        integrate)
            shift
            case $1 in
                zsh)
                    shift
                    __integrate_zsh_completions "$NDKPKG_ZSH_COMPLETION_SCRIPT_URL" "$@"
                    ;;
                *)  abort 1 "ndk-pkg integrate $1: not support."
            esac
            ;;
        homepage) shift;  __show_or_open_homepage_of_the_given_package "$@" ;;
        depends)  shift; __show_packages_depended_by_the_given_package "$@" ;;
        fetch)    shift;        __fetch_resources_of_the_given_package "$@" ;;

        export) shift; __export_google_prefab_aar_for_the_given_installed_packages "$@" ;;
        deploy) shift; __deploy_google_prefab_aar_for_the_given_installed_packages "$@" ;;

        logs) shift; __logs_the_given_installed_package "$@" ;;
        pack) shift; __pack_the_given_installed_package "$@" ;;
        tree) shift; __tree_the_given_installed_package "$@" ;;

        info)
            shift
            __show_information_of_the_given_package "$@"
            ;;
        *)  abort 1 "unrecognized argument: $1"
    esac
}

main "$@"
